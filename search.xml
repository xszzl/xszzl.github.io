<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IO多路复用</title>
    <url>/2020/02/09/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><img src="/images/select%E8%AE%B2%E8%A7%A3.png" alt="select讲解"></p>
<p>虚线上半部分是在监听socket服务端，准备5个文件描述符用作通道，其中max标识的是文件描述符中编号最大的编号。然后再设置rset，rset是一个bitmap，我们将使用了的文件描述符的编号位置置为1，比如使用了1，2，5，7，9文件描述符，那么rset就是01100101010000…，默认为1024位。我们使用rset来代替fds数组</p>
<p>然后就是select函数，该函数是一个阻塞函数，其参数分别是最大文件描述符编号+1，读文件描述符集合，写文件描述符集合，异常文件描述符集合和超时时间。其作用是将rset的内容从<strong>用户态拷贝到内核态</strong>，内核来负责每一个文件描述符是否有数据，如果没有就阻塞，如果有就将对应的rset位置位，然后select返回。</p>
<p>在接下来的for循环里，就是读取有数据的fd，然后进行处理。</p>
<p>select的<strong>缺点</strong>：</p>
<ul>
<li>bitmap为1024位，有上限</li>
<li>rset被内核修改过不可重用</li>
<li>将rset拷贝到内核态存在用户态到内核态的开销</li>
<li>不知道哪个fd有数据需要遍历</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><img src="/images/poll%E8%AE%B2%E8%A7%A3.png" alt="poll讲解"></p>
<p>poll()的工作原理和select是一样的，但是它使用了结构体而不是fds数组和bitmap。在结构体中存放了fd，events和revents。</p>
<p>poll函数的参数分别是pollfds数组，数组长度和超时时间。也是将其拷贝到内核态，当有数据的时候将结构体的revent置位为POLLIN，然后返回。</p>
<p>因此其上限将是数组个数上限，远远不止1024位；同时每次处理完成之后revents都会被置为0，因此pollfds是可以重用的，但是对于内核态和用户态的切换带来的开销和遍历数组还是没法避免。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="/images/epoll%E8%AE%B2%E8%A7%A3.png" alt="epoll讲解"></p>
<p>epoll使用的结构epoll_event同样有fd和events字段。</p>
<p>epoll_create(num)用于创建长度为num的容器epfd，epoll_ctl()用于对创建的epfd进行操作，这里是增加数据，数据包括fd和events。</p>
<p>epfd会在用户态和内存态共享区域，因此消除了状态切换的开销。</p>
<p>epoll_wait()用于监听，当有数据的时候也需要置位，但置位实现是通过重排，将有数据的fd放到最前面，同时该函数有返回值，其值为有数据的fd个数，因此在处理的时候只需要遍历nfds次，从而减少了遍历个数。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-MySQL-必知必会</title>
    <url>/2020/02/09/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-MySQL-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h2 id="MySQL-必知必会"><a href="#MySQL-必知必会" class="headerlink" title="MySQL - 必知必会"></a>MySQL - 必知必会</h2><h3 id="MySQL的索引由了解吗"><a href="#MySQL的索引由了解吗" class="headerlink" title="MySQL的索引由了解吗"></a>MySQL的索引由了解吗</h3><a id="more"></a>

<p>索引是对数据库表中一列或者多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息。InnoDB存储引擎的索引模型底层实现数据结构为B+树，所有数据都是存储在B+树中的。</p>
<h4 id="为什么底层数据结构使用B-树，而不是B树"><a href="#为什么底层数据结构使用B-树，而不是B树" class="headerlink" title="为什么底层数据结构使用B+树，而不是B树"></a>为什么底层数据结构使用B+树，而不是B树</h4><ul>
<li>B+树是B树的变种，B+树的非叶子节点只用来保存索引，不存储数据，所有的数据都保存在叶子节点；而非B树的非叶子节点也会保存数据。这样就使得B+树的查询效率更加稳定，均从根节点到叶子节点的路径。</li>
<li>B+树的内部节点并没有指向关键字的具体信息的指针，因此其内部节点相对B树更小，同样空间可以读入更多的节点，所以B+树的磁盘读写代价更低。</li>
</ul>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><p>聚簇索引也称为主键索引，其索引树的叶子节点中村的是整行数据，表中行的物理顺序与键值的逻辑顺序相同。一个表只能包含一个聚集索引。</p>
<p>非聚簇索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引。</p>
<p>如果使用非聚集索引查询，需要先查到主键值，然后根据主键值去查询主键索引，即需要查询两次。</p>
<h4 id="索引的最左前缀原则"><a href="#索引的最左前缀原则" class="headerlink" title="索引的最左前缀原则"></a>索引的最左前缀原则</h4><p>在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。</p>
<h4 id="索引下推："><a href="#索引下推：" class="headerlink" title="索引下推："></a>索引下推：</h4><p>在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。MySQL5.6引入的索引下推优化，（联合索引前提）可以在索引遍历过程中，对索引中包含的其余字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提升查询效率。</p>
<h4 id="创建索引有哪些开销？"><a href="#创建索引有哪些开销？" class="headerlink" title="创建索引有哪些开销？"></a>创建索引有哪些开销？</h4><p>经常需要作为条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（<strong>数据页的分裂与合并</strong>），对性能造成影响。</p>
<h3 id="MySQL常见的存储引擎"><a href="#MySQL常见的存储引擎" class="headerlink" title="MySQL常见的存储引擎"></a>MySQL常见的存储引擎</h3><p>MySQL中最常见的存储引擎有InnoDB和MyISAM，他们的区别如下：</p>
<ul>
<li>MyISAM不支持事务；InnoDB是事务类型的存储引擎</li>
<li>MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁</li>
<li>MyISAM引擎不支持外键；InnoDB支持外键</li>
<li>对于count(*)查询来说MyISAM更有优势，因为其保存了行数</li>
<li>InnoDB是为了处理巨大数据量时的最大性能设计的存储引擎</li>
<li>MyISAM支持全文索引（FULLTEXT）；InnoDB不支持</li>
</ul>
<h4 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h4><p><img src="/images/MySQL%E6%9E%B6%E6%9E%84.png" alt="MySQL架构"></p>
<ul>
<li><strong>连接器</strong>：验证客户端权限，建立和断开MySQL连接</li>
<li><strong>分析器</strong>：进行SQL语句的语法分析</li>
<li><strong>优化器</strong>：选择索引，生成具体的SQL语句执行结果</li>
<li><strong>执行器</strong>：操作存储引擎，执行SQL，返回执行结果</li>
<li><strong>存储引擎层</strong>：各个不同的存储引擎都提供了一些读写接口来操作数据库</li>
</ul>
<h3 id="MySQL中where、group-by、having关键字"><a href="#MySQL中where、group-by、having关键字" class="headerlink" title="MySQL中where、group by、having关键字"></a>MySQL中where、group by、having关键字</h3><ul>
<li>where子句用来筛选from子句中指定的操作所产生的的行</li>
<li>group by 子句用来分组where子句的输出</li>
<li>having子句用来从分组的结果中筛选行</li>
</ul>
<p><strong>having和where的区别：</strong></p>
<ul>
<li>语法类似，where搜索条件在进行分组操作之前应用；having搜索条件在进行分组操作之后应用</li>
<li>having可以包含聚合函数sum、avg、max等</li>
<li>having子句限制的是组，而不是行</li>
</ul>
<p><strong>当同时含有where子句、group by 子句 、having子句及聚集函数时，执行顺序如下：</strong></p>
<ul>
<li>执行where子句查找符合条件的数据</li>
<li>使用group by子句对数据进行分组</li>
<li>对group by子句形成的组运行聚集函数计算每一组的值</li>
<li>最后用having子句去掉不符合条件的组</li>
</ul>
<h3 id="MySQL的日志模块binlog和redo-log"><a href="#MySQL的日志模块binlog和redo-log" class="headerlink" title="MySQL的日志模块binlog和redo log"></a>MySQL的日志模块binlog和redo log</h3><p>在MySQL的使用中，更新操作也是很频繁的，如果每一次更新操作都根据条件找到对应的记录，然后将记录更新，再写回磁盘，那么<strong>IO成本以及查找记录的成本</strong>都很高。所以，出现了日志模块，即我们的update更新操作是先写日志，在合适的时间去写磁盘，日志更新完毕就将执行结果返回给了客户端。</p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log是InnoDB引擎持有的日志模块，redo log是物理日志，记录了某个数据页上做了哪些修改。InnoDB的redo log是固定大小的。从头开始写，写到末尾就回到开头循环写。</p>
<p>InnoDB的redo log保证了数据库发送异常重启之后，之前提交的记录不会丢失，这个能力称为crash-safe。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>binlog是Server层自带的日志模块，binlog是逻辑日志，记录本次修改的原始逻辑，说白了就是SQL语句。binlog是追加写的形式，可以写多个文件，不会覆盖之前的日志。通过mysqlbinlog可以解析查看binlog日志。binlog日志文件的格式：statement、rot、mixed。</p>
<ul>
<li><strong>statement</strong>格式的binlog记录是完整的SQL语句，优点是日志文件小，性能较好，缺点也很明显，那就是准确性差，遇到SQL语句中有now()等函数会导致不准确</li>
<li><strong>row</strong>格式的binlog中记录的是数据行的实际数据的变更，优点是数据记录准确，缺点就是日志文件较大。</li>
<li><strong>mixed</strong>格式就是前两者混合。</li>
</ul>
<h4 id="为什么MySQL会突然变慢一下"><a href="#为什么MySQL会突然变慢一下" class="headerlink" title="为什么MySQL会突然变慢一下"></a>为什么MySQL会突然变慢一下</h4><p>当内存数据页和磁盘数据页的内容不一致的时候，这个内存页就是“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，这个时候的内存页就是”干净页“。</p>
<p>当redo log写满了，要flush脏页，也就是把内存里的数据写入磁盘，会导致MySQL执行速度突然变慢一瞬间。</p>
<h3 id="MySQL事务的特性"><a href="#MySQL事务的特性" class="headerlink" title="MySQL事务的特性"></a>MySQL事务的特性</h3><ul>
<li><strong>原子性</strong>：事务作为一个整体被执行，要么全部执行，要么全部不执行</li>
<li><strong>一致性</strong>：保证数据库状态从一个一致性状态转变为另一个一致性状态</li>
<li><strong>隔离性</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li>
<li><strong>持久性</strong>：一个事务一旦提交，对数据库的修改应该永久保存</li>
</ul>
<h4 id="多个事务并发会产生的问题"><a href="#多个事务并发会产生的问题" class="headerlink" title="多个事务并发会产生的问题"></a>多个事务并发会产生的问题</h4><ul>
<li><strong>丢失更新</strong>：两个不同事务同时获得相同数据，然后在各自事务中修改了该数据，那么先提交的事务更新会被后提交的事务的更新给覆盖掉，导致数据更新丢失</li>
<li><strong>脏读</strong>：事务A读取了事务B未提交的数据，由于事务B回滚，导致了事务A的数据不一致，结果事务A出现了脏读</li>
<li><strong>不可重复读</strong>：一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次得到的结果数值不同，因为别的事务更新了该数据，并且提交了事务</li>
<li><strong>幻读</strong>：事务A读的时候读出了N条记录，事务B在事务A执行的过程中增加了1条，事务A再读的时候就变成了N+1条，这种情况就叫做幻读</li>
</ul>
<h4 id="MySQL数据库事务的隔离级别"><a href="#MySQL数据库事务的隔离级别" class="headerlink" title="MySQL数据库事务的隔离级别"></a>MySQL数据库事务的隔离级别</h4><ul>
<li><strong>读未提交</strong>：允许脏读取，如果一个事务已经开始写数据，则另一个数据不允许同时进行写操作，但允许其他事务读取此行数据。一级封锁，写数据上X锁，直到事务结束。</li>
<li><strong>读已提交</strong>：允许不可重复读取，但不允许脏读取。读取数据的事务允许其他事务继续访问改行数据，但是未提交的写事务将会禁止其他事务访问该行。在一级封锁的基础上，读数据上S锁，直到读取完毕。</li>
<li><strong>可重复读</strong>：禁止不可重复读取和脏读取，但是有时可能出现幻读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止其他任何事务。在二级封锁的基础上，读数据上S锁，直到事务结束。</li>
<li><strong>序列化</strong>：提供严格的事务隔离。他要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</li>
</ul>
<h3 id="MySQL中的锁机制"><a href="#MySQL中的锁机制" class="headerlink" title="MySQL中的锁机制"></a>MySQL中的锁机制</h3><h4 id="独占锁（排他锁），X锁"><a href="#独占锁（排他锁），X锁" class="headerlink" title="独占锁（排他锁），X锁"></a>独占锁（排他锁），X锁</h4><p>独占锁锁定的资源只允许进行锁定操作的程序使用，其他任何对它的操作均不会被接收。独占锁一直到事务结束才能被释放。</p>
<p>在select命令中使用独占锁的SQL语句为：select … for update;</p>
<h4 id="共享锁，也叫S锁"><a href="#共享锁，也叫S锁" class="headerlink" title="共享锁，也叫S锁"></a>共享锁，也叫S锁</h4><p>共享锁就是其锁定的资源可以被其他用户读取，但是其他不用不能修改。如果在select查询语句中要手动加入共享锁，其语句为select … lock in share mode;</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>MySQL中的死锁主要是<strong>多个事务使用行级锁对某行数据加锁造成的</strong></p>
<p><strong>业务逻辑上的死锁解决方案：</strong></p>
<ul>
<li>指定锁的获取顺序</li>
<li>大事务拆分成各个小事务</li>
<li>在同一个事务中，一次锁定尽量多的资源，减少死锁概率</li>
<li>给表建立合适的索引以及降低事务的隔离级别等</li>
</ul>
<p><strong>数据库的设置来解决死锁</strong>：</p>
<ul>
<li>通过参数innodb_lock_wait_timeout根据实际业务场景来设置超时时间，InnoDB引擎默认值是50s</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数Innodb_deadlock_detect设置为on</li>
</ul>
<h4 id="行级锁什么时候会锁住整个表"><a href="#行级锁什么时候会锁住整个表" class="headerlink" title="行级锁什么时候会锁住整个表"></a><strong>行级锁什么时候会锁住整个表</strong></h4><p>InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</p>
<h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><p><strong>悲观锁</strong>：利用数据库的锁机制实现，在整个数据处理过程中都加入锁，以保持排他性</p>
<p><strong>乐观锁</strong>：乐观锁可以利用CAS操作实现，在操作数据的时候进行一个比较，按照当前事务中的数据和数据库表中的该数据是否一致来决定是否要执行本次操作。</p>
<h4 id="乐观锁的ABA问题"><a href="#乐观锁的ABA问题" class="headerlink" title="乐观锁的ABA问题"></a>乐观锁的ABA问题</h4><p>ABA问题是指当前事务读取该行数据时是A，经过别的事务修改成B，但是当前事务要更新数据的时候，该行数据又被别的事务修改为A，事实上数据行是发生过改变的，存在并发问题。</p>
<p>ABA问题可以通过基于<strong>数据版本</strong>记录机制来解决。也就是为数据增加一个版本标识。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。根据当前事务的数据版本号和数据库中数据的版本号对比来决定是否更新数据。</p>
<p>与给当前数据增加一个数据版本类似，我们也可以增加基于时间戳机制来解决ABA问题，通过时间戳来记录当前数据行变化。</p>
<h4 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h4><p>一般情况下，我们遇到一个SQL异常的时候，比如说执行时间超时等，可以通过<strong>explain</strong>查看当前SQL语句的执行情况。explain +SQL语句可以查看当前的SQL语句使用的索引以及其扫描了多少行数据。</p>
<h3 id="MySQL建表的约束条件"><a href="#MySQL建表的约束条件" class="headerlink" title="MySQL建表的约束条件"></a>MySQL建表的约束条件</h3><ul>
<li><strong>主键约束</strong>：唯一性，非空性</li>
<li><strong>唯一约束</strong>：唯一性，可以空</li>
<li><strong>检查约束</strong>：对该列数据的范围、格式的限制</li>
<li><strong>默认约束</strong>：该数据的默认值</li>
<li><strong>外键约束</strong>：需要建立两表间的关系并引用主表的列</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Web开发安全</title>
    <url>/2020/02/09/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Web%E5%BC%80%E5%8F%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="Web开发安全"><a href="#Web开发安全" class="headerlink" title="Web开发安全"></a>Web开发安全</h2><h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><a id="more"></a>


<p>XSS跨站脚本攻击是一种常见的安全漏洞，恶意攻击者在用户提交的数据中加入一些代码，将代码嵌入到了Web页面中，从而可以盗取用户资料，控制用户行为或者破坏页面结构和样式等。为了和CSS区分，这里把攻击的第一个字母改成了X，于是叫做XSS。</p>
<h4 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h4><ul>
<li><strong>存储型</strong>：攻击者将恶意代码存储到了数据库中，在响应浏览器请求的时候返回恶意代码，并且执行。这种攻击常见于带有用户保存数据的网站功能。</li>
<li><strong>反射型</strong>：将恶意代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行。</li>
<li><strong>DOM型</strong>：取出和执行恶意代码由浏览器端完成，属于前端JS的安全漏洞。</li>
</ul>
<h4 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h4><ul>
<li>对重要的cookie设置httpOnly，防止客户端通过document.cookie读取cookie</li>
<li>对输入内容的特点字符进行编码，前后端都可以对传入的内容进行过滤，去掉带js等字段的输入</li>
</ul>
<h3 id="CSRF跨站请求伪造"><a href="#CSRF跨站请求伪造" class="headerlink" title="CSRF跨站请求伪造"></a>CSRF跨站请求伪造</h3><p>XSS相当于控制了站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。</p>
<p><img src="/images/CSRF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CSRF示意图"></p>
<h4 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h4><ul>
<li><strong>Referer头验证</strong>：在HTTP头中有一个字段叫Referer，他记录了该HTTP请求的来源地址。不靠谱，Referer可以被改变</li>
<li><strong>Token验证</strong>：服务器发送给客户端一个Token，客户端提交的表单中带着这个Token。如果这个Token不合法，那么服务器拒绝这个请求。</li>
<li><strong>双重Cookie验证</strong>：利用恶意网站无法获取cookie信息，仅可冒用的特点，我们将cookie中的参数取出来，加入到请求参数中，服务端进行校验，如果参数中没有附加额外的cookie中的参数，那么就拒绝请求。</li>
</ul>
<h3 id="SSRF服务端请求伪造"><a href="#SSRF服务端请求伪造" class="headerlink" title="SSRF服务端请求伪造"></a>SSRF服务端请求伪造</h3><p>SSRF是一种由攻击者构造请求，利用服务端发起的一种安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统。</p>
<p><img src="/images/SSRF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SSRF示意图"></p>
<h4 id="SSRF产生原因"><a href="#SSRF产生原因" class="headerlink" title="SSRF产生原因"></a>SSRF产生原因</h4><p>SSRF产生的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如指定URL地址获取网页文本内容，加载指定地址的图片和文档等。</p>
<h4 id="SSRF漏洞危害"><a href="#SSRF漏洞危害" class="headerlink" title="SSRF漏洞危害"></a>SSRF漏洞危害</h4><p>因为外网借助了服务端来实现了对内网服务器的访问，所以很多操作都可以进行，包括如下的危害：</p>
<ul>
<li>对服务器所在的内网进行端口扫描，获取一些服务的banner信息等</li>
<li>攻击运行在内网或者本地的应用程序</li>
<li>对内网WEB应用进行指纹识别，通过访问默认文件实现</li>
<li>下载内网的一些资源文件等。</li>
</ul>
<h4 id="SSRF的防御"><a href="#SSRF的防御" class="headerlink" title="SSRF的防御"></a>SSRF的防御</h4><ul>
<li>对错误信息进行统一处理，避免用户可以根据错误信息来判断远端服务器的端口状态</li>
<li>对请求的端口进行限制，限定为HTTP常用的端口，比如80，443，8080等</li>
<li>设定IP黑名单。避免应用被用来获取内网数据，攻击内网</li>
<li>禁用不需要的协议。仅仅允许HTTP和HTTPS请求</li>
<li>对返回信息进行有效过滤等</li>
</ul>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是指通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器，执行恶意的SQL命令。</p>
<h4 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h4><ul>
<li>使用预编译语句，比如MyBatis中的SQL语句使用#代替$符号</li>
<li>使用安全的存储过程来防止SQL注入</li>
<li>对客户端的输入进行数据类型的检查等</li>
</ul>
<h3 id="在浏览器中输入一个网址之后发送了什么"><a href="#在浏览器中输入一个网址之后发送了什么" class="headerlink" title="在浏览器中输入一个网址之后发送了什么"></a>在浏览器中输入一个网址之后发送了什么</h3><p>在浏览器中输入一个网址，首先要做的就是域名解析，也就是域名-&gt;IP的解析，依次查看了浏览器缓存，系统缓存，hosts文件，路由器缓存，递归搜索根域名服务器，直到找到最终的ip地址。</p>
<p>然后就是TCP协议的三次握手建立连接。由浏览器发送一个HTTP请求；经由路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器；服务器处理该HTTP请求，返回一个HTML文件；浏览器解析该HTML文件，并且渲染显示在浏览器端。</p>
<h4 id="HTTP协议和TCP协议的关系与区别"><a href="#HTTP协议和TCP协议的关系与区别" class="headerlink" title="HTTP协议和TCP协议的关系与区别"></a>HTTP协议和TCP协议的关系与区别</h4><p>HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接。HTTP协议提供了封装或显示数据的具体形式；TCP协议提供了网络通信的能力。两个计算机之间的交流其实就是两个端口之间的数据通信，具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</p>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Web开发安全</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-网络协议-入门</title>
    <url>/2020/02/08/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="网络协议-入门"><a href="#网络协议-入门" class="headerlink" title="网络协议 - 入门"></a>网络协议 - 入门</h2><h3 id="简单说下OSI七层协议模型"><a href="#简单说下OSI七层协议模型" class="headerlink" title="简单说下OSI七层协议模型"></a>简单说下OSI七层协议模型</h3><a id="more"></a>

<p>OSI七层模型包括应用层，表示层，会话层，传输层，网络层，数据链路层以及物理层。</p>
<ul>
<li><strong>应用层：</strong>由用户自己规定，<strong>规定各个应用之间消息传递的形式</strong>等，包括各机互访协议，分布式数据库协议等。常见的应用层协议有HTTP协议和FTP等。</li>
<li><strong>表示层：</strong>在满足用户需求的基础上，尽可能的节省传输费用而设置的，比如传输压缩文件，jpeg或者加密文件等格式。</li>
<li><strong>会话层：</strong>用于建立和拆除会话。</li>
<li><strong>传输层：</strong>负责将来自会话层的消息传递给网络层，<strong>常见的传输层协议有TCP和UDP等协议。</strong></li>
<li><strong>网络层：</strong>规定通信网内的路由选择等方式，建立用户间的信息报传输设施。常见的网络层协议有IP，ICMP以及ARP等协议。</li>
<li><strong>数据链路层：</strong>与建立数据传输链路相关。</li>
<li><strong>物理层：</strong>规定一些机电性能，也包括工作方式如双工、单工或半双工，建立通信的启动和终止等。</li>
</ul>
<h3 id="TCP-IP协议有了解吗"><a href="#TCP-IP协议有了解吗" class="headerlink" title="TCP/IP协议有了解吗"></a>TCP/IP协议有了解吗</h3><p>TCP/IP协议是一系列网络协议的总称，是网络通信的基本骨架。TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为<strong>应用层，传输层，网络层以及链路层</strong>。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p>
<h4 id="ARP协议（地址解析协议）"><a href="#ARP协议（地址解析协议）" class="headerlink" title="ARP协议（地址解析协议）"></a>ARP协议（地址解析协议）</h4><p>根据IP地址获取MAC地址，将目标的IP地址在链路层进行包装，生成以太网数据包，在同一个子网内进行广播出去，各个主机拿到IP地址和自己的IP地址对比，若一样，则返回自己的MAC地址。注意，MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间。</p>
<h4 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h4><p>ARP的寻址必须是在同一个子网内，我们可以通过IP协议来确定是否是同一个子网。如果不是同一个子网，则通过网关将数据包多次转发到对应的子网中，完成这个路由协议的物理设备就是路由器。</p>
<h3 id="三次挥手和四次握手"><a href="#三次挥手和四次握手" class="headerlink" title="三次挥手和四次握手"></a>三次挥手和四次握手</h3><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p>
<p><img src="/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p><img src="/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h4 id="四次挥手主动方为什么需要等待2MSL"><a href="#四次挥手主动方为什么需要等待2MSL" class="headerlink" title="四次挥手主动方为什么需要等待2MSL"></a>四次挥手主动方为什么需要等待2MSL</h4><p><strong>MSL表示最大报文生存周期</strong>，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p>主动关闭方需要等待2MSL是为了，防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>位于传输层的TCP协议是面向连接的，可靠的传输协议，拥有着确认机制。理论上，每发一个数据包都会收到其对应的确认包，然后才可以继续发送数据。</p>
<p>在三次握手阶段，双方互相将自己的<strong>最大可接收的数据量</strong>告诉对方，也就是自己的<strong>数据接收缓冲池</strong>的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知，利用滑动窗口机制有效提高通信效率。</p>
<h3 id="TCP和UDP协议的区别"><a href="#TCP和UDP协议的区别" class="headerlink" title="TCP和UDP协议的区别"></a>TCP和UDP协议的区别</h3><ul>
<li>TCP协议进行数据通信之前需要三次握手建立连接，UDP协议不需要建立连接即可发送数据。</li>
<li>TCP有确认机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。</li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li>
</ul>
<h4 id="UDP协议的应用"><a href="#UDP协议的应用" class="headerlink" title="UDP协议的应用"></a>UDP协议的应用</h4><p>UDP协议由于传输不需要建立连接，资源消耗较小。常用在<strong>视频或者语音传输</strong>中，<strong>域名解析服务DNS</strong>都使用了UDP协议。</p>
<h3 id="一个网络数据包包括哪些"><a href="#一个网络数据包包括哪些" class="headerlink" title="一个网络数据包包括哪些"></a>一个网络数据包包括哪些</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%8C%85.png" alt="数据包"></p>
<h3 id="TCP协议中的数据包分片和重组功能"><a href="#TCP协议中的数据包分片和重组功能" class="headerlink" title="TCP协议中的数据包分片和重组功能"></a>TCP协议中的数据包分片和重组功能</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p>
<h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。</p>
<p>分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达，因为同一个包的所有分片都具有相同的ID。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p>
<ul>
<li><strong>MTU: Maxitum Transmission Unit 最大传输单元</strong></li>
<li><strong>MSS: Maxitum Segment Size 最大分段大小</strong>，MSS就是TCP数据包每次能够传输的最大数据分段。</li>
<li><img src="/images/%E5%88%86%E7%89%87%E9%87%8D%E7%BB%84.png" alt="分片重组"></li>
</ul>
<h3 id="TCP协议的拥塞避免算法"><a href="#TCP协议的拥塞避免算法" class="headerlink" title="TCP协议的拥塞避免算法"></a>TCP协议的拥塞避免算法</h3><p><strong>拥塞控制：</strong>防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p>
<p><strong>拥塞避免算法主要有如下两种：</strong></p>
<ul>
<li>慢启动+拥塞避免</li>
<li>快重传+快恢复</li>
</ul>
<h3 id="HTTP和HTTPS协议的区别"><a href="#HTTP和HTTPS协议的区别" class="headerlink" title="HTTP和HTTPS协议的区别"></a>HTTP和HTTPS协议的区别</h3><ul>
<li>HTTP是超文本传输协议，数据明文传输；HTTPS在HTTP的基础上加入了SSL协议，实现数据的加密传输</li>
<li>HTTPS需要申请证书，一般是收费的</li>
<li>HTTP默认使用80端口，而HTTPS默认使用443端口</li>
</ul>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>HTTP是超文本传输协议，是一种无状态的协议，是常见的一种应用层协议。HTTP是一个通信规则，规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。</p>
<p><strong>HTTP请求信息</strong>：HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息</p>
<p><strong>HTTP返回信息</strong>：HTTP返回信息中包括响应协议，HTTP Code以及Content-Type，时间和Cookie等信息。</p>
<h4 id="HTTP请求中的GET和POST方法的区别"><a href="#HTTP请求中的GET和POST方法的区别" class="headerlink" title="HTTP请求中的GET和POST方法的区别"></a>HTTP请求中的GET和POST方法的区别</h4><ul>
<li>GET一般用来从服务器上查询获取资源；POST一般用来更新服务器上的资源</li>
<li>GET方法将参数直接拼接在URL后边，明文显示，可以通过浏览器地址栏直接访问</li>
<li>POST请求用于提交表单，数据不是明文的，安全性更高</li>
<li>GET请求有长度限制，POST请求没有</li>
</ul>
<h4 id="常见的HTTP协议的状态码"><a href="#常见的HTTP协议的状态码" class="headerlink" title="常见的HTTP协议的状态码"></a>常见的HTTP协议的状态码</h4><ul>
<li>200（成功）</li>
<li>302（重定向）：请求重定向到指定网页</li>
<li>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容（根据Last-Modified来判断）</li>
<li>401（未授权）：请求要求身份验证</li>
<li>403（禁止）：服务器拒绝请求（比如死循环了，一直访问）</li>
<li>404（未找到）：服务器找不到请求的页面</li>
<li>405（方法禁用）：POST请求当成了GET请求直接访问</li>
<li>500（服务器内部错误）：有bug导致程序崩溃</li>
<li>502（错误网关）：服务器从上游接到了无效响应</li>
<li>504（网关超时）：nginx请求超时，请求一直没有返回</li>
</ul>
<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><p>HTTP协议是一种无状态的协议，我们可以使用cookie和session来保持会话。用户发起请求，服务端收到请求处理后生成一个sessionid，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。</p>
<p>这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p>
<h4 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h4><p>SSL协议在传输控制层的基础上建立了安全的连接，它作为一种通用可靠的安全解决方案，可与多种应用层协议结合使用，实现应用数据的安全传输。SSL协议分为记录协议，握手协议，警告协议和密码规范改变协议。</p>
<ul>
<li><strong>记录协议</strong>：接收上层协议或下层协议的消息并进行一系列的处理，然后将处理后的消息继续向下或向上传递。主要包括对消息进行加解密，压缩解压缩，分段或者重组等操作。</li>
<li><strong>握手协议</strong>：建立在三次握手之后，为通信双方确立安全连接所需要的安全参数，通常也会在此阶段对通信双方身份的真实性进行验证。</li>
<li><strong>警告协议</strong>：无论是在握手阶段还是在对应用层数据的传输阶段，都有可能出现差错。警告协议规定了在SSL协议工作过程中可能出现的差错、错误的严重等级以及相应的处理方式</li>
<li><strong>密码规范改变协议</strong>：在SSL握手刚开始的时候，加密参数还没确定，消息都是明文传送的。双方协商好加密参数后，在发送握手结束消息之前，需要发送一个密码规范改变消息来通知对方随后的消息都使用刚刚协商好的加密算法和加密密钥进行加密。</li>
</ul>
<h3 id="HTTP1-0，HTTP1-1以及HTTP2-0协议的区别"><a href="#HTTP1-0，HTTP1-1以及HTTP2-0协议的区别" class="headerlink" title="HTTP1.0，HTTP1.1以及HTTP2.0协议的区别"></a>HTTP1.0，HTTP1.1以及HTTP2.0协议的区别</h3><h4 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h4><p>HTTP1.0是一种无状态，无连接的协议。浏览器的每次请求都需要建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求。也就是默认用Connection：close</p>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>HTTP/1.1中默认使用Connection：keep-alive，避免了连接建立和释放的开销。但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。</p>
<h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><p>HTTP2.0协议新增了二进制分帧，多路复用，头部压缩和服务器推送等功能，进一步提高了传输效率。</p>
<h3 id="路由汇聚"><a href="#路由汇聚" class="headerlink" title="路由汇聚"></a>路由汇聚</h3><p>路由汇聚是指把一组路由汇聚为一个单个的路由广播。路由汇聚优点是可以缩小网络上的路由表尺寸。</p>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-消息队列-kafka介绍</title>
    <url>/2020/02/08/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="消息队列-Kafka介绍"><a href="#消息队列-Kafka介绍" class="headerlink" title="消息队列 - Kafka介绍"></a>消息队列 - Kafka介绍</h2><h3 id="消息队列kafka有了解吗"><a href="#消息队列kafka有了解吗" class="headerlink" title="消息队列kafka有了解吗"></a>消息队列kafka有了解吗</h3><a id="more"></a>

<p>Kafka是一个消息队列，可以实现发布订阅模式。在异步通信或者生产者和消费者需要解耦合的场景中经常使用，可以对数据流进行处理等。</p>
<p><strong>Kafka的特性如下所示</strong>：</p>
<ul>
<li>kafka支持消息的快速持久化</li>
<li>支持批量读写消息</li>
<li>支持消息分区，并且支持在线增加分区，提高了并发能力</li>
<li>支持为每个分区创建多个副本</li>
</ul>
<h4 id="Kafka使用磁盘存储，为什么具有高性能的特点"><a href="#Kafka使用磁盘存储，为什么具有高性能的特点" class="headerlink" title="Kafka使用磁盘存储，为什么具有高性能的特点"></a>Kafka使用磁盘存储，为什么具有高性能的特点</h4><ul>
<li><strong>顺序读写磁盘</strong>：消息在磁盘中的方式是顺序读写的，磁盘的顺序读写速度超过内存随机读写。</li>
<li><strong>页缓存</strong>：页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘I/O的操作。具体就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。当然，也会存在磁盘脏页，以及合适时机会进行刷盘操作。</li>
<li><strong>零拷贝</strong>：使用零拷贝技术来进一步提升kafka性能。零拷贝是指将数据直接从磁盘文件复制到网卡设备，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换</li>
</ul>
<h3 id="Kafka中的核心概念"><a href="#Kafka中的核心概念" class="headerlink" title="Kafka中的核心概念"></a>Kafka中的核心概念</h3><ul>
<li><strong>生产者（Producer）</strong>：生产消息，并且按照一定的规则（分区分配规则）推送到Topic的分区中。</li>
<li><strong>消费者（Consumer）</strong>：从Topic中拉取消息并且进行消费，消费者自行维护消费消息的位置（offset）</li>
<li><strong>分区（partition）</strong>：每个Topic可以划分为多个分区，每个消息在分区中都会有一个唯一编号offset，kafka通过offset保证消息在分区中的顺序，同一Topic的不同分区可以分配在不同的Broker上，partition以文件的形式存储在文件系统中</li>
<li><strong>副本（replica）</strong>：Kafka对消息进行了冗余备份，每个分区有多个副本，每个副本中包含的消息是“一样”的。每个副本中都会选举出一个Leader副本，其余为Follower副本，Follower副本仅仅是将数据从Leader副本拉到本地，然后同步到自己的Log中。</li>
<li><strong>消费者组（Consumer Group）</strong>：每个consumer都属于一个consumer group，每条消息只能被consumer group中的一个Consumer消费，但可以被多个consumer group消费。</li>
<li><strong>Broker</strong>：一个单独的server就是一个Broker，主要用来接收生产者发过来的消息，分配offset，并且保存到磁盘中。</li>
<li><strong>Cluster &amp; Controller</strong>：多个Broker可以组成一个Cluster集群，每个集群选举一个Broker来作为Controller，充当指挥中心。Controller负责管理分区的状态，管理每个分区的副本状态，监听ZooKeeper中数据的变化等工作</li>
<li><strong>日志压缩与保留策略</strong>：不管消费者是否已经消费了消息，Kafka都会保存这些消息（持久化到磁盘），通过配置相应的保留策略，定时删除陈旧的消息。所谓日志压缩，就是定时进行相同key值合并，只保留最新的key - value值。</li>
</ul>
<h3 id="简单介绍下Kafka中的副本机制"><a href="#简单介绍下Kafka中的副本机制" class="headerlink" title="简单介绍下Kafka中的副本机制"></a>简单介绍下Kafka中的副本机制</h3><p><strong>同步复制</strong>：当所有的Follower副本都将消息复制完成，这条消息才会被认为是提交完成，一旦有一个Follower副本出现故障，就会导致消息无法提交，极大的影响到了系统的性能。</p>
<p><strong>异步复制</strong>：当Leader副本接收到生产者发送的消息后就认为当前消息提交成功。Follower副本异步地从Leader副本同步消息，但是不可以保证同步速度，当Leader副本突然宕机的时候，可能Follower副本中的消息落后太多，导致消息的丢失。</p>
<p><strong>Kakfa引入了ISR集合</strong></p>
<h4 id="ISR（In-Sync-Replica-集合："><a href="#ISR（In-Sync-Replica-集合：" class="headerlink" title="ISR（In-Sync-Replica)集合："></a>ISR（In-Sync-Replica)集合：</h4><p>可用副本集合，ISR集合表示当前“可用”且消息量与Leader相差不多的副本集合，需要满足如下条件：</p>
<ul>
<li>副本所在节点必须维持着与ZooKeeper的连接。</li>
<li>副本最后一条消息的offset与Leader副本的最后一条消息的offset之间的差值不能超过指定的阈值</li>
</ul>
<h4 id="HW和LEO标志"><a href="#HW和LEO标志" class="headerlink" title="HW和LEO标志"></a>HW和LEO标志</h4><ul>
<li>HW（HighWatermark）表示高水位，标记了一个特殊的offset，当消费者处理消息的时候，只能拉取到HW之前的消息。HW也是由Leader副本管理的。</li>
<li>LEO（Log End Offset）是所有副本都会有的一个offset标记。</li>
</ul>
<h4 id="ISR、HW和LEO的工作配合机制"><a href="#ISR、HW和LEO的工作配合机制" class="headerlink" title="ISR、HW和LEO的工作配合机制"></a>ISR、HW和LEO的工作配合机制</h4><ul>
<li>producer向此分区中推送消息</li>
<li>Leader副本将消息追加到Log中，并且递增其LEO</li>
<li>Follower副本从Leader副本中拉取消息进行同步</li>
<li>Follower副本将消息更新到本地Log中，并且递增其LEO</li>
<li>当ISR集合中所有的副本都完成了对offset的消息同步，Leader副本会递增其HW</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>同步复制会导致高延迟，异步复制可能会造成消息的丢失</li>
<li>Kafka引入的ISR集合解决了同步复制和异步复制的缺点</li>
<li>当Follower副本延迟过高时，将会被踢出ISR集合，避免了高延迟的Follower副本影响整个Kafka集群性能</li>
<li>当Leader副本所在的Broker宕机，会优先将ISR集合中的Follower副本选举为Leader</li>
</ul>
<h3 id="Kafka的文件存储机制"><a href="#Kafka的文件存储机制" class="headerlink" title="Kafka的文件存储机制"></a>Kafka的文件存储机制</h3><p>Kafka中消息是以topic进行分类的，生产者通过topic向kafka broker发送消息，消费者通过topic读取数据。topic在物理层面又能以partition为分组，一个topic可以分成若干个partition，partition还可以细分为segment，一个partition物理上由多个segment组成。</p>
<h3 id="Topic和Partition"><a href="#Topic和Partition" class="headerlink" title="Topic和Partition"></a>Topic和Partition</h3><p>Kafka中的一个topic可以认为是一类消息，每个topic将被分成多个partition，每个partition在存储层面是append log文件。发布到此partition的消息都会被追加到log文件的尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型的数字，它唯一标记一条消息。</p>
<p><strong>分区的水平扩展</strong>：每一条消息被发送到broker中，会根据partition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息均可以发布到不同的partition里。</p>
<p><strong>为什么Kafka中的分区只支持增长，不支持减小分区个数的操作？</strong></p>
<ul>
<li>删除掉的分区的消息不好处理，若丢弃则可靠性得不到保证</li>
<li>如果插入现有分区的尾部，则一些带时间戳的消息会对消费者有影响</li>
<li>如果消息量大的话，复制到其它分区也会很耗费资源；</li>
</ul>
<h3 id="Kafka消息传输的三大语义"><a href="#Kafka消息传输的三大语义" class="headerlink" title="Kafka消息传输的三大语义"></a>Kafka消息传输的三大语义</h3><ul>
<li>At most once：最多一次，消息可能丢失，但绝不会重复传输</li>
<li>At least once：最少一次，消息绝不会丢失，但可能会重复传输</li>
<li>Exactly once：恰好一次，每条消息肯定会被传输一次且仅传输一次</li>
</ul>
<h3 id="Kafka中关于可靠性的配置"><a href="#Kafka中关于可靠性的配置" class="headerlink" title="Kafka中关于可靠性的配置"></a>Kafka中关于可靠性的配置</h3><p><strong>request.required.acks</strong>：</p>
<ul>
<li><strong>1（默认）</strong>：这意味着producer在ISR中的leader已成功收到数据并得到确认。如果leader宕机了，则会丢失数据。</li>
<li><strong>0：</strong>这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li>
<li><strong>-1：</strong>producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时（ISR中的成员由于某些情况会增加也会减少，最少就只剩一个leader），这样就变成了acks=1的情况。</li>
</ul>
<p><strong>min.insync.replicas(ISR集合中的最小副本个数)</strong>：</p>
<ul>
<li>min.insync.replicas这个参数设定ISR中的最小副本数是多少，默认值为1，当且仅当request.required.acks参数设置为-1时，此参数才生效。</li>
<li>如果ISR中的副本数少于min.insync.replicas配置的数量时，客户端会返回异常：org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-缓存技术-Redis解析</title>
    <url>/2020/02/07/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF-Redis%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="缓存技术-Redis解析"><a href="#缓存技术-Redis解析" class="headerlink" title="缓存技术 - Redis解析"></a>缓存技术 - Redis解析</h2><h3 id="Redis有了解吗"><a href="#Redis有了解吗" class="headerlink" title="Redis有了解吗"></a>Redis有了解吗</h3><a id="more"></a>

<p><strong>redis（Remote Dictionary Server远程字典服务）</strong>，是一款高性能的(key/value)分布式<strong>内存数据库</strong>，基于<strong>内存运行</strong>并支持<strong>持久化</strong>的NoSQL数据库。因为数据都在内存中，所以运行速度快。redis支持丰富的数据类型并且支持事务，事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断。</p>
<h4 id="redis相比memcached有哪些优势？"><a href="#redis相比memcached有哪些优势？" class="headerlink" title="redis相比memcached有哪些优势？"></a>redis相比memcached有哪些优势？</h4><ul>
<li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。</li>
<li>redis的速度比memcached快很多，并且redis支持数据的持久化。</li>
<li>redis支持数据的备份，即master-slave模式的数据备份。</li>
<li>使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。redis自己构建了VM 管理机制。</li>
<li>value大小不同，redis最大可以达到512MB，而memcache只有1MB。</li>
</ul>
<h4 id="redis支持哪些数据类型"><a href="#redis支持哪些数据类型" class="headerlink" title="redis支持哪些数据类型"></a>redis支持哪些数据类型</h4><ul>
<li><strong>string：</strong>redis 中字符串 value 最大可为512M。可以用来做一些计数功能的缓存（也是实际工作中最常见的）。</li>
<li><strong>list：</strong>简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边），其底层实现是一个链表。可以实现一个简单消息队列功能，做基于redis的分页功能等。</li>
<li><strong>set：</strong>是一个字符串类型的无序集合。可以用来进行全局去重等。</li>
<li><strong>sorted set：</strong>是一个字符串类型的有序集合，给每一个元素一个固定的<strong>分数score</strong>来保持顺序。可以用来做排行榜应用或者进行范围查找等。</li>
<li><strong>hash：</strong>键值对集合，是一个字符串类型的 Key和 Value 的映射表，也就是说其存储的Value是一个键值对（Key- Value）。可以用来存放一些具有特定结构的信息。</li>
</ul>
<h3 id="redis是单线程的吗？为什么执行速度这么快？"><a href="#redis是单线程的吗？为什么执行速度这么快？" class="headerlink" title="redis是单线程的吗？为什么执行速度这么快？"></a>redis是单线程的吗？为什么执行速度这么快？</h3><p>redis是单线程的，redis的单线程是指网络请求模块使用了一个线程，所以不需考虑并发安全性。但是对于需要依赖多个操作的复合操作来说，还是需要锁的，而且有可能是分布式锁。</p>
<p><strong>那么单线程的redis为什么执行速度如此之快？</strong></p>
<ul>
<li>基于内存实现，完全内存计算</li>
<li>单线程操作，避免了线程上下文切换操作</li>
<li><strong>多路I/O复用的线程模型</strong>，实现了一个线程监控多个IO流，及时响应请求</li>
<li>redis对外部的依赖比较少，属于轻量级内存数据库</li>
</ul>
<p>I/O多路复用就是通过一种机制<strong>一个进程可以监视多个描述符</strong>，一旦某个描述符读就绪或者写就绪，其能够通知应用程序进行相应的读写操作。</p>
<h3 id="使用redis可能出现的问题"><a href="#使用redis可能出现的问题" class="headerlink" title="使用redis可能出现的问题"></a>使用redis可能出现的问题</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>举例：</strong>缓存同一时间大面积的失效，这个时候又来的一波请求都到数据库上，导致数据库连接异常。</p>
<p><strong>解决办法：</strong>可以给缓存设置不同的缓存时间，更新数据使用互斥锁或者通过双缓存在避免缓存雪崩。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>举例：</strong>故意的去请求缓存中不存在的数据，导致请求都打到了数据库上，导致数据库异常。</p>
<p><strong>解决办法：</strong>可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制来拦截不合法的key值等。</p>
<h4 id="数据库和缓存的双写一致问题"><a href="#数据库和缓存的双写一致问题" class="headerlink" title="数据库和缓存的双写一致问题"></a>数据库和缓存的双写一致问题</h4><p>在高并发请求下很容易导致数据不一致的问题，如果你的业务需要保证数据的强一致性，那么建议不要使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>双删延时的解决方法：可以先删除缓存数据，然后再更新数据库数据，最后再隔固定的时间再次删除缓存。</li>
<li>更新数据库产生的binlog订阅（使用canal）。将有变化的key记录下来，并且尝试去不断的去删除缓存（如果上次删除缓存失败）</li>
</ul>
<h3 id="redis的持久化方式有哪些"><a href="#redis的持久化方式有哪些" class="headerlink" title="redis的持久化方式有哪些"></a>redis的持久化方式有哪些</h3><h4 id="RDB（快照方式）（全量持久化）："><a href="#RDB（快照方式）（全量持久化）：" class="headerlink" title="RDB（快照方式）（全量持久化）："></a>RDB（快照方式）（全量持久化）：</h4><p>将当前内存中的数据集快照写入磁盘，实现数据的持久化，恢复时可以将快照重新载入内存的。</p>
<p><strong>触发方式</strong>：</p>
<ul>
<li>自动触发：在配置文件中，可以配置执行了多少次save就自动触发自动持久化。</li>
<li>手动触发：通过bgsave命令，在后台异步进行生成快照的操作，同时还可以响应客户端的请求。通过redis进程fork操作创建子进程，生成的快照由子进程负责，客户端请求只会在fork阶段被阻塞。</li>
</ul>
<p><strong>快照恢复</strong>：将备份文件(dump.rdb)移动到redis安装目录并启动服务，redis会自动加载快照文件数据到内存。但是，redis服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p>
<h4 id="AOF（增量持久化）："><a href="#AOF（增量持久化）：" class="headerlink" title="AOF（增量持久化）："></a>AOF（增量持久化）：</h4><p>通过记录redis服务器所执行的写命令来记录数据库状态。恢复时可以将AOF文件载入内存，并且可以通过redis-check-aof –fix进行修复AOF文件。</p>
<p><strong>AOF日志重写</strong>：</p>
<ul>
<li>AOF文件会随着服务器运行的时间越来越大，可以通过AOF重写来控制AOF文件的大小。</li>
<li>AOF重写会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来替代前面对键值对操作的多条命令</li>
<li>使用命令bgrewriteaof来实现AOF重写</li>
</ul>
<p><strong>AOF重写缓冲区</strong>:</p>
<p>redis 是单线程工作，当AOF文件较大时重写时间会比较长，在重写 AOF 期间，redis将长时间无法处理客户端请求。为了解决这个问题，可以将 AOF 重写程序放到子进程中执行，好处如下：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理其他客户端请求。</li>
<li>子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ul>
<p>子进程AOF重写会导致AOF文件和数据库中数据不一致的问题</p>
<p><strong>解决</strong>：</p>
<ul>
<li>redis服务器设置了一个AOF重写缓冲区。这个缓冲区在创建子进程后开始使用，当redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到AOF重写缓冲区。</li>
<li>当子进程完成AOF日志重写之后，给父进程发送信号，父进程接收此信号后，将AOF重写缓冲区的内容写到新的AOF文件中，保持数据的一致性。</li>
</ul>
<h4 id="持久化策略选择"><a href="#持久化策略选择" class="headerlink" title="持久化策略选择"></a>持久化策略选择</h4><ul>
<li>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。</li>
<li>RDB持久化，安全性较差，它是正常时期数据备份以及master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。</li>
</ul>
<h3 id="redis数据的过期回收策略与内存淘汰机制"><a href="#redis数据的过期回收策略与内存淘汰机制" class="headerlink" title="redis数据的过期回收策略与内存淘汰机制"></a>redis数据的过期回收策略与内存淘汰机制</h3><ul>
<li>定期删除：redis会每隔一定的时间去抽查一定量的数据判断是否过期，过期则进行删除</li>
<li>惰性删除：在获取一个key的时候，redis会检查这个key是否已经过期，若过期则会进行删除。</li>
</ul>
<h4 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h4><p>在配置文件中，我们可以对内存淘汰机制进行配置。当内存使用达到最大值时，redis可以使用的<strong>清除策略</strong>如下：</p>
<ul>
<li><strong>volatile-lru</strong>：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )</li>
<li><strong>allkeys-lru</strong>：利用LRU算法移除任何key</li>
<li><strong>volatile-random</strong>：移除设置过过期时间的随机key</li>
<li><strong>allkeys-random</strong>：移除随机key</li>
<li><strong>volatile-ttl</strong>：移除即将过期的key(minor TTL)</li>
<li><strong>noeviction</strong> ：不移除任何key，只是返回一个写错误 ，默认选项</li>
</ul>
<h3 id="redis的主从复制机制"><a href="#redis的主从复制机制" class="headerlink" title="redis的主从复制机制"></a>redis的主从复制机制</h3><p>当项目比较大时，我们可以采用主从架构Master/Slave机制，Master以写为主，Slave以读为主，Master主节点更新后根据配置，自动同步到从机Slave节点。</p>
<p>主从复制的原理包括旧版同步和命令传播，主从复制的代价就是系统复制较重的时候会导致主从延迟，并且根据CAP理论，无法同时保证服务可用性和数据一致性。</p>
<p><strong>CAP理论</strong>是指当网络分区发生时，一致性和可用性不能同时保证。</p>
<h3 id="redis对事务的支持"><a href="#redis对事务的支持" class="headerlink" title="redis对事务的支持"></a>redis对事务的支持</h3><p>redis是单进程的程序，保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。redis会将一个事务中的所有命令序列化，然后按顺序执行。redis不可能在一个事务的执行过程中插入执行另外一个客户端发出的请求。可以保证Redis将这些命令作为一个单独的隔离操作执行。</p>
<p>redis不支持回滚操作。</p>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>缓存技术</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java框架-MyBatis必会知识点</title>
    <url>/2020/02/07/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E6%A1%86%E6%9E%B6-MyBatis%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Java框架-MyBatis必会知识点"><a href="#Java框架-MyBatis必会知识点" class="headerlink" title="Java框架 - MyBatis必会知识点"></a>Java框架 - MyBatis必会知识点</h2><h3 id="MyBatis是什么"><a href="#MyBatis是什么" class="headerlink" title="MyBatis是什么"></a>MyBatis是什么</h3><a id="more"></a>

<p>MyBatis是一个半ORM（对象关系映射）框架，内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花精力去处理加载驱动、创建连接、创建statement等繁杂的过程。通过直接编写原生态SQL，可以严格控制SQL语句的执行性能，灵活度高（支持动态SQL语句）。</p>
<p>MyBatis使用XML或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了JDBC代码手动设置参数以及获取结果集的繁琐步骤。</p>
<p>MyBatis通过xml文件或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由MyBatis框架执行SQL语句，并将结果映射为Java对象并返回。</p>
<h3 id="MyBatis的核心组件"><a href="#MyBatis的核心组件" class="headerlink" title="MyBatis的核心组件"></a>MyBatis的核心组件</h3><ul>
<li><strong>SqlSessionFactoryBuilder</strong>是一个构建器，通过XML配置文件或者Java编码获得资源来构建SqlSessionFactory，通过Builder可以构建多个SessionFactory。其生命周期一般只存在于方法的局部，用完即可回收。</li>
<li><strong>SqlSessionFactory</strong>的作用就是创建SqlSession，也就是创建一个会话。每次程序需要访问数据库，就需要使用到SqlSession。所以SqlSessionFactory应该在MyBatis应用的整个生命周期中。为了减少每次都创建一个会话带来的资源消耗，一般情况下都会使用单例模式来创建SqlSession。</li>
<li><strong>SqlSession</strong>就是一个会话，相当于JDBC中的Connetion对象，既可以发送SQL去执行并返回结果，也可以获取Mapper接口。SqlSession是一个线程不安全的对象，其生命周期应该是请求数据库处理事务的过程中。每次创建的SqlSession对象必须及时关闭，否则会使得数据库连接池的活动资源减少，影响系统性能。</li>
<li><strong>Mapper</strong>也叫映射器，由Java接口和XML文件（或者是注解）共同组成，给出了对应的SQL和映射规则，主要负责发送SQL去执行，并且返回结果。</li>
</ul>
<h3 id="MyBatis的动态SQL"><a href="#MyBatis的动态SQL" class="headerlink" title="MyBatis的动态SQL"></a>MyBatis的动态SQL</h3><p>MyBatis动态SQL可以在映射XML映射文件内，以标签的形式编写动态SQL。动态SQL的执行原理是根据表达式的值完成逻辑判断并动态拼接SQL语句。</p>
<ul>
<li>if</li>
<li>choose，when，otherwise</li>
<li>foreach</li>
<li>trim，where，set</li>
<li>bind</li>
</ul>
<h3 id="MyBatis的Dao接口的工作原理"><a href="#MyBatis的Dao接口的工作原理" class="headerlink" title="MyBatis的Dao接口的工作原理"></a>MyBatis的Dao接口的工作原理</h3><p>Dao接口即Mapper接口。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口权限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。在MyBatis中，每一个标签&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;都会被解析为一个MapperStatement对象。</p>
<p>Mapper接口的工作原理是JDK动态代理，MyBatis运行时会使用JDK动态代理为Mapper接口生成代理对象Proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的SQL，然后将SQL执行结果返回。</p>
<p><strong>Mapper接口里的方法是不能重载的，因为是使用全限名+方法名的保存和寻找策略</strong></p>
<h3 id="MyBatis中-和-的区别是什么"><a href="#MyBatis中-和-的区别是什么" class="headerlink" title="MyBatis中 # 和 $ 的区别是什么"></a>MyBatis中 # 和 $ 的区别是什么</h3><p>MyBatis中我们能用#就尽量不要用$符号</p>
<ul>
<li>#符号将传入的数据当作一个字符串，会对自动传入的数据加一个双引号</li>
<li>$符号将传入的数据直接显示在生成的SQL语句中</li>
<li>#符号存在预编译的过程，对问号赋值，防止SQL注入</li>
<li>$符号是直译的方式，一般在order by ${列名}语句中</li>
</ul>
<h3 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a>MyBatis的缓存机制</h3><ul>
<li><strong>一级缓存（同一个SqlSession）</strong>，基于HashMap的本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有缓存就将清空，默认打开以及缓存。</li>
<li><strong>二级缓存（同一个SqlSessionFactory）</strong>，二级缓存与一级缓存机制相同，都是采用HashMap的本地缓存，但是其存储作用域为Mapper(Namespace)，并且可自定义存储源。</li>
</ul>
<h3 id="MyBatis的接口绑定"><a href="#MyBatis的接口绑定" class="headerlink" title="MyBatis的接口绑定"></a>MyBatis的接口绑定</h3><ul>
<li>通过注解绑定</li>
<li>通过xml里面写SQL来绑定，要指定xml映射文件里面的namespace必须为接口的全路径名</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Java框架</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java框架-Spring必会知识点</title>
    <url>/2020/02/07/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E6%A1%86%E6%9E%B6-Spring%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Java框架-Spring必会知识点"><a href="#Java框架-Spring必会知识点" class="headerlink" title="Java框架 - Spring必会知识点"></a>Java框架 - Spring必会知识点</h2><h3 id="说一下Spring中的控制反转（IOC）"><a href="#说一下Spring中的控制反转（IOC）" class="headerlink" title="说一下Spring中的控制反转（IOC）"></a>说一下Spring中的控制反转（IOC）</h3><a id="more"></a>

<p>IOC也叫控制反转，将对象间的依赖关系交给Spring容器，使用配置文件来创建所依赖的对象，由主动创建对象改为了被动方式，实现解耦合。可以通过注解@Autowired和@Resource来注入对象，被注入的对象，被注入的对象必须被下边的四个注解之一标注：</p>
<ul>
<li><strong>@Controller</strong></li>
<li><strong>@Service</strong></li>
<li><strong>@Repository</strong></li>
<li><strong>@Component</strong></li>
</ul>
<p><strong>DI依赖注入</strong>：应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源。把底层类作为<strong>参数</strong>传递给上层类，实现上层对下层的“控制”，而不是在上层类中new一个底层类。</p>
<h4 id="Spring的优点有哪些？"><a href="#Spring的优点有哪些？" class="headerlink" title="Spring的优点有哪些？"></a>Spring的优点有哪些？</h4><ul>
<li>Spring的依赖注入将对象间的依赖关系交给了框架来处理，减小了各个组件之间的耦合性</li>
<li>AOP面向切面编程，可以将通用的任务抽取出来，复用性更高</li>
<li>Spring对于其余主流框架都提供了很好的支持，代码的侵入性很低</li>
</ul>
<h3 id="Spring中的AOP面向切面编程"><a href="#Spring中的AOP面向切面编程" class="headerlink" title="Spring中的AOP面向切面编程"></a>Spring中的AOP面向切面编程</h3><p>AOP，面向切面编程是指当需要在某一个方法之前或者之后做一些额外的操作，比如说日志记录，权限判断，异常统计等，可以利用AOP将功能代码从业务逻辑中分离出来。</p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul>
<li>Joinpoint（连接点）：类里面可以被增强的方法，这些方法称为连接点</li>
<li>Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li>
<li>Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</li>
<li>Aspect（切面）：是切入点和通知的结合</li>
<li>Introduction（引介）：引介是一种特殊的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或属性</li>
<li>Target（目标对象）：代理的目标对象（要增强的类）</li>
<li>Weaving（织入）：是把增强(advice)应用到目标(target)的过程</li>
<li>Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类</li>
</ul>
<h4 id="Spring中AOP的实现方式"><a href="#Spring中AOP的实现方式" class="headerlink" title="Spring中AOP的实现方式"></a>Spring中AOP的实现方式</h4><ul>
<li>使用JDK动态代理实现，只能对实现了接口的类进行代理，该目标类型的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。</li>
<li>使用cglib来实现，对是否实现接口无要求。原理是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法不能声明为final类型。</li>
</ul>
<p>Spring AOP对这两种代理的选择：实现了接口则默认采用JDK的动态代理，否则使用cglib库。</p>
<h3 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h3><p>IOC容器的初始化主要包括<strong>Resource定位，载入和注册</strong>三个步骤。</p>
<ul>
<li>Resource资源定位：BeanDefinition的资源定位，也就是IOC容器找数据的过程。</li>
<li>BeanDefinition的载入：载入过程就是把定义好的Bean表示成IOC容器内部的数据结构，即BeanDefinition，具体是通过BeanDefinitionReader读取，解析Resource定位的资源。在配置文件中每一个Bean都对应这一个BeanDefinition，在IOC容器内部维护着一个BeanDefinitionMap。</li>
<li>BeanDefinition的注册：就是将前面的BeanDefinition保存到Map的过程，通过BeanDefinitionRegistry接口来实现注册。</li>
</ul>
<p>不开启延迟加载就会在IOC容器启动的时候创建Bean，开启则会在第一次索取Bean的时候通过getBean()方法完成创建。</p>
<h4 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h4><p>BeanFactory是Spring里面最顶层的接口，包含了各种Bean的定义，读取Bean配置文档，管理Bean的加载、实例化，控制Bean的生命周期，维护Bean之间的依赖关系。</p>
<p>而ApplicationContext接口是BeanFactory的派生，还提供了更完整的框架功能。</p>
<p><strong>ApplicationContext三种常见的实现</strong>:</p>
<ul>
<li>FileSystemXmlApplicationContext</li>
<li>ClassPathXmlApplicationContext</li>
<li>WebXmlApplicationContext</li>
</ul>
<p><strong>在创建Bean和内存占用方面的区别</strong>：</p>
<ul>
<li>BeanFactory采用的是延迟加载形式来注入Bean的</li>
<li>ApplicationContext是在容器启动时，一次性创建了所有的Bean</li>
</ul>
<p><strong>优缺点分析</strong>：</p>
<p><strong>BeanFactory</strong>：</p>
<ul>
<li>优点：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势</li>
<li>缺点：运行速度相对来说慢一点。而且有可能出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。</li>
</ul>
<p><strong>ApplicationContext</strong>：</p>
<ul>
<li>优点：所有的Bean在启动的时候都进行了加载，系统运行的速度快；在系统启动的时候，可以发现系统中的配置问题</li>
<li>缺点：程序启动较慢，内存占用较大</li>
</ul>
<h3 id="Spring中Bean的作用域有哪几种？"><a href="#Spring中Bean的作用域有哪几种？" class="headerlink" title="Spring中Bean的作用域有哪几种？"></a>Spring中Bean的作用域有哪几种？</h3><ul>
<li>singleton：Bean在每个Spring IOC 容器中只有一个实例，默认作用域</li>
<li>prototype：一个Bean的定义可以有多个实例</li>
<li>request：每次http请求都会创建一个Bean</li>
<li>session：在一个HTTP Session中，一个Bean定义对应一个实例</li>
<li>global-session：在一个全局的HTTP Session中，一个Bean对应一个实例</li>
</ul>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>如果A对象创建的过程需要用到B对象，而B对象创建的时候需要用到A对象，这是一种构造器循环依赖，通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。</p>
<h3 id="Spring的事务有了解吗"><a href="#Spring的事务有了解吗" class="headerlink" title="Spring的事务有了解吗"></a>Spring的事务有了解吗</h3><ul>
<li>编程式事务管理：使用TransationTemplate实现</li>
<li>声明式事务管理：建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行的情况提交或者回滚事务。</li>
</ul>
<h4 id="事务选择"><a href="#事务选择" class="headerlink" title="事务选择"></a>事务选择</h4><p>声明式事务管理要优于编程式事务，这正是Spring所倡导的非侵入式开发方式，使业务代码不受污染。唯一不足之处是声明式事务的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p>
<h3 id="Spring-MVC的消息处理流程"><a href="#Spring-MVC的消息处理流程" class="headerlink" title="Spring MVC的消息处理流程"></a>Spring MVC的消息处理流程</h3><p>通过前端控制器DispatcherServlet来接收并且分发请求，然后通过HandlerMapping和HandlerAdapter找到具体可以处理该请求的Handler，经过逻辑处理，返回一个ModelAndView，经过ViewResolver处理，最后生成了一个View视图返回给了客户端。</p>
<p><img src="/images/SpringMVC%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="SpringMVC处理过程"></p>
<h3 id="简单说下Spring-Boot吧"><a href="#简单说下Spring-Boot吧" class="headerlink" title="简单说下Spring Boot吧"></a>简单说下Spring Boot吧</h3><p>Spring Boot是Spring开源组织下的子项目，是Spring组件一站式解决方案，主要简化了使用Spring的难度，简省了繁重的配置，提供了各种启动器starter，开发者能够快速上手。</p>
<p>SpringBoot的优点包括可以独立运行，简化了配置，可以实现自动配置，无代码生成以及XML配置，并且可以进行应用监控。</p>
<h4 id="SpringBoot的核心注解："><a href="#SpringBoot的核心注解：" class="headerlink" title="SpringBoot的核心注解："></a>SpringBoot的核心注解：</h4><ul>
<li>@SpringBootConfiguration：组合了@Configuration注解，实现了配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动装配功能，也可以关闭某个自动配置的选项。</li>
<li>@ComponentScan：Spring组件扫描</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java框架</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义RPC</title>
    <url>/2020/02/06/%E8%87%AA%E5%AE%9A%E4%B9%89RPC/</url>
    <content><![CDATA[<h2 id="自定义RPC"><a href="#自定义RPC" class="headerlink" title="自定义RPC"></a>自定义RPC</h2><h3 id="RPC结构"><a href="#RPC结构" class="headerlink" title="RPC结构"></a>RPC结构</h3><a id="more"></a>


<p><img src="/images/RPC%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="RPC结构图"></p>
<h3 id="设计和实现"><a href="#设计和实现" class="headerlink" title="设计和实现"></a>设计和实现</h3><h4 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h4><p><img src="/images/PRC%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="PRC结构设计"></p>
<ul>
<li>Client（服务的调用方）：两个接口 + 一个包含main方法的测试类</li>
<li>Client Stub：一个客户端代理类 + 一个客户端业务处理类</li>
<li>Server（服务的提供方）：两个接口 + 两个实现类</li>
<li>Server Stub：一个网络处理服务器 + 一个服务器业务处理类</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="client"><a href="#client" class="headerlink" title="client"></a>client</h5><p><strong>HelloNetty</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloNetty</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloRPC</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRPC</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TestNettyRPC</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyRPC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次远程调用</span></span><br><span class="line">        HelloNetty helloNetty = (HelloNetty) NettyRPCProxy.create(HelloNetty<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(helloNetty.hello());</span><br><span class="line">        <span class="comment">// 第2次调用</span></span><br><span class="line">        HelloRPC helloRPC = (HelloRPC) NettyRPCProxy.create(HelloRPC<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(helloRPC.hello(<span class="string">"RPC"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ClientStub"><a href="#ClientStub" class="headerlink" title="ClientStub"></a>ClientStub</h5><p><strong>NettyRPCProxy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRPCProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据接口创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">create</span><span class="params">(Class target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClassLoader(), <span class="keyword">new</span> Class[]&#123;target&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 封装ClassInfo</span></span><br><span class="line">                ClassInfo classInfo = <span class="keyword">new</span> ClassInfo();</span><br><span class="line">                classInfo.setClassName(target.getName());</span><br><span class="line">                classInfo.setMethodName(method.getName());</span><br><span class="line">                classInfo.setObjects(args);</span><br><span class="line">                classInfo.setTypes(method.getParameterTypes());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始用Netty发送数据</span></span><br><span class="line">                EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">                ResultHandler resultHandler = <span class="keyword">new</span> ResultHandler();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                    b.group(group)</span><br><span class="line">                            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                    <span class="comment">// 编码器</span></span><br><span class="line">                                    pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                                    <span class="comment">// 解码器</span></span><br><span class="line">                                    pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE,</span><br><span class="line">                                            ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line">                                    <span class="comment">// 客户端业务处理类</span></span><br><span class="line">                                    pipeline.addLast(<span class="string">"handler"</span>, resultHandler);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    ChannelFuture future = b.connect(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>).sync();</span><br><span class="line">                    future.channel().writeAndFlush(classInfo).sync();</span><br><span class="line">                    future.channel().closeFuture().sync();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    group.shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resultHandler.getResponse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ResultHandler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getResponse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取服务器端返回的数据（远程调用的结果）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        response = msg;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p><strong>HelloNetty</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloNetty</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloNettyImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNettyImpl</span> <span class="keyword">implements</span> <span class="title">HelloNetty</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello netty"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloRPC</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloRPC</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloRPCImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRPCImpl</span> <span class="keyword">implements</span> <span class="title">HelloRPC</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ServerStub"><a href="#ServerStub" class="headerlink" title="ServerStub"></a>ServerStub</h5><p><strong>ClassInfo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;   <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;  <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] types;   <span class="comment">// 参数类型</span></span><br><span class="line">    <span class="keyword">private</span> Object[] objects;   <span class="comment">// 参数列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt;[] getTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> types;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypes</span><span class="params">(Class&lt;?&gt;[] types)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.types = types;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getObjects() &#123;</span><br><span class="line">        <span class="keyword">return</span> objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjects</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>InvokeHandler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到某接口下某个实现类的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getImplClassName</span><span class="params">(ClassInfo classInfo)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 服务方接口和实现类所在的包路径</span></span><br><span class="line">        String interfacePath = <span class="string">"com.itheima.hchat.RPC.Server"</span>;</span><br><span class="line">        <span class="keyword">int</span> lastDot = classInfo.getClassName().lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        String interfaceName = classInfo.getClassName().substring(lastDot);</span><br><span class="line">        <span class="comment">// 接口的全路径</span></span><br><span class="line">        Class superClass = Class.forName(interfacePath + interfaceName);</span><br><span class="line">        Reflections reflections = <span class="keyword">new</span> Reflections(interfacePath);</span><br><span class="line">        <span class="comment">// 得到某接口下的所有实现类</span></span><br><span class="line">        Set&lt;Class&gt; ImplClassSet = reflections.getSubTypesOf(superClass);</span><br><span class="line">        <span class="keyword">if</span>(ImplClassSet.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"未找到实现类"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ImplClassSet.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"找到多个实现类，未明确使用哪一个"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把集合转换成数组</span></span><br><span class="line">            Class[] classes = ImplClassSet.toArray(<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> classes[<span class="number">0</span>].getName();    <span class="comment">// 返回实现类的名字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取客户端发来的数据并通过反射调用实现类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassInfo classInfo = (ClassInfo) msg;</span><br><span class="line">        Object clazz = Class.forName(getImplClassName(classInfo)).newInstance();</span><br><span class="line">        Method method = clazz.getClass().getMethod(classInfo.getMethodName(),classInfo.getTypes());</span><br><span class="line">        <span class="comment">// 通过反射调用实现类的方法</span></span><br><span class="line">        Object result = method.invoke(clazz, classInfo.getObjects());</span><br><span class="line">        ctx.writeAndFlush(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyRPCServer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyRPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyRPCServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>,128)</span></span><br><span class="line"><span class="class">                    .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_KEEPALIVE</span>,<span class="title">true</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">localAddress</span>(<span class="title">port</span>).<span class="title">childHandler</span>(</span></span><br><span class="line"><span class="class">                        <span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                                <span class="comment">// 编码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">                                <span class="comment">// 解码器</span></span><br><span class="line">                                pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> ObjectDecoder(Integer.MAX_VALUE,</span><br><span class="line">                                        ClassResolvers.cacheDisabled(<span class="keyword">null</span>)));</span><br><span class="line">                                <span class="comment">// 服务端业务处理类</span></span><br><span class="line">                                pipeline.addLast(<span class="keyword">new</span> InvokeHandler());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">"...........Server is ready............"</span>);</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyRPCServer(<span class="number">9999</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java进阶-JVM内存机制</title>
    <url>/2020/02/06/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E8%BF%9B%E9%98%B6-JVM%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="JVM内存机制"><a href="#JVM内存机制" class="headerlink" title="JVM内存机制"></a>JVM内存机制</h2><h3 id="JVM中的内存是怎么划分的？"><a href="#JVM中的内存是怎么划分的？" class="headerlink" title="JVM中的内存是怎么划分的？"></a>JVM中的内存是怎么划分的？</h3><a id="more"></a>

<p>JVM中的内存区域主要划分为5个区域，即方法区，堆内存，程序计数器，虚拟机栈和本地方法栈</p>
<p><strong>方法区</strong>：方法区是一个线程之间共享的区域。常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息。</p>
<p><strong>堆内存</strong>：堆内存是垃圾回收的主要场所，也是线程之间共享的区域，主要用来存储创建的对象实例，通过-Xms和-Xmx可以控制大小</p>
<p><strong>虚拟机栈</strong>：栈内存只要存放局部变量、基本数据类型变量以及堆内存中某个对象的引用变量。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈操作。</p>
<p><strong>程序计数器</strong>：程序计数器是当前线程执行的字节码的<strong>位置指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<p><strong>本地方法栈</strong>：主要是为JVM提供使用native方法的服务。</p>
<h3 id="对象创建过程中的内存分配"><a href="#对象创建过程中的内存分配" class="headerlink" title="对象创建过程中的内存分配"></a>对象创建过程中的内存分配</h3><p>当虚拟机遇到一条new指令的时候，会去检查这个指令的参数是否能在常量池中定位到某个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。如果没有，那么会执行类加载过程。</p>
<p>通过执行类的加载，验证，准备，解析，初始化步骤，完成了类的加载，这个时候会为该对象进行内存分配，也就是把一块确定大小的内存从Java堆中划分出来，在<strong>分配的内存</strong>上完成对象的创建工作。</p>
<p>对象的内存分配有两种方式，即<strong>指针碰撞</strong>和<strong>空闲列表</strong>方式。</p>
<p><strong>指针碰撞</strong>：假设Java堆中的内存是绝对规整的，用过的内存在一边，未使用的内存在另一边，中间有一个指示指针，那么所有的内存分配就是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<p><strong>空闲列表</strong>：如果Java堆内存中不是规整的，已使用和未使用的内存相互交错，那么虚拟机就必须维护一个列表用来记录哪块内存是可用的，在分配的时候找到一块足够大的空间分配对象实例，并且需要更新列表上的记录。</p>
<h4 id="内存的分配如何保证线程安全"><a href="#内存的分配如何保证线程安全" class="headerlink" title="内存的分配如何保证线程安全"></a>内存的分配如何保证线程安全</h4><ul>
<li>对分配内存空间的动作进行同步处理，通过“CAS + 失败重试” 的方式保证更新指针操作的原子性。</li>
<li>把分配内存的动作按照线程划分在不同的空间之中，即给每一个线程都预先分配一小段的内存，称为<strong>本地线程分配缓存（TLAB）</strong>只有TLAB用完并分配新的TLAB时，才需要进行同步锁定。</li>
</ul>
<h3 id="对象被访问的时候是怎么被找到的"><a href="#对象被访问的时候是怎么被找到的" class="headerlink" title="对象被访问的时候是怎么被找到的"></a>对象被访问的时候是怎么被找到的</h3><h4 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h4><p>在JVM的堆内存中划分出一块内存来作为句柄池，引用变量中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。在内存垃圾收集之后，对象会移动，但是引用reference中存储的是稳定的句柄地址。但是句柄地址不直接，访问速度较慢。</p>
<h4 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h4><p>引用变量中存储的就是对象的直接地址，通过指针直接访问对象。直接指针的访问方式节省了一次指针定位的时间开销，速度较快。HotSpot使用了直接指针方式进行对象的访问。</p>
<h3 id="内存分配与垃圾回收"><a href="#内存分配与垃圾回收" class="headerlink" title="内存分配与垃圾回收"></a>内存分配与垃圾回收</h3><p>JVM的内存可以分为堆内存和非堆内存。堆内存分为年轻代和老年代。年轻代又可以进一步划分为一个Eden区和两个Survivor区。</p>
<h4 id="堆内存上对象的分配与回收"><a href="#堆内存上对象的分配与回收" class="headerlink" title="堆内存上对象的分配与回收"></a>堆内存上对象的分配与回收</h4><p>我们创建的对象会优先在Eden分配，如果是大对象则可以直接进入老年代。虚拟机提供一个-XX:PretenureSizeThreshold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。</p>
<p>另外，长期存活的对象将进入老年代，每一次MinorGC（年轻代GC），对象年龄就大一岁，默认15岁晋升到老年代，通过<strong>-XX:MaxTenuringThreshold设置晋升年龄。</strong></p>
<h4 id="垃圾回收什么时候开始"><a href="#垃圾回收什么时候开始" class="headerlink" title="垃圾回收什么时候开始"></a>垃圾回收什么时候开始</h4><p><strong>Minor GC（年轻代GC）:</strong>对象优先在Eden中分配，当Eden中没有足够的空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭的，所以Minor GC非常频繁，而且速度也很快。</p>
<p><strong>Full GC（老年代GC）:</strong>当老年代没有足够的空间即发生Full GC，发生Full GC一般都会有一次Minor GC</p>
<h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>如果survivor空间中相同年龄的所有对象大小总和大于survivor空间的一半，那么年龄大于等于该对象年龄的对象即可晋升到老年代，不必等到-XX:MaxTenuringThreshold.</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>发送Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p>
<h3 id="JVM如何判定一个对象是否应该被回收"><a href="#JVM如何判定一个对象是否应该被回收" class="headerlink" title="JVM如何判定一个对象是否应该被回收"></a>JVM如何判定一个对象是否应该被回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</p>
<h4 id="root根搜索法"><a href="#root根搜索法" class="headerlink" title="root根搜索法"></a>root根搜索法</h4><p>root搜索方法的基本思路就是通过一系列可以作为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。一下对象会被认为是root对象：</p>
<ul>
<li>栈内存中引用的对象</li>
<li>方法区中静态引用和常量引用指向的对象</li>
<li>被启动类（bootstrap加载器）加载的类和创建的对象</li>
<li>Native方法中JNI引用的对象</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul>
<li><strong>强引用</strong>：普通存在，P p = new P(); 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li><strong>软引用</strong>：通过SoftReference类来实现软引用，在内存不足的时候会将这些软引用回收掉。</li>
<li><strong>弱引用</strong>：通过WeakReference类来实现弱引用，每次垃圾回收的时候肯定会回收掉弱引用。</li>
<li><strong>虚引用</strong>：通过PhantomReference类实现。设置虚引用只是为了对象被回收时候收到一个系统通知。</li>
</ul>
<h3 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法把内存空间划分为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。缺点就是需要两倍的内存空间。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从跟节点开始表姐所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p>
<h3 id="JVM中的垃圾收集器"><a href="#JVM中的垃圾收集器" class="headerlink" title="JVM中的垃圾收集器"></a>JVM中的垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是一个单线程的垃圾收集器，并且在执行垃圾回收的时候需要Stop The World。虚拟机运行在Client模式下的默认新生代收集器。Serial收集器的优点是简单高效，对于限定在单个CPU环境来说，Serial收集器没有多线程交互的开销。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，也是一个单线程收集器。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是作为CMS垃圾收集器的后备预案，当CMS并发收集发送Concurrent Mode Failure时使用。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew是Serial收集器的多线程版本，新生代是并行的，老年代是串行的，新生代采用复制算法，老年代采用标记整理算法。</p>
<h4 id="Parallel-Scavenge垃圾收集器"><a href="#Parallel-Scavenge垃圾收集器" class="headerlink" title="Parallel Scavenge垃圾收集器"></a>Parallel Scavenge垃圾收集器</h4><p>Parallel Scavenge是一种新生代收集器，使用复制算法的收集器，而且是并行的多线程收集器。Parallel收集器特点是更加关注吞吐量（吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值）。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。</p>
<h4 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h4><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法实现的，是一种老年代收集器，通常与ParNew一起使用。</p>
<p>CMS的垃圾收集过程可分为四步：</p>
<ul>
<li><strong>初始标记</strong>：需要Stop The Wrold，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。</li>
<li><strong>并发标记</strong>：是主要标记过程，这个标记过程是和用户线程并发执行的。</li>
<li><strong>重新标记</strong>：需要“Stop The World”，为了修正并发标记期间因用户程序运作而导致标记产生变动的那一部分对象的标记记录，停顿比初始标记长，但比并发标记短得多。</li>
<li><strong>并发清除</strong>：和用户线程并发执行的，基于标记结果来清理对象</li>
</ul>
<p><strong>如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？</strong></p>
<p>答：不会的，在并发标记阶段其实还包括了一次并发的<strong>预清理阶段</strong>，虚拟机会主动<strong>等待年轻代发生垃圾回收</strong>，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。</p>
<p><strong>优点</strong>：并发收集，停顿时间低</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>会产生浮动垃圾。因此必须提前进行垃圾收集。通过参数<strong>-XX:CMSInitiatingOccupancyFraction</strong>的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现<strong>Concurrent Mode Failure失败</strong>，之后会临时使用Serial Old收集器作为老年代收集器，会产生更长时间的停顿。</li>
<li>标记-清除算法会产生内存碎片。可以使用参数<strong>-XX：UseCMSCompactAtFullCollection</strong>来控制是否开启内存整理（无法并发，默认是开启的）。参数<strong>-XX:CMSFullGCsBeforeCompaction</strong>用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）</li>
</ul>
<p><strong>浮动垃圾</strong>：由于在应用运行的同时进行垃圾回收，所以有些垃圾可能会在垃圾回收进行完成时产生，这就造成了“Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，<strong>并发收集器一般需要20%的预留空间</strong>用于这些浮动垃圾。</p>
<h4 id="G1（Garbage-First）收集器"><a href="#G1（Garbage-First）收集器" class="headerlink" title="G1（Garbage-First）收集器"></a>G1（Garbage-First）收集器</h4><p>G1收集器将新生代和老年代取消了，取而代之的是将堆划分成若干的区域，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。</p>
<p>通过将JVM堆分成一个个的区域（region），G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据回收时间来优先回收价值最大的region。</p>
<p>特点：</p>
<ul>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合：G1从整体来看是基于标记-整理算法，从局部来看基于复制算法实现，G1运作期间不会产生内存空间碎片。</li>
<li>可预测的停顿</li>
</ul>
<p>也可分为四个阶段</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<h3 id="JVM常用的内存调优命令"><a href="#JVM常用的内存调优命令" class="headerlink" title="JVM常用的内存调优命令"></a>JVM常用的内存调优命令</h3><ul>
<li><strong>jps</strong>：主要用来输出JVM中运行的进程状态信息，一般使用jps命令来查看进程的状态信息，包括JVM启动参数等。</li>
<li><strong>jinfo</strong>：主要用来观察进程运行环境参数等信息。</li>
<li><strong>jstack</strong>：主要用来查看某个Java进程内的线程堆栈信息。jstack pid可以看到当前进程中各个线程的状态信息，包括其持有的锁和等待的锁</li>
<li><strong>jmap</strong>：用来查看堆内存使用状况。jmap -heap pid可以看到当前进程的堆信息和使用的GC收集器，包括年轻代和老年代的大小分配等。</li>
<li><strong>jstat</strong>：进行实时命令行的监控，包括堆信息以及实时GC信息等。可以使用jstat -gcutil pid 1000来每隔一秒来查看当前的GC信息。</li>
</ul>
<h3 id="JDK8中内存管理的变化"><a href="#JDK8中内存管理的变化" class="headerlink" title="JDK8中内存管理的变化"></a>JDK8中内存管理的变化</h3><p>JDK8中出现了元空间代替了永久代。元空间和永久代类似，都是对JVM规范中方法区的实现。区别在于元空间并不在虚拟机中，而是使用本地内存，默认情况下元空间的大小仅受本地内存限制。</p>
<p>字符串在永久代中，容易出现性能问题和内存溢出的问题。类和方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出。使用元空间则使用了本地内存。</p>
<h3 id="Java中的类加载机制"><a href="#Java中的类加载机制" class="headerlink" title="Java中的类加载机制"></a>Java中的类加载机制</h3><p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用、卸载七个过程。类的加载机制保持则包括前面五个阶段。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的作用是确保被加载的类的正确性，包括文件格式验证，元数据验证，字节码验证以及符号引用验证。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段为类的静态变量分配内存，并将其初始化为默认值。假设一个类变量的定义为public static int val = 3，那么变量val在准备阶段过后的初始值不是3而是0.</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段将类中符号引用转换为直接引用。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul>
<li><strong>启动类加载器</strong>：启动类加载器负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的类。</li>
<li><strong>扩展类加载器</strong>：扩展类加载器负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。</li>
<li><strong>应用类加载器</strong>：应用类加载器负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。</li>
</ul>
<h4 id="类加载器的职责"><a href="#类加载器的职责" class="headerlink" title="类加载器的职责"></a>类加载器的职责</h4><ul>
<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入</li>
<li>父类委托，类加载机制会先让父加载器试图加载该类，只有在父类加载器无法加载该类时才会尝试从自己的类路径中加载该类。父类委托机制是为了防止内存中出现多份相同的字节码，保证java程序安全稳定运行。</li>
<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要某个Class时，先从缓存区中寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
        <tag>JVM内存</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-找到二叉树中的最大搜索二叉树</title>
    <url>/2020/02/05/%E7%AE%97%E6%B3%95-%E6%89%BE%E5%88%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一颗二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索而叉子树，并返回这棵子树的头节点。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p><strong>树形dp套路</strong></p>
<p>其使用前提是：如果题目求解目标是S规则，则求解流程可以定成以每一个节点为头节点的子树在S规则下的每一个答案，并且最终答案一定在其中。</p>
<p>树形dp套路第一步：以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是以X的左子树、X的右子树和X整棵树的角度来考虑可能性的。</p>
<p>树形dp套路第二步：根据第一步的可能性分析，列出所有需要的信息。</p>
<p>树形dp套路第三步：合并第二步的信息，对左子树和右子树提出同样的要求，并写出信息结构。</p>
<p>树形dp套路第四步：设计递归函数，递归函数是处理以X为头节点的情况下的答案，包括设计递归的base case，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node maxBSTHead;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxBSTSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnType</span><span class="params">(Node maxBSTHead,<span class="keyword">int</span> maxBSTSize, <span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxBSTHead = maxBSTHead;</span><br><span class="line">        <span class="keyword">this</span>.maxBSTSize = maxBSTSize;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnType <span class="title">process</span><span class="params">(Node X)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(X == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(<span class="keyword">null</span>, <span class="number">0</span>, Integer.MAX_VALUE, Integer.MIN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnType lData = process(X.left);</span><br><span class="line">    ReturnType rData = process(X.right);</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(X.value, Math.min(lData.min, rData.min));</span><br><span class="line">    <span class="keyword">int</span> max = Math.max(X.value, Math.max(lData.max, rData.max));</span><br><span class="line">    <span class="keyword">int</span> maxBSTSize = Math.max(lData.maxBSTSize, rData.maxBSTSize);</span><br><span class="line">    Node maxBSTHead = lData.maxBSTSize &gt; rData.maxBSTSize ?</span><br><span class="line">        lData.maxBSTHead : rData.maxBSTHead;</span><br><span class="line">    <span class="keyword">if</span>(lData.maxBSTHead == X.left &amp;&amp; rData.maxBSTHead == X.right &amp;&amp; X.value &gt; lData.max &amp;&amp; X.value &lt; rData.min)&#123;</span><br><span class="line">        maxBSTSize = lData.maxBSTSize + rData.maxBSTSize + <span class="number">1</span>;</span><br><span class="line">        maxBSTHead = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(maxBSTHead, maxBSTSize, min, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getMaxBST</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).maxHSTHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java进阶-高效并发编程</title>
    <url>/2020/02/05/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E8%BF%9B%E9%98%B6-%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Java进阶-高效并发编程"><a href="#Java进阶-高效并发编程" class="headerlink" title="Java进阶-高效并发编程"></a>Java进阶-高效并发编程</h2><a id="more"></a>

<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul>
<li>进程是一个“执行中的程序”，是系统进行<strong>资源分配和调度</strong>的一个独立单位</li>
<li>线程是进程的一个实体，一个进程中一般拥有多个线程。线程之间<strong>共享地址空间</strong>和其他资源</li>
<li>线程一般不拥有系统资源，但是也有一些必不可少的资源（使用ThreadLocal存储）</li>
<li>线程上下文的切换比进程上下文切换要快很多</li>
</ul>
<h4 id="线程上下文切换比进程上下文切换快的原因"><a href="#线程上下文切换比进程上下文切换快的原因" class="headerlink" title="线程上下文切换比进程上下文切换快的原因"></a>线程上下文切换比进程上下文切换快的原因</h4><ul>
<li>进程切换时涉及到当前进程的CPU环境保存和新被调度运行进程的CPU环境的设置</li>
<li>线程切换时，仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作</li>
</ul>
<h4 id="进程之间常见的通信方式："><a href="#进程之间常见的通信方式：" class="headerlink" title="进程之间常见的通信方式："></a>进程之间常见的通信方式：</h4><ul>
<li>通过使用套接字Socket来实现不同机器间的进程通信</li>
<li>通过映射一段可以被多个进程访问的共享内存来进行通信</li>
<li>通过写进程和读进程利用管道进行通信</li>
</ul>
<h3 id="多线程与单线程的关系"><a href="#多线程与单线程的关系" class="headerlink" title="多线程与单线程的关系"></a>多线程与单线程的关系</h3><ul>
<li>多线程是指在一个进程中，并发执行了多个线程。</li>
<li>在单核CPU中，将CPU分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用CPU的机制。由于CPU轮询的速度非常开，所以看起来像是”同时“在执行一样</li>
<li>多线程会存在线程上下文切换，会导致程序执行速度变慢</li>
<li>多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以<strong>减少用户的等待响应时间，提高了资源的利用效率</strong></li>
</ul>
<h3 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h3><p>线程的状态包括新建状态（NEW）、运行状态（RUNNABLE），阻塞状态等待和消亡状态（TERMINATED）。而阻塞等待状态又分为BLOCKED, WAITING和TIMED_WAITING。</p>
<p>BLOCKED是当线程准备进入synchronized同步块或者同步方法的时候，需要申请一个监视器锁而进行的等待；而WAITING和TIMED_WAITING是调用了Object.wait(), Thread.join()或者LockSupport.park()，其中TIMED_WAITING是时间明确的。</p>
<h3 id="多线程编程中常用的函数比较"><a href="#多线程编程中常用的函数比较" class="headerlink" title="多线程编程中常用的函数比较"></a>多线程编程中常用的函数比较</h3><ul>
<li>sleep方法是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会接触阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁。</li>
<li>wait方法是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyAll被调用时，才会解除阻塞。但是只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</li>
<li>join方法：当前线程调用，则其他线程全部停止，等待当前线程执行完毕，接着执行。</li>
<li>yield方法使得线程放弃当前分得的CPU时间。但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得CPU时间。</li>
</ul>
<h3 id="线程的活性故障"><a href="#线程的活性故障" class="headerlink" title="线程的活性故障"></a>线程的活性故障</h3><p>由于资源的稀缺性或者程序自身的问题导致线程一直处于非Runnable状态，并且其处理的任务一直无法完成的线程被称为是线程活性故障。常见的线程活性故障包括死锁，锁死，活锁与线程饥饿。</p>
<h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>死锁产生的四个必要条件：</p>
<ul>
<li>资源互斥：一个资源只能被一个线程使用</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对以获得资源保持不放</li>
<li>不剥夺条件：线程已经获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干线程之间形成一种头尾相连的循环等待资源关系</li>
</ul>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ul>
<li>粗锁法</li>
<li>锁排序法</li>
<li>使用显示锁中的ReentrantLock.try()来申请锁</li>
</ul>
<h4 id="线程锁死"><a href="#线程锁死" class="headerlink" title="线程锁死"></a>线程锁死</h4><p>线程锁死是指等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态，导致其任务一直无法进展。可以分为<strong>信号丢失锁死</strong>（典型例子是没有对保护条件进行判断，在等待之前保护条件就已经满足了）、<strong>嵌套监视器锁死</strong>（只释放了内层锁，而没有释放外层锁，导致等待线程无法获得外层锁而一直处于等待状态）</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁是一种特殊的线程活性故障。当一个线程一直处于运行状态，但是其所执行的任务却没有任务进展。</p>
<h4 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h4><p>线程饥饿是指线程一直无法获得其所需的资源导致任务一直无法运行的情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>线程饥饿发生时，如果线程处于可运行状态，也就是一直在申请资源，那么就会转变为活锁</li>
<li>只要存在一个或多个线程因为获取不到其所需的资源而无法进展就是线程饥饿，所以线程死锁其实也算是线程饥饿。</li>
</ul>
<h3 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>对于涉及到共享变量访问的操作，若该操作从执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，该操作具有原子性。</p>
<p>实现方式有：</p>
<ul>
<li>利用锁的排他性</li>
<li>利用CAS（Compare And Swap）保证</li>
<li>Java语言规范中，保证了除long和double型以外的任何变量的写操作都是原子操作</li>
<li>Java语言规范中，volatile关键字修饰的变量可以保证其写操作的原子性</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指一个线程对于共享变量的更新，对于后续访问该变量的线程是否可见的问题。</p>
<p>可见性的保障：</p>
<ul>
<li>当前处理器需要刷新处理器缓存，使得其余处理器对变量所作的更新可以同步到当前的处理器缓存中</li>
<li>当前处理器对共享变量更新之后，需要冲刷处理器缓存，使得该更新可以被写入处理器缓存中。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性是指一个处理器上运行的线程所执行的内存访问操作在另一个处理器上运行的线程来看是否有序的问题。</p>
<p><strong>重排序</strong>：为了提高程序执行的性能，Java编译器在其认为不影响程序正确性的前提下，可能会对源代码顺序进行一定的调整，导正程序运行顺序与源代码顺序不一致。</p>
<p>可以这么认为，<strong>原子性 + 可见性 -&gt; 有序性</strong></p>
<h3 id="谈谈你对synchronized关键字的理解"><a href="#谈谈你对synchronized关键字的理解" class="headerlink" title="谈谈你对synchronized关键字的理解"></a>谈谈你对synchronized关键字的理解</h3><p>synchronized是Java中的一个关键字，是一个内部锁。它可以使用在方法和代码块上，表示同步方法和同步代码块。在多线程环境下，同步方法或者同步代码块在同一时刻只允许有一个线程在运行。</p>
<h4 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h4><ul>
<li>进入时，执行monitorenter，将计数器+1，释放锁monitorexit时，计数器-1</li>
<li>当一个线程判断到计数器为0时，则当前锁空闲，可以占用；反之，当前线程进入等待状态</li>
</ul>
<h4 id="JVM对synchronized内部锁的调度"><a href="#JVM对synchronized内部锁的调度" class="headerlink" title="JVM对synchronized内部锁的调度"></a>JVM对synchronized内部锁的调度</h4><p>非公平的调度方式</p>
<p>JVM会给每个内部锁分配一个入口集（Entry Set），用于记录等待获得相应内部锁的线程。当锁被持有的线程释放的时候，该锁的入口集中的任意一个线程将会被唤醒，从而得到再次申请锁的机会。被唤醒的线程等待占有处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放的锁。</p>
<h3 id="谈谈你对volatile关键字的理解"><a href="#谈谈你对volatile关键字的理解" class="headerlink" title="谈谈你对volatile关键字的理解"></a>谈谈你对volatile关键字的理解</h3><ul>
<li>volatile可以保证主内存和工作内存直接产生交互，进行读写操作，保证可见性</li>
<li>volatile仅能保证变量写操作的原子性，不能保证读写操作的原子性</li>
<li>volatile可以禁止指令重排序</li>
<li>volatile不会导致线程上下文切换，但是其读取变量的成本较高，因为每次都需要从高速缓存或者主内存中读取，无法直接从寄存器中读取变量。</li>
</ul>
<h4 id="volatile在什么情况下可以替代锁"><a href="#volatile在什么情况下可以替代锁" class="headerlink" title="volatile在什么情况下可以替代锁"></a>volatile在什么情况下可以替代锁</h4><p>volatile是一个轻量级的锁，适合多个线程共享一个状态变量。可以将多个线程共享的一组状态变量合并成一个对象，用一个volatile变量来引用该对象，从而替代锁</p>
<h3 id="Java中的线程池有了解吗"><a href="#Java中的线程池有了解吗" class="headerlink" title="Java中的线程池有了解吗"></a>Java中的线程池有了解吗</h3><p>java.util.concurrent.ThreadPoolExecutor类就是一个线程池。客户端调用ThreadPoolExecutor.submit(Runnable task)提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有3种形态：</p>
<ul>
<li><strong>当前线程池大小</strong>：表示线程池中实际工作者线程的数量</li>
<li><strong>最大线程池大小（maxinumPoolSize）</strong>：表示线程池中允许存在的工作者线程的数量上限</li>
<li><strong>核心线程大小（corePoolSize ）</strong>：表示一个不大于最大线程池大小的工作者线程数量上限</li>
</ul>
<h4 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h4><ul>
<li>可以重复利用已有的线程，一次创建可以执行多次任务，有效降低线程创建和销毁所造成的资源消耗</li>
<li>使请求可以快速得到响应，节约了创建线程的时间</li>
<li>可以更好地管理线程，做到统一分配、调优和监控线程，提高系统的稳定性</li>
</ul>
<h4 id="线程池的排队策略"><a href="#线程池的排队策略" class="headerlink" title="线程池的排队策略"></a>线程池的排队策略</h4><ul>
<li>如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程</li>
<li>等于或者多于corePoolSize，则排队等待，如果队列满了，就创建新的线程，如果线程数超出maximumPoolSize则默认会拒绝任务。</li>
</ul>
<h4 id="常见的线程池类型："><a href="#常见的线程池类型：" class="headerlink" title="常见的线程池类型："></a>常见的线程池类型：</h4><p><strong>newCachedThreadPool( )</strong></p>
<ul>
<li>核心线程池大小为0，最大线程池大小不受限，来一个创建一个线程</li>
<li>适合用来执行大量耗时较短且提交频率较高的任务</li>
</ul>
<p><strong>newFixedThreadPool( )</strong></p>
<ul>
<li>固定大小的线程池</li>
<li>当线程池大小达到核心线程池大小，就不会增加也不会减小工作者线程的固定大小的线程池</li>
</ul>
<p><strong>newSingleThreadExecutor( )</strong></p>
<ul>
<li>便于实现单（多）生产者-消费者模式</li>
</ul>
<h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><p><strong>ArrayBlockingQueue</strong>：</p>
<ul>
<li>内部使用一个<strong>数组</strong>作为其存储空间，数组的存储空间是<strong>预先分配</strong>的</li>
<li><strong>优点是</strong> put 和 take操作不会增加GC的负担（因为空间是预先分配的）</li>
<li><strong>缺点是</strong> put 和 take操作使用同一个锁，可能导致锁争用，导致较多的上下文切换。</li>
<li>ArrayBlockingQueue适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li>
</ul>
<p><strong>LinkedBlockingQueue</strong>：</p>
<ul>
<li>是一个无界队列（其实队列长度是Integer.MAX_VALUE）</li>
<li>内部存储空间是一个<strong>链表</strong>，并且链表节点所需的<strong>存储空间是动态分配</strong>的</li>
<li><strong>优点是</strong> put 和 take 操作使用两个显式锁（putLock和takeLock）</li>
<li><strong>缺点是</strong>增加了GC的负担，因为空间是动态分配的。</li>
<li>LinkedBlockingQueue适合在生产者线程和消费者线程之间的并发程序较高的情况下使用。</li>
</ul>
<p><strong>synchronousQueue</strong>：</p>
<p>SynchronousQueue可以被看做一种特殊的有界队列。生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品，适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</p>
<h3 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a>CountDownLatch和CyclicBarrier</h3><p><strong>CountDownLatch</strong>是一个倒计时协调器，它可以实现一个或多个线程等待其余线程完成一组特定的操作之后，继续运行。</p>
<p>CountDownLatch.await() 和 CountDownLatch.countDown()</p>
<p><strong>CyclicBarrier</strong>是一个栅栏，可以实现多个线程互相等待执行到指定的地点，这时候这些线程会接着执行，在实际工作中可以用来模拟高并发请求测试。</p>
<p>CyclicBarrier.await()</p>
<h3 id="ThreadLocal有了解吗"><a href="#ThreadLocal有了解吗" class="headerlink" title="ThreadLocal有了解吗"></a>ThreadLocal有了解吗</h3><p>使用ThreadLocal维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响到其他线程对应的副本。</p>
<h4 id="ThreadLocal内部实现"><a href="#ThreadLocal内部实现" class="headerlink" title="ThreadLocal内部实现"></a>ThreadLocal内部实现</h4><ul>
<li>每个线程内部都会维护一个类似HashMap的对象，称为ThreadLocalMap，里边会包含若干个Entry(K-V键值对)，对应的线程被称为这些Entry的属主线程。</li>
<li>Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象。Entry的作用是为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系</li>
<li>Entry对Key的引用是弱引用；Entry对Value的引用是强引用（造成内存泄漏的原因）</li>
</ul>
<h3 id="对Atmoic有了解吗"><a href="#对Atmoic有了解吗" class="headerlink" title="对Atmoic有了解吗"></a>对Atmoic有了解吗</h3><p><strong>AtomicInteger类提供了getAndIncrement和incrementAndGet等原子性的自增自减等操作</strong>。<strong>Atomic等原子类内部使用了CAS来保证原子性。</strong></p>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Java进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-判断一个链表是否为回文结构</title>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表的头节点head，请判断该链表是否为回文结构</p>
<p>进阶：要求时间复杂度为O(N),额外空间复杂度为O(1)</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>利用<strong>栈</strong>，将右半部分压栈，然后依次弹栈和左半部分比较即可。需要注意奇偶数，可以用双指针。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node right = head.next;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右半部分压栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.value != stack.pop().value)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不使用栈</strong>：</p>
<ol>
<li>改变链表右半区的结构，使整个右半区反转，最后指向中间节点</li>
<li>leftStart和rightStart同时向中间移动，移动每一步都要比较leftStart和rightStart节点的值是否相等</li>
<li>恢复原来的结构</li>
<li>返回结果</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node n1 = head;</span><br><span class="line">   	Node n2 = head;</span><br><span class="line">    <span class="comment">// 找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span>(n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2 = n1.next;</span><br><span class="line">    n1.next = <span class="keyword">null</span>;		<span class="comment">// mid -&gt; next = null</span></span><br><span class="line">    Node n3 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 反转右半部分</span></span><br><span class="line">    <span class="keyword">while</span>(n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n3 = n2.next;</span><br><span class="line">        n2.next = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    n3 = n1;	<span class="comment">// n3保存最后一个节点</span></span><br><span class="line">    n2 = head;	<span class="comment">// n2对应左边第一个节点</span></span><br><span class="line">    <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(n1 != <span class="keyword">null</span> &amp;&amp; n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1.value != n2.value)&#123;</span><br><span class="line">            res = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1.next;</span><br><span class="line">        n2 = n2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n1 = n3.next;</span><br><span class="line">    n3.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 恢复链表</span></span><br><span class="line">    <span class="keyword">while</span>(n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = n3;</span><br><span class="line">        n3 = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-反转部分单向链表</title>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。</p>
<a id="more"></a>

<p>例如：</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null, from = 2, to = 4</p>
<p>调整结果为1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null</p>
<p>再如：</p>
<p>1-&gt;2-&gt;3-&gt;null, from = 1, to = 3</p>
<p>调整结果为3-&gt;2-&gt;1-&gt;null</p>
<p>要求时间复杂度为O(N),额外空间复杂度为O(1)</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol>
<li>先判断是否满足1≤from≤to≤N，如果不满足，直接返回head</li>
<li>找到第个from-1节点fPre和第to+1个节点tPos。把反转的部分先反转，然后正确地连接fPre和tPos。</li>
<li>如果fPre为null说明反转部分包含头节点，则返回反转部分的最后一个节点，否则返回原头节点。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverserPart</span><span class="params">(Node head,<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node node1 = head;</span><br><span class="line">    Node fPre = <span class="keyword">null</span>;</span><br><span class="line">    Node tPos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        fPre = len == from - <span class="number">1</span> ? node1 : fPre;</span><br><span class="line">        tPos = len == to + <span class="number">1</span> ? node1 : tPos;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(from &gt; to || from &lt; <span class="number">1</span> || to &gt; len)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    node1 = fPre == <span class="keyword">null</span> ? head : fPre.next;</span><br><span class="line">    Node node2 = node1.next;</span><br><span class="line">    node1.next = tPos;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(node2 != tPos)&#123;</span><br><span class="line">        next = node2.next;</span><br><span class="line">        node2.next = node1;</span><br><span class="line">        node1 = node2;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fPre != <span class="keyword">null</span>)&#123;</span><br><span class="line">        fPre.next = node1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java基础-三大集合</title>
    <url>/2020/02/04/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E5%9F%BA%E7%A1%80-%E4%B8%89%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="Java基础-三大集合"><a href="#Java基础-三大集合" class="headerlink" title="Java基础-三大集合"></a>Java基础-三大集合</h2><h3 id="说说Java中常见的集合吧"><a href="#说说Java中常见的集合吧" class="headerlink" title="说说Java中常见的集合吧"></a>说说Java中常见的集合吧</h3><a id="more"></a>

<ul>
<li>Map接口和Collection接口是所有集合框架的父接口</li>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、LinkedHashMap、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<h3 id="HashMap和Hashtable的区别有哪些？"><a href="#HashMap和Hashtable的区别有哪些？" class="headerlink" title="HashMap和Hashtable的区别有哪些？"></a>HashMap和Hashtable的区别有哪些？</h3><ul>
<li>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</li>
<li>HashMap允许null作为key；Hashtable不允许null作为Key，Hashtable的value也不可以为null</li>
</ul>
<h4 id="HashMap线程不安全的例子"><a href="#HashMap线程不安全的例子" class="headerlink" title="HashMap线程不安全的例子"></a>HashMap线程不安全的例子</h4><ul>
<li>HashMap线程不安全主要是考虑到了多线程环境下进行扩容可能会出现HashMap死循环</li>
<li>Hashtable线程安全是由于其内部实现的put和remove等方法上使用了synchronized进行了同步，所以对单个方法的使用是线程安全的，但是多个方法复用时，线程安全性无法保证。</li>
</ul>
<h4 id="Java集合中的快速失败（fast-fail）机制："><a href="#Java集合中的快速失败（fast-fail）机制：" class="headerlink" title="Java集合中的快速失败（fast-fail）机制："></a>Java集合中的快速失败（fast-fail）机制：</h4><p>快速失败机制是Java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast。</p>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount的值，如果是则返回遍历，否则抛出异常，终止遍历。</p>
<h3 id="HashMap底层实现结构有了解吗"><a href="#HashMap底层实现结构有了解吗" class="headerlink" title="HashMap底层实现结构有了解吗"></a>HashMap底层实现结构有了解吗</h3><p>HashMap底层实现数据结构为<strong>数组+链表</strong>的形式，JDK8及其以后的版本中使用了<strong>数组+链表+红黑树</strong>实现，解决了链表太长导致的查询速度变慢的问题。</p>
<h4 id="HashMap的初始容量，加载因子，扩容增量是多少"><a href="#HashMap的初始容量，加载因子，扩容增量是多少" class="headerlink" title="HashMap的初始容量，加载因子，扩容增量是多少"></a>HashMap的初始容量，加载因子，扩容增量是多少</h4><p>HashMap的初始容量是16，加载因子是0.75，扩容增量是原容量的1倍。HashMap扩容是指元素个数（包括数组和链表+红黑树中）超过16*0.75=12之后开始扩容。</p>
<h4 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a>HashMap的长度为什么是2的幂次方？</h4><p>我们将一个键值对插入HashMap中，通过将Key的hash值与length-1进行&amp;运算，实现了当前Key的定位，2的幂次方可以减少冲突（碰撞）的次数，提高HashMap查询效率。</p>
<h4 id="HashMap的存储和获取原理："><a href="#HashMap的存储和获取原理：" class="headerlink" title="HashMap的存储和获取原理："></a>HashMap的存储和获取原理：</h4><p>当调用put()方法传递键和值来存储时，先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来存储Entry对象，也就是找到了该元素应该被存储的桶中。当两个键的hashCode值相同时，bucket位置发生了冲突，也就是发生了Hash冲突，这个时候，会在每一个bucket后边接上一个链表（JDK8以后的版本会加上红黑树）来解决，将新存储的键值对放在表头（也即是bucket中）。</p>
<p>当调用get方法获取存储的值时，首先根据键的hashCode找到对应的bucket，然后根据equals方法来在链表和红黑树中找到对应的值。</p>
<h4 id="HasMap的扩容步骤："><a href="#HasMap的扩容步骤：" class="headerlink" title="HasMap的扩容步骤："></a>HasMap的扩容步骤：</h4><p>HashMap里面默认的负载因子大小为0.75，也就是说，当Map中的元素个数<strong>（包括数组，链表和红黑树中）</strong>超过了16<em>0.75=12之后开始扩容。将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作*</em>rehashing**，因为它调用hash方法找到新的bucket位置。</p>
<p>但是，需要注意的是在<strong>多线程环境</strong>下，HashMap扩容可能会导致<strong>死循环</strong>。</p>
<p>前面我们介绍了<strong>在HashMap存储的时候，会发生Hash冲突</strong>，那么我们一起来看Hash冲突的解决办法吧。</p>
<h4 id="解决Hash冲突的方法有哪些？"><a href="#解决Hash冲突的方法有哪些？" class="headerlink" title="解决Hash冲突的方法有哪些？"></a>解决Hash冲突的方法有哪些？</h4><ul>
<li>拉链法 <strong>（HashMap使用的方法）</strong></li>
<li>线性探测再散列法</li>
<li>二次探测再散列法</li>
<li>伪随机探测再散列法</li>
</ul>
<h4 id="哪些类适合作为HashMap的键？"><a href="#哪些类适合作为HashMap的键？" class="headerlink" title="哪些类适合作为HashMap的键？"></a>哪些类适合作为HashMap的键？</h4><p>String和Integer这样的包装类很适合作为HashMap的键，因为它们是final类型的类，而且重写了equals和hashCode方法，避免了键值对改写，有效提高HashMap性能。</p>
<h3 id="ConcurrentHashMap和Hashtable的区别"><a href="#ConcurrentHashMap和Hashtable的区别" class="headerlink" title="ConcurrentHashMap和Hashtable的区别"></a>ConcurrentHashMap和Hashtable的区别</h3><p>ConcurrentHashMap锁的方式是稍微细粒度的，ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁上当前需要用到的桶。</p>
<p><strong>Segment</strong>是一种<strong>可重入的锁ReentrantLock</strong>，每个Segment守护一个HashEntry数组里得元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment锁。</p>
<h3 id="TreeMap有哪些特性？"><a href="#TreeMap有哪些特性？" class="headerlink" title="TreeMap有哪些特性？"></a>TreeMap有哪些特性？</h3><p>TreeMap底层使用红黑树实现，TreeMap中存储的键值对按照键来排序</p>
<ul>
<li>如果Key存入的是字符串类型，那么会按照字典默认顺序排序</li>
<li>如果传入的是自定义引用类型，那么该对象必须实现Comparable接口，并且覆盖其compareTo方法；或者在创建TreeMap的时候，我们必须指定使用的比较器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：定义该类的时候，就指定比较规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里边定义其比较规则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式二：创建TreeMap的时候，可以指定比较规则</span></span><br><span class="line">    <span class="keyword">new</span> TreeMap&lt;User, Integer&gt;(<span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 在这里边定义其比较规则</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArrayList和LinkedList有哪些区别？"><a href="#ArrayList和LinkedList有哪些区别？" class="headerlink" title="ArrayList和LinkedList有哪些区别？"></a>ArrayList和LinkedList有哪些区别？</h3><ul>
<li>ArrayList底层使用了<strong>动态数组</strong>实现，实质上是一个动态数组</li>
<li>LinkedList底层使用了<strong>双向链表</strong>实现，可当作堆栈、队列、双端队列使用</li>
<li>ArrayList在随机存储方面效率高于LinkedList</li>
<li>LinkedList在节点的增删方面效率高于ArrayList</li>
<li>ArrayList必须预留一点空间，当空间不足时会进行扩容</li>
<li>LinkedList的开销是必须存储节点的信息以及节点的指针信息</li>
</ul>
<h3 id="HashSet和TreeSet有哪些区别"><a href="#HashSet和TreeSet有哪些区别" class="headerlink" title="HashSet和TreeSet有哪些区别"></a>HashSet和TreeSet有哪些区别</h3><ul>
<li>HashSet底层使用了Hash表实现。保证元素唯一性的原理：判断元素的hashCode值是否相同。如果相同，还会继续判断元素的equals方法，是否为true</li>
<li>TreeSet底层使用了红黑树来实现，保证元素唯一性是通过Comparable或者Comparator接口实现的</li>
</ul>
<p>其实，HashSet的底层实现还是HashMap，只不过其只使用了其中的Key，具体如下所示：</p>
<ul>
<li>HashSet的add方法底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。</li>
<li>HashSet的contains方法使用HashMap得containsKey方法实现</li>
</ul>
<h3 id="LinkedHashMap和LinkedHashSet"><a href="#LinkedHashMap和LinkedHashSet" class="headerlink" title="LinkedHashMap和LinkedHashSet"></a>LinkedHashMap和LinkedHashSet</h3><ul>
<li>LinkedHashMap内部的Entry继承于HashMap.Node，这两个类都实现了Map.Entry&lt;K,V&gt;</li>
<li>LinkedHashMap的Entry不光有value，next，还有before和after属性，这样通过一个双向链表，保证了<strong>各个元素的插入顺序</strong></li>
<li>通过构造方法public LinkedHashMap(int initalCapacity,float loadFactor, boolean accessOrder), accessOrder传入true可以实现<strong>LRU缓存</strong>算法。</li>
<li><strong>LinkedHashSet 底层使用LinkedHashMap实现</strong>，两者的关系类似与HashMap和HashSet的关系，大家可以自行类比。</li>
</ul>
<h3 id="List和Set的区别？"><a href="#List和Set的区别？" class="headerlink" title="List和Set的区别？"></a>List和Set的区别？</h3><ul>
<li>List是有序的并且元素是可以重复的</li>
<li>Set是无序的（LinkedHashSet除外），并且元素是不可重复的</li>
</ul>
<h3 id="Iteartor和ListIterator的区别是什么"><a href="#Iteartor和ListIterator的区别是什么" class="headerlink" title="Iteartor和ListIterator的区别是什么"></a>Iteartor和ListIterator的区别是什么</h3><ul>
<li>Iterator可以遍历list和set集合；ListIterator只能用来遍历list集合</li>
<li>Iterator前者只能前向遍历集合；ListIterator可以前向和后向遍历集合</li>
</ul>
<h3 id="数组和集合List之间的转换"><a href="#数组和集合List之间的转换" class="headerlink" title="数组和集合List之间的转换"></a>数组和集合List之间的转换</h3><h4 id="数组转为集合List"><a href="#数组转为集合List" class="headerlink" title="数组转为集合List"></a>数组转为集合List</h4><p>通过Arrays.asList方法，转换之后不可以使用add/remove等修改集合的相关方法，因为该方法返回的其实是一个Arrays的内部私有的一个类ArrayList</p>
<h4 id="集合转换数组"><a href="#集合转换数组" class="headerlink" title="集合转换数组"></a>集合转换数组</h4><p>List.toArray方法搞定了集合转换成数组，这里<strong>最好传入一个类型一样的数组</strong>，大小就是list.size()。因为如果入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为list.size()及其之后的数组元素将被置为null，其它数组元素保持原值。所以，建议该方法入参数组的大小与集合元素个数保持一致。</p>
<p>若是<strong>直接使用toArray无参方法</strong>，此方法返回值只能是Object[ ]类，若强转其它类型数组将出现<strong>ClassCastException</strong>错误。</p>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty核心API</title>
    <url>/2020/02/04/Netty%E6%A0%B8%E5%BF%83API/</url>
    <content><![CDATA[<h3 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h3><a id="more"></a>

<h4 id="ChannelHandler及其实现类"><a href="#ChannelHandler及其实现类" class="headerlink" title="ChannelHandler及其实现类"></a>ChannelHandler及其实现类</h4><p><img src="/images/ChannelHandler.png" alt="ChannelHandler"></p>
<p>我们经常需要自定义一个Handler类去继承ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，一般我们需要重写</p>
<ul>
<li>public void channelActive(ChannelHandlerContext ctx)，通道就绪事件</li>
<li>public void channelRead(ChannelHandlerContext ctx,Object msg)，通道读取数据事件</li>
<li>public void channelReadComplete(ChannelHandlerContext ctx)，通道读取完毕事件</li>
<li>public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause)，通道发生异常事件</li>
</ul>
<h4 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h4><p>ChannelPipeline是一个Handler的集合，它负责处理和拦截inbound或者outbound的事件和操作，相当于一个贯穿Netty的链。</p>
<ul>
<li>ChannelPipeline addFirst(ChannelHandler… handlers)，把一个业务处理类(handler)添加到链中的第一个位置</li>
<li>ChannelPipeline addLast(ChannelHandler… handlers)，把一个业务处理类(handler)添加到链中的最一个位置</li>
</ul>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>这是事件处理器上下文对象，Pipeline链中的实际处理节点。每个处理节点ChannelHandlerContext中包含一个具体的事件处理器ChannelHandler，同时ChannelHandlerContext中也绑定了对应的pipeline和Channel的信息，方便对ChannelHandler进行调用。</p>
<ul>
<li>ChannelFuture close(), 关闭通道</li>
<li>ChannelOutboundInvoker flush(), 刷新</li>
<li>ChannelFuture writeAndFlush(Object msg), 将数据写到ChannelPipeline中当前ChannelHandler的下一个ChannelHandler开始处理</li>
</ul>
<h4 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h4><p>Netty在创建Channel实例后，一般需要设置ChannelOption参数。常用的参数有</p>
<ul>
<li>ChannelOption.SO_BACKLOG：用来初始化服务器可连接队列的大小</li>
<li>ChannelOption.SO_KEEPALIVE，一直保持连接活动状态</li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>表示Channel中异步I/O操作的结果，在Netty中所有的I/O操作都是异步的，I/O的调用会直接返回。调用者并不能立刻获得结果，但是可以通过ChannelFuture来获取I/O操作的处理状态。常用方法如下：</p>
<ul>
<li>Channel channel()，返回当前正在进行IO操作的通道</li>
<li>ChannelFuture sync()，等待异步操作执行完毕</li>
</ul>
<h4 id="EventLoopGroup和其实现类NioEventLoopGroup"><a href="#EventLoopGroup和其实现类NioEventLoopGroup" class="headerlink" title="EventLoopGroup和其实现类NioEventLoopGroup"></a>EventLoopGroup和其实现类NioEventLoopGroup</h4><p>EventLoopGroup提供next接口，可以从组里按照一定规则获取其中一个EventLoop来处理任务。在Netty服务端编程中，我们一般需要提供两个EventLoopGroup，例如BossEventLoopGroup和WorkerEventLoopGroup。</p>
<p>通常一个服务端口即一个ServerSocktChannel对应一个Selector和一个EventLoop线程。BossEventLoop负责接收客户端的连接并将SocketChannel交给WorkerEventLoopGroup来进行IO处理。</p>
<p><img src="/images/Netty%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.png" alt="Netty处理模型"></p>
<p>BossEventLoopGroup通常是一个单线程的EventLoop，EventLoop维护着一个注册了ServerSocketChannel的Selector实例，BossEventLoop不断轮询Selector将连接事件分离出来，通常是OP_ACCEPT事件，然后将接收到的SocketChannel交给WorkerEventLoopGroup，WorkerEventLoopGroup会由next选择其中一个EventLoopGroup来讲这个SocketChannel注册到其维护的Selector并对其后续的IO事件进行处理。常用方法：</p>
<ul>
<li>public NioEventLoopGroup(), 构造方法</li>
<li>public Future&lt;?&gt; shutdownGracefully(), 断开连接，关闭线程</li>
</ul>
<h4 id="ServerBootstrap-和-Bootstrap"><a href="#ServerBootstrap-和-Bootstrap" class="headerlink" title="ServerBootstrap 和 Bootstrap"></a>ServerBootstrap 和 Bootstrap</h4><p>ServerBootstrap是Netty中的服务器端启动助手，通过它可以完成服务器端的各种配置；Bootstrap是Netty中的客户端启动助手，通过它可以完成客户端的各种配置；</p>
<ul>
<li>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)， 该方法用于服务器端，用来设置两个EventLoop</li>
<li>public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类（自定义的handler）</li>
<li>public ChannelFuture bind(inetPort), 该方法用于服务器端，用来设置占用的端口号</li>
<li>public ChannelFuture  connect(String inetHost, int inetPort)，该方法用于客户端，用来连接服务器端</li>
</ul>
<h4 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h4><p>这是Netty提供的一个专门用来操作缓冲区的工具类</p>
<ul>
<li>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)，通过给定的数据和字符编码返回一个ByteBuf对象</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-单调栈结构</title>
    <url>/2020/02/03/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个不含有重复值的数组arr，找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。</p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>arr = {3,4,1,5,6,2,7}</p>
<p>返回</p>
<p>{</p>
<p>{-1,2},{0,2},{-1,-1},{2,5},{3,5},{2,-1},{5,-1}</p>
<p>}</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>使用单调栈。</p>
<p>准备一个栈，记为stack&lt;Integer&gt;，栈中放的元素是数组的位置，开始时stack为空。如果找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置，那么需要让stack从栈顶到栈底是所代表的值是严格递减的。如果要找比位置i大的左右最近的值，那么从栈顶到栈底要是严格递增的。</p>
<p>当arr[i] &lt; 栈顶元素时，我们将栈顶元素弹出，记为cur，此时如果栈非空，那么当前栈顶元素就是离cur最近的左边的比它小的位置，而i就是cur离他最近的右边元素的位置；如果为空，那就记为-1，然后将当前元素压入栈中</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] getNearLessNoRepeat(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> popIndex = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        res[popIndex][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">        res[popIndex][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-生成滑动窗口的最大值数组</title>
    <url>/2020/02/03/%E7%AE%97%E6%B3%95-%E7%94%9F%E6%88%90%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。</p>
<p>如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>要求时间复杂度为O(N).</p>
<p>使用双端队列，具体过程如下：</p>
<ol>
<li>如果qmax为空，直接把下标i放进qmax，放入过程结束。</li>
<li>如果qmax不为空，取出当前qmax队尾存放的下标，假设为j</li>
<li>如果arr[j] &gt; arr[i]，直接把下标i放进qmax的队尾，放入过程结束。</li>
<li>如果arr[j] &lt;= arr[i]，把j从qmax中弹出，重复qmax的放入规则</li>
<li>如果qmax对头的下标等于i-w，说明当前qmax队头的下标已过期，弹出当前对头的下标即可。</li>
</ol>
<p>也就是队列总是从头到尾递减的，所以从队头取出的肯定是最大的。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMaxWindow(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> w)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || w &lt; <span class="number">1</span> || arr.length &lt; w)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[i])&#123;</span><br><span class="line">            qmax.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        qmax.addLast(i);</span><br><span class="line">        <span class="keyword">if</span>(qmax.peekFirst() == i - w)&#123;</span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= w - <span class="number">1</span>)&#123;</span><br><span class="line">            res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客专栏-Java基础-必知必会</title>
    <url>/2020/02/03/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-Java%E5%9F%BA%E7%A1%80-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h2 id="Java基础-必知必会"><a href="#Java基础-必知必会" class="headerlink" title="Java基础-必知必会"></a>Java基础-必知必会</h2><a id="more"></a>

<h3 id="面向对象可以解释下吗？都有哪些特性？"><a href="#面向对象可以解释下吗？都有哪些特性？" class="headerlink" title="面向对象可以解释下吗？都有哪些特性？"></a>面向对象可以解释下吗？都有哪些特性？</h3><p>答：面向对象是一种思想，可以将复杂问题简单化，让我们从执行者变成了指挥者。面向对象的三个特性是封装、继承与多态。</p>
<p><strong>封装</strong>：将事务封装成一个类，减少耦合，隐藏细节。保留特定的接口与外界联系，当接口内部发生变化时，不会影响外部调用方。（get/set体现）</p>
<p><strong>继承</strong>：从一个已知的类中派生出一个新的类，新类可以拥有已知类的行为和属性，并且可以通过覆盖/重写来增强已知类的能力。</p>
<p><strong>多态</strong>：多态的本质就是一个程序中存在多个同名的不同方法，主要通过三种方式来实现：</p>
<ol>
<li>通过子类对父类的覆盖来实现</li>
<li>通过在一个类中对方法的重载来实现</li>
<li>通过将子类对象作为父类对象使用来实现</li>
</ol>
<h4 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h4><p>Java中不支持多继承，即一个类只可以有一个父类。另外Java中的构造函数是不可以继承的，我们可以通过设置类的构造函数为private限制其被继承。</p>
<p>Java中类的<strong>初始化顺序</strong>：</p>
<ul>
<li>初始化父类的静态成员变量和静态代码块</li>
<li>初始化子类的静态成员变量和静态代码块</li>
<li>初始化父类中的普通成员变量和代码块，再执行父类的构造函数</li>
<li>初始化子类中的普通成员变量和代码块，再执行子类的构造函数</li>
</ul>
<h4 id="覆盖（-Override）"><a href="#覆盖（-Override）" class="headerlink" title="覆盖（@Override）"></a>覆盖（@Override）</h4><p>覆盖也叫重写，是指子类与父类之间方法的一种关系。子类中的方法与父类中继承的方法有完全小童的返回值类型、方法名、参数个数以及参数类型。</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载是指在一个类中（包括父类）存在多个同名的不同方法，这些方法的参数<strong>个数，顺序以及类型</strong>不同均可以构成方法的重载。如果仅仅是修饰符、返回值、抛出的异常不同，那么这是2个相同的方法。</p>
<h4 id="子类对象作为父类对象来使用"><a href="#子类对象作为父类对象来使用" class="headerlink" title="子类对象作为父类对象来使用"></a>子类对象作为父类对象来使用</h4><p>把不同的子类对象都作为父类对象来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。</p>
<p>对象的引用型变量具有多态性，因为一个引用型变量可以指向不同形式的对象，即：子类的对象作为父类的对象来使用。</p>
<p><strong>向上转型</strong>：</p>
<p>子类对象转为父类，父类可以是接口。</p>
<p>如Father f  = new Son(); Father是父类或者接口，Son是子类</p>
<p><strong>向下转型</strong>：</p>
<p>父类对象转为子类。Son s = (Son) f;</p>
<p>注意该父类必须实际指向一个子类对象才可以强制向下转型，即Father f = new Son();这样创建的。</p>
<h3 id="JDK-JRE和JVM的区别和联系有哪些？"><a href="#JDK-JRE和JVM的区别和联系有哪些？" class="headerlink" title="JDK,JRE和JVM的区别和联系有哪些？"></a>JDK,JRE和JVM的区别和联系有哪些？</h3><p><strong>JDK（Java Development Kit）</strong>是一个开发工具包，是Java开发环境的核心组件，并且提供编译、调试和运行一个Java程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件。</p>
<p><strong>JRE（Java Runtime Environment）</strong>是指Java运行时环境，是JVM的实现，提供了运行Java程序的平台。JRE包含了JVM，但不包含Java编译器/调试器之类的开发工具。</p>
<p><strong>JVM（Java Virtual Machine）</strong>是指Java虚拟机，当我们运行一个程序时，JVM负责将字节码转换成特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等。</p>
<h4 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h4><ul>
<li>JDK是开发工具包，用来开发Java程序，而JRE是Java的运行时环境</li>
<li>JDK和JRE都包含了JVM</li>
<li>JVM是Java编程的核心，独立于硬件和操作系统，具有平台无关性，而这也是Java可以一次编写，多次执行的原因。</li>
</ul>
<h4 id="Java语言的平台无关系是如何实现的？"><a href="#Java语言的平台无关系是如何实现的？" class="headerlink" title="Java语言的平台无关系是如何实现的？"></a>Java语言的平台无关系是如何实现的？</h4><ul>
<li>JVM屏蔽了操作系统和底层硬件的差异</li>
<li>Java面向JVM编程，先编译生成字节码文件，然后交给JVM解释生成机器码执行</li>
<li>通过规定基本数据类型的取值范围和行为</li>
</ul>
<h3 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h3><ul>
<li>抽象类中可以没有抽象方法，也可以抽象方法和非抽象方法共存</li>
<li>接口中的方法在JDK8之前只能是抽象的，JDK8版本开始提供了接口中方法的default实现</li>
<li>抽象类和类一样是单继承的；接口可以实现多个父接口</li>
<li>抽象类可以存在普通的成员变量；接口中的变量必须是static final类型的，必须被初始化，接口中只有常量，没有变量</li>
</ul>
<h4 id="在JDK8中为什么出现默认方法呢？"><a href="#在JDK8中为什么出现默认方法呢？" class="headerlink" title="在JDK8中为什么出现默认方法呢？"></a>在JDK8中为什么出现默认方法呢？</h4><p>使用接口，使得我们可以面向抽象编程，但是其有一个缺点就是当接口中有改动的时候，需要修改所有的实现类。在JDK8中，为了给已经存在的接口增加新的方法并且不影响已有的实现，所以引入了接口中的默认方法实现。</p>
<h3 id="Java中的8中基本数据类型及其取值范围"><a href="#Java中的8中基本数据类型及其取值范围" class="headerlink" title="Java中的8中基本数据类型及其取值范围"></a>Java中的8中基本数据类型及其取值范围</h3><ul>
<li>byte：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
<li>float：4字节</li>
<li>double：8字节</li>
<li>char：2字节</li>
<li>boolean：Java规范中并没有规定boolean类型所占字节数</li>
</ul>
<h3 id="Java的元注解有哪些"><a href="#Java的元注解有哪些" class="headerlink" title="Java的元注解有哪些"></a>Java的元注解有哪些</h3><ul>
<li>@Target：说明注解所修饰的对象范围</li>
<li>@Rentention：保留策略定义了该注解被保留的时间长短。其指有SORUCE、CLASS、RUNTIME</li>
<li>@Documented：用于描述其他类型的annotation应该被作为被标注的程序成员的公共API，因此可以被javadoc此类的工具文档化。</li>
<li>@Inherited：标记注解，@Inherited阐述了某个被标注的类型是被继承的。</li>
</ul>
<h4 id="注解的功能"><a href="#注解的功能" class="headerlink" title="注解的功能"></a>注解的功能</h4><p>代替繁杂的配置文件，简化开发。</p>
<h4 id="如何定义注解"><a href="#如何定义注解" class="headerlink" title="如何定义注解"></a>如何定义注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用MyAnn注解</span></span><br><span class="line"><span class="meta">@MyAnn</span>(num = <span class="number">100</span>, value = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说说Java中反射机制"><a href="#说说Java中反射机制" class="headerlink" title="说说Java中反射机制"></a>说说Java中反射机制</h3><p>反射机制是指在运行中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。即动态获取信息和动态调用对象方法的功能称为反射机制。</p>
<h4 id="与反射相关的类"><a href="#与反射相关的类" class="headerlink" title="与反射相关的类"></a>与反射相关的类</h4><ul>
<li>Class：表示类，用于获取类的相关信息</li>
<li>Field：表示成员变量，包括实例变量和静态变量</li>
<li>Method：表示方法，用于获取类中的方法参数和方法类型</li>
<li>Constructor：表示构造器，用于获取构造器的相关参数和类型。</li>
</ul>
<p>获取Class类有三种基本方法：</p>
<ol>
<li>通过类名称.class来获得</li>
<li>通过对象.getClass()方法来获得</li>
<li>通过类名称加载类Class.forName()</li>
</ol>
<h3 id="Java中的Exception和Error有什么区别"><a href="#Java中的Exception和Error有什么区别" class="headerlink" title="Java中的Exception和Error有什么区别"></a>Java中的Exception和Error有什么区别</h3><p>Exception是程序正常运行中<strong>预料</strong>到可能会出现的错误，并且可以<strong>被捕获</strong>并进行相应的处理，是一种异常现象。</p>
<p>Exception又分为运行时异常（受检异常）和编译时异常（非受检异常）</p>
<p>Error是正常情况下不可能发生的错误，Error会导致JVM处于一种不可恢复的状态，不需要捕获异常。</p>
<h3 id="JIT编译器有了解吗？"><a href="#JIT编译器有了解吗？" class="headerlink" title="JIT编译器有了解吗？"></a>JIT编译器有了解吗？</h3><p>JIT编译器全名叫Just In Time Compile，也就是即时编译器，把经常运行的代码作为”<strong>热点代码</strong>“编译成与本地平台相关的机器码，并进行各种层次的优化。JIT编译除了具有缓存的功能外，还会对代码做各种优化，包括逃逸分析，锁消除、锁膨胀、方法内联、空值检查消除、类型检测消除以及公共子表达式消除等。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。JIT编译器的优化包括：</p>
<ul>
<li>同布省略：也就是锁消除</li>
<li>标量替换。其中标量（Scalar）是指一个无法再分解成更小的数据的数据，比如原始数据类型；而聚合量（Aggregate）是可以分解的数据，比如对象。在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就是标量替换。其好处是对象可以不在堆内进行分配，为栈上分配提供了良好的基础。</li>
</ul>
<h3 id="Java中值传递和引用传递可以解释下吗？"><a href="#Java中值传递和引用传递可以解释下吗？" class="headerlink" title="Java中值传递和引用传递可以解释下吗？"></a>Java中值传递和引用传递可以解释下吗？</h3><p>值传递：意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。</p>
<p>引用传递：意味着传递的并不是实际的对象，而是对象的引用。因此外部对引用对象的改变会反映到所有的对象上。</p>
<h3 id="其余经典面试题"><a href="#其余经典面试题" class="headerlink" title="其余经典面试题"></a>其余经典面试题</h3><ul>
<li>StringBuffer与StringBuilder的区别？</li>
<li>Java中的泛型的理解</li>
<li>Java序列化与反序列化的过程</li>
<li>equals和hashCode方法的关系？</li>
<li>Java和C++的区别有哪些？</li>
<li>静态与非静态的区别？</li>
<li>Java中equals方法和==的区别？</li>
</ul>
]]></content>
      <categories>
        <category>牛客专栏</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NettyChat整理</title>
    <url>/2020/02/03/NettyChat%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="在SpringBoot中使用Netty"><a href="#在SpringBoot中使用Netty" class="headerlink" title="在SpringBoot中使用Netty"></a>在SpringBoot中使用Netty</h3><h4 id="Spring整合Netty"><a href="#Spring整合Netty" class="headerlink" title="Spring整合Netty"></a>Spring整合Netty</h4><a id="more"></a>

<p>websocketServer.start();用于启动netty服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring整合Netty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebSocketServer websocketServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.getApplicationContext().getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                websocketServer.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在start()方法中我们用于绑定端口号，而在构造方法中，我们创建接收线程组和工作线程组，然后创建服务器，并给服务器设置两个EventLoop、负责监听连接的通道和对应的自定义handler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;       <span class="comment">// 主线程池</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;     <span class="comment">// 工作线程池</span></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap server;         <span class="comment">// 服务器</span></span><br><span class="line">    <span class="keyword">private</span> ChannelFuture future;           <span class="comment">// 回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        future = server.bind(<span class="number">9001</span>);</span><br><span class="line">        System.out.println(<span class="string">"netty server - 启动成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebSocketServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        server.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">WebsocketInitializer</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="业务Handler"><a href="#业务Handler" class="headerlink" title="业务Handler"></a>业务Handler</h4><p>在WebsocketInitializer类中我们要将我们的业务处理类绑定到链上，即pipeline上。具体包括编解码器、对写大数据流的支持、对Http请求和相应的聚合器、对Websocket的支持、读写空闲和自定义的心跳、聊天处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------</span></span><br><span class="line">        <span class="comment">// 用于支持Http协议</span></span><br><span class="line">        <span class="comment">// ------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// websocket基于http协议，需要有http的编解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">// 对写大数据流的支持</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">        <span class="comment">// 添加对HTTP请求和响应的聚合器:只要使用Netty进行Http编程都需要使用</span></span><br><span class="line">        <span class="comment">// 对HttpMessage进行聚合，聚合成FullHttpRequest或者FullHttpResponse</span></span><br><span class="line">        <span class="comment">// 在netty编程中都会使用到Handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">1024</span> * <span class="number">64</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------支持Web Socket -----------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// websocket服务器处理的协议，用于指定给客户端连接访问的路由: /ws</span></span><br><span class="line">        <span class="comment">// 本handler会帮你处理一些握手动作: handshaking(close, ping, pong) ping + pong = 心跳</span></span><br><span class="line">        <span class="comment">// 对于websocket来讲，都是以frames进行传输的，不同的数据类型对应的frames也不同</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/ws"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加Netty空闲超时检查的支持</span></span><br><span class="line">        <span class="comment">// 读空闲超时（超过一定的时间会发送对应的事件消息）</span></span><br><span class="line">        <span class="comment">// 写空闲超时</span></span><br><span class="line">        <span class="comment">// 读写空闲超时</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> HeartBeatHandler());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ChatHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理聊天的自定义处理器中，我们通过重写父类的方法即可实现对新连接的客户端记录，并将userid和channelid通过map映射在一起。通过writeAndFlush()来发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理消息的handler</span></span><br><span class="line"><span class="comment"> * TextWebSocketFrame: 在netty中，是用于为websocket专门处理文本的对象，frame是消息的载体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来保存所有的客户端连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup clients = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当channel中有新的事件消息会自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当接收到数据后会自动调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取客户端发送过来的文本消息</span></span><br><span class="line">        String text = msg.text();</span><br><span class="line">        System.out.println(<span class="string">"接收到消息数据为："</span> + text);</span><br><span class="line"></span><br><span class="line">        Message message = JSON.parseObject(text, Message<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过SpringUtil工具类获取Spring IOC容器</span></span><br><span class="line">        ChatRecordService chatRecordService = SpringUtil.getBean(ChatRecordService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// IdWorker idWorker = SpringUtil.getBean(IdWorker.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (message.getType())&#123;</span><br><span class="line">            <span class="comment">// 建立用户与通道的关联</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                String userid = message.getChatRecord().getUserid();</span><br><span class="line">                UserChannelMap.put(userid, ctx.channel());</span><br><span class="line">                System.out.println(<span class="string">"建立用户："</span> + userid + <span class="string">"与通道"</span> + ctx.channel().id() + <span class="string">"的关联"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 处理客户端发送好友消息</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"接收到用户消息"</span>);</span><br><span class="line">                <span class="comment">// 将聊天消息保存到数据库</span></span><br><span class="line">                TbChatRecord chatRecord = message.getChatRecord();</span><br><span class="line">                chatRecordService.insert(chatRecord);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果好友在线，直接发送</span></span><br><span class="line">                Channel channel = UserChannelMap.get(chatRecord.getFriendid());</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    channel.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(JSON.toJSONString(message)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果不在线，暂时不发生</span></span><br><span class="line">                    System.out.println(<span class="string">"用户"</span>+chatRecord.getFriendid() + <span class="string">"不在线！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 处理客户端的签收消息</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="comment">// 将消息记录设置为已读</span></span><br><span class="line">                chatRecordService.updateStatusHasRead(message.getChatRecord().getId());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">// 接收心跳消息</span></span><br><span class="line">                System.out.println(<span class="string">"接收到心跳消息："</span> + JSON.toJSONString(message));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有新的客户端连接只会会调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将新的通道加入到clients</span></span><br><span class="line">        clients.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserChannelMap.removeByChannelId(ctx.channel().id().asLongText());</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭通道"</span>);</span><br><span class="line">        UserChannelMap.removeByChannelId(ctx.channel().id().asLongText());</span><br><span class="line">        UserChannelMap.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>netty整体设计</title>
    <url>/2020/02/03/netty%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="Netty整体设计"><a href="#Netty整体设计" class="headerlink" title="Netty整体设计"></a>Netty整体设计</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><a id="more"></a>

<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p><img src="/images/NIO%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="netty单线程模型"></p>
<p>服务端用一个线程通过多路复用搞定所有的IO操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑。之前的NIO案例就属于单线程模型</p>
<h4 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h4><p><img src="/images/NIO%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B.png" alt="netty线程池模型"></p>
<p>服务器端采用一个线程专门处理客户端连接请求，采用一个线程负责IO操作。在绝大多数场景下，改模型都能满足使用。</p>
<h4 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h4><p><img src="/images/netty%E6%A8%A1%E5%9E%8B.png" alt="netty模型"></p>
<p>比较类似于上面的线程池模型，Netty抽象出两组线程池，Boss Group专门负责接收客户端连接，WorkerGroup专门负责网络读写操作。NioEventLoop表示一个不断循环执行处理任务的线程，每个NioEventLoop都有一个selector，用于监听绑定在其上的socket网络通道。NioEventLoop内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送，始终由IO线程NioEventLoop负责。</p>
<ul>
<li>一个NioEventLoopGroup下包含多个NioEventLoop</li>
<li>每个NioEventLoop中包含有一个Selector，一个taskQueue</li>
<li>每个NioEventLoop的Selector上可以注册监听多个NioChannel</li>
<li>每个NioChannel只会绑定在唯一的NioEventLoop上</li>
<li>每个NioChannel都绑定有一个自己的ChannelPipeline</li>
</ul>
<h3 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h3><p>Netty的异步模型是建立在future和callback之上的。</p>
<p>在使用Netty进行编程时，拦截操作和转换出入站数据只需要提供callback或者利用future即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。Netty框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</p>
<p><img src="/images/netty%E9%93%BE%E5%BC%8F.png" alt="netty链式"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO-网络编程</title>
    <url>/2020/02/02/NIO-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="NIO网络编程基础"><a href="#NIO网络编程基础" class="headerlink" title="NIO网络编程基础"></a>NIO网络编程基础</h3><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a><strong>Selector</strong></h4><a id="more"></a>

<p>选择器，能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p>
<h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>代表了Selector和serverSocketChannel的注册关系，一共四种：OP_ACCEPT、OP_CONNECT、OP_READ、OP_WRITE</p>
<h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p>用来在服务器端监听新的客户端Socket连接</p>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>网络IO通道，具体负责进行读写操作。NIO总是把缓冲区的数据写入通道，或者把通道里的数据读出到缓冲区（buffer）</p>
<h4 id="NIO网络编程模型"><a href="#NIO网络编程模型" class="headerlink" title="NIO网络编程模型"></a>NIO网络编程模型</h4><p><img src="/images/NIO%E6%A8%A1%E5%9E%8B.png" alt="NIO模型"></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到一个网络通道</span></span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置非阻塞方式</span></span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 提供服务器端的IP和端口号</span></span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 连接服务器端</span></span><br><span class="line">        <span class="keyword">if</span> (!channel.connect(address))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!channel.finishConnect())&#123;</span><br><span class="line">                <span class="comment">// 非阻塞的</span></span><br><span class="line">                System.out.println(<span class="string">"Client:连接服务器是非阻塞的~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到一个缓冲区，并放入数据</span></span><br><span class="line">        String msg = <span class="string">"Hello Server!"</span>;</span><br><span class="line">        ByteBuffer writeBuf = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        channel.write(writeBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时阻塞客户端</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务器端代码"><a href="#服务器端代码" class="headerlink" title="服务器端代码"></a>服务器端代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到一个ServerSocketChannel对象</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 得到一个Selector对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 设置非阻塞方式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把ServerSocketChannel对象注册到Selector对象中</span></span><br><span class="line">        <span class="comment">// 监测是否有客户端连接</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 监控客户端</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">2000</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Server:没有客户端连接，非阻塞式"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到SelectionKey，判断通道里的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 客户端连接事件</span></span><br><span class="line">                    System.out.println(<span class="string">"OP_ACCEPT"</span>);</span><br><span class="line">                    <span class="comment">// 获取通道</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 读取客户端数据事件</span></span><br><span class="line">                    System.out.println(<span class="string">"OP_READ"</span>);</span><br><span class="line">                    <span class="comment">// 获取通道</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 获得附件</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="comment">// 从缓存中读取数据</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端的数据:"</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动从集合中移除当前的key，防止重复处理</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-有关阶乘的两个问题</title>
    <url>/2020/02/02/%E7%AE%97%E6%B3%95-%E6%9C%89%E5%85%B3%E9%98%B6%E4%B9%98%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数N，返回N!结果的末尾为0的数量。</p>
<p>例如5! = 120，有一个0，返回1；1000000000!的末尾有249999998个0，返回249999998。</p>
<a id="more"></a>

<p><strong>进阶问题</strong>：给定一个非负整数N，如果二进制表达N!的结果，返回最低位的1在哪个位置上，认为最右的位置为位置0.</p>
<p>例如：2! = 2，最低位的1在1位置上，1000000000!最低位的1在999999987位置上。</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>N!的末尾有多少个0可以转换为N!有多少个因子5，因为因子2一定比5多，而0只能从2*5得到，因此只要找出1~N所有的数中一共有多少个因子5即可。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">zeroNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; num + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cur = i;</span><br><span class="line">        <span class="keyword">while</span>(cur % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            cur = cur / <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法的效率并不高，对于每一次处理来说，处理的代价都是log5，所以时间复杂度为O(NlogN).</p>
<p>其实可以这样看N中有N/5个数能贡献一个因子5，而(N/5)中又有(N/5)/5个数能额外多贡献一个5……</p>
<p>所以<br>$$<br>Z = N/5 + N/(5^2) + N/(5^3) + … + N/(5^i)<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">zeroNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        res += num/<span class="number">5</span>;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时时间复杂度为O(logN).</p>
<p><strong>进阶问题</strong>：</p>
<p>最低位的1在哪个位置上完全取决于1~N有多少个因子2，因为一个二进制数*2就等于往末尾加一个0。同理可以得到<br>$$<br>Z = N/2 + N/(2^2) + N/(2^3) + … + N/(2^i)<br>$$<br>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightOne</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        res += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>阶乘</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-一行代码求两个数的最大公约数</title>
    <url>/2020/02/02/%E7%AE%97%E6%B3%95-%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个不等于0的整数M和N，求M和N的最大公约数。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>辗转相除法</p>
<p>如果q和r分别是m除以n的商及余数，即m = nq + r，那么m和n的最大公约数等于n和r的最大公约数。</p>
<p>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? m : gcd(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-从5随机到7随机及其扩展</title>
    <url>/2020/02/02/%E7%AE%97%E6%B3%95-%E4%BB%8E5%E9%9A%8F%E6%9C%BA%E5%88%B07%E9%9A%8F%E6%9C%BA%E5%8F%8A%E5%85%B6%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个等概率随机产生1~5的随机函数rand1To5如下：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1To5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，不能使用任何额外的随机机制，请用rand1To5实现等概率随机产生1~7的随机函数rand1To5.</p>
<p><strong>补充问题</strong>：给定一个以p概率产生0，以1-p概率产生1的随机函数rand01p如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand01p</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可随意改变p</span></span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">0.83</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &lt; p ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，不能使用任何额外的随机机制，请用rand01p实现等概率随机产生1~6的随机函数rand1To6.</p>
<p><strong>进阶问题</strong>：给定一个等概率随机产生1~m的随机函数rand1ToM如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1ToM</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random() * m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，不能使用任何额外的随机机制。有两个输入参数，分别为m和n，请用rand1ToM(m)实现等概率随机产生1~n的随机函数rand1ToN.</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>先解决原问题。</p>
<ol>
<li>rand1To5()等概率随机产生1，2，3，4，5</li>
<li>rand1To5()-1等概率随机产生0，1，2，3，4</li>
<li>(rand1To5()-1)*5 + (rand1To5()-1)等概率随机产生0，1，2，3，4，……，23，24.之所以乘以5是因为rand1To5()-1的长度为5，要随机产生范围更大的数只能乘以比它长度大的数。这就是“插空”的过程，即先随机产生0，5，10，15，20，然后对于0来说，随机加上0，1，2，3，4就是随机产生0，1，2，3，4，而对于5，10，15，20也是同理</li>
<li>如果上述步骤产生的结果大于20，则重复步骤3，直到产生的结果都在0<del>20之间。同时可以轻易知道出现21</del>24的概率会平均分配到0~20上。这就是“筛”过程。</li>
<li>上面的步骤会随机产生0<del>20，所以该结果再进行%7操作，就会等概率地随机产生0</del>6.</li>
<li>上面地步骤地结果再加1，就会等概率产生1~7.</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1To5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1To7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        num = (rand1To5()-<span class="number">1</span>) * <span class="number">5</span> + rand1To5() - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(num &gt; <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充问题</strong>：</p>
<p>虽然rand01p方法以p的概率产生0，以1-p的概率产生1，但是rand01p产生01和10的概率都是p(1-p)。利用这一点可以等概率产生01.</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand01p</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可随意改变p</span></span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">0.83</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.random() &lt; p ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        num = rand01p();</span><br><span class="line">    &#125; <span class="keyword">while</span>(num == rand01p());</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是“插空”和“筛”的过程</p>
<ol>
<li>0<del>1通过插空得到0</del>3</li>
<li>0<del>3通过插空得到0</del>15</li>
<li>0<del>15通过筛得到0</del>11</li>
<li>0<del>11通过%6得到0</del>5</li>
<li>0<del>5通过+1得到1</del>6</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand0To3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand01() * <span class="number">2</span> + rand01();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1To6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        num = rand0To3() * <span class="number">4</span> + rand0To3();</span><br><span class="line">    &#125; <span class="keyword">while</span>(num &gt; <span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进阶问题</strong>：</p>
<p>同样也是“插空”和“筛”操作。</p>
<p>如果m ≥ n，直接“筛”即可，而如果n&gt;m,则需要先“插空”来得到范围大于n的随机函数，然后再“筛”。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1ToM</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random() * m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand1ToN</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nMSys = getMSysNum(n-<span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">int</span>[] randNum = getRanMSysNumLessN(nMSys, m);</span><br><span class="line">    <span class="keyword">return</span> getNumFromMSysNum(randNum, m) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把value转成m进制数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMSysNum(<span class="keyword">int</span> value,<span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> index = res.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">0</span>)&#123;</span><br><span class="line">        res[index--] = value % m;</span><br><span class="line">        value = value / m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等概率随机产生一个0~nMsys范围的数，只不过是用m进制数表达的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getRanMSysNumLessN(<span class="keyword">int</span>[] nMSys, <span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nMSys.length];</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(nMSys[start] == <span class="number">0</span>)&#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于是32位的，前面有很多都是0</span></span><br><span class="line">    <span class="keyword">int</span> index = start;</span><br><span class="line">    <span class="keyword">boolean</span> lastEqual = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(index != nMSys.length)&#123;</span><br><span class="line">        res[index] = rand1ToM(m) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lastEqual)&#123;</span><br><span class="line">        	<span class="comment">// 只有当lastEqual为false时，即前一个数比原来笑了，该位置的数才能大于原来该位置的数，否则就大于原来的数了。</span></span><br><span class="line">            <span class="keyword">if</span>(res[index] &gt; nMSys[index])&#123;</span><br><span class="line">                index = start;</span><br><span class="line">                lastEqual = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastEqual = res[index] == nMSys[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把m进制数转换成十进制数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumFromMSysNum</span><span class="params">(<span class="keyword">int</span>[] mSysNum,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != mSysNum.length; i++)&#123;</span><br><span class="line">        res = res * m + mSysNum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-“之”字形打印矩阵</title>
    <url>/2020/02/01/%E7%AE%97%E6%B3%95-%E2%80%9C%E4%B9%8B%E2%80%9D%E5%AD%97%E5%BD%A2%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个矩阵matrix，按照“之”字形的方式打印这个矩阵，例如</p>
<a id="more"></a>

<p>1    2    3    4</p>
<p>5    6    7    8</p>
<p>9    10  11  12</p>
<p>“之”字形打印的结果为：1，2，5，9，6，3，4，7，10，11，8，12</p>
<p>要求：额外空间复杂度为O(1)</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol>
<li>上坐标(tR, tC)初始为(0,0)，先沿着矩阵第一行移动(tC++), 当到达第一行最右边的元素后，再沿着矩阵最后一列移动(tR++).</li>
<li>下坐标(dR, dC)初始为(0,0), 先沿着矩阵第一列移动(dC++), 当到达第一列最下边的元素后，再沿着矩阵最后一行移动(dC++).</li>
<li>上坐标与下坐标同步移动，每次移动后的上坐标与下坐标的连线就是矩阵中的一条斜线，打印斜线上的元素即可。</li>
<li>如果上次斜线是从左下到右上打印的，这次一定是从右上到左下，反之亦然。打印反向用一个boolean值表示即可。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatrixZigZag</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endR = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(tR != endR + <span class="number">1</span>)&#123;</span><br><span class="line">        printLevel(matrix,tR,tC,dR,dC,fromUp);</span><br><span class="line">        tR = tC == endC ? tR + <span class="number">1</span> : tR;</span><br><span class="line">        tC = tC == endC ? tC : tC + <span class="number">1</span>;</span><br><span class="line">        dC = dR == endR ? dC + <span class="number">1</span> : dC;</span><br><span class="line">        dR = dR == endR ? dR : dR + <span class="number">1</span>;</span><br><span class="line">        fromUp = !fromUp;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLevel</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> tR,<span class="keyword">int</span> tC,<span class="keyword">int</span> dR,<span class="keyword">int</span> dC,<span class="keyword">boolean</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)&#123;</span><br><span class="line">        <span class="keyword">while</span>(tR != dR + <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(m[tR++][tC--] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(dR != tR - <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(m[dR--][dC++] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-将正方形矩阵顺时针转动90°</title>
    <url>/2020/02/01/%E7%AE%97%E6%B3%95-%E5%B0%86%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E8%BD%AC%E5%8A%A890%C2%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个N×N的矩阵matrix，把这个矩阵调整成顺时针转动90°后的形式。</p>
<a id="more"></a>

<p>例如：</p>
<p>1    2    3    4</p>
<p>5    6    7    8</p>
<p>9    10  11  12</p>
<p>13  14  15  16</p>
<p>顺时针转动90°之后为：</p>
<p>13    9    5    1</p>
<p>14    10  6    2</p>
<p>15    11  7    3</p>
<p>16    12  8    4</p>
<p>要求：额外空间复杂度为O(1).</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>我们已经采用矩阵圈的方式来处理</p>
<p>​        1    2    3    4</p>
<p>​        5                8                              </p>
<p>​        9                12                                           </p>
<p>​        13  14  15  16</p>
<p>我们可以这样看1占据4的位置，4占据16的位置，16占据13的位置，13占据1的位置，然后继续处理2，8，15，9……</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123;</span><br><span class="line">        rotateEdge(matrix,tR++,tC++,dR--,dC--;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> tR,<span class="keyword">int</span> tC,<span class="keyword">int</span> dR,<span class="keyword">int</span> dC)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = dC - tC;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">        tmp = m[tR][tC + i];</span><br><span class="line">        m[tR][tC + i] = m[dR - i][tC];</span><br><span class="line">        m[dR - i][tC] = m[dR][dC - i];</span><br><span class="line">        m[dR][dC - i] = m[tR + i][dC];</span><br><span class="line">        m[tR + i][dC] = tmp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-转圈打印矩阵</title>
    <url>/2020/02/01/%E7%AE%97%E6%B3%95-%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整型矩阵matrix，请按照转圈的方式打印它</p>
<a id="more"></a>

<p>例如：</p>
<p>1    2    3    4</p>
<p>5    6    7    8</p>
<p>9    10  11  12</p>
<p>13  14  15  16</p>
<p>打印结果为：1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p>
<p>要求：额外空间复杂度为O(1)</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>该题在算法上没有任何难度，但是我们可以用另一种统一的矩阵处理方法来处理它，我们可以把矩阵看成很多环构成，比如本例中可以看作</p>
<p>​        1    2    3    4</p>
<p>​        5                8                              和             6    7</p>
<p>​        9                12                                            10    11</p>
<p>​        13  14  15  16</p>
<p>构成，我们可以通过矩阵圈的左上角和右下角确定唯一的矩阵圈。</p>
<p>然后根据题目要求打印矩阵圈即可。然后我们更新解释左上角往右下移动，右下角往左上移动。</p>
<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spiralOrderPrint</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123;</span><br><span class="line">        printEdge(matrix,tR++,tC++,dR--,dC--;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> tR,<span class="keyword">int</span> tC,<span class="keyword">int</span> dR,<span class="keyword">int</span> dC)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tR == dR)&#123;</span><br><span class="line">        <span class="comment">// 只有一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tC; i &lt;= dC; i++)&#123;</span><br><span class="line">            System.out.print(m[tR][i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tC == dC)&#123;</span><br><span class="line">        <span class="comment">// 只有一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = tR; i &lt;= dR; i++)&#123;</span><br><span class="line">            System.out.print(m[i][tC] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> curC = tC;</span><br><span class="line">        <span class="keyword">int</span> curR = tR;</span><br><span class="line">        <span class="comment">// 往右</span></span><br><span class="line">        <span class="keyword">while</span>(curC != dC)&#123;</span><br><span class="line">            System.out.print(m[tR][curC] + <span class="string">" "</span>);</span><br><span class="line">            curC++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往下</span></span><br><span class="line">        <span class="keyword">while</span>(curR != dR)&#123;</span><br><span class="line">            System.out.print(m[curR][dC] + <span class="string">" "</span>);</span><br><span class="line">            curR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往左</span></span><br><span class="line">        <span class="keyword">while</span>(curC != tC)&#123;</span><br><span class="line">            System.out.print(m[dR][curC] + <span class="string">" "</span>);</span><br><span class="line">            curC--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 往上</span></span><br><span class="line">        <span class="keyword">while</span>(curR != tR)&#123;</span><br><span class="line">            System.out.print(m[curR][tC] + <span class="string">" "</span>);</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring介绍</title>
    <url>/2020/02/01/Spring%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><a id="more"></a>

<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>IOC(Inversion of Control)：控制反转</p>
<p>DI(Dependency Inversion)：依赖注入，含义：把底层类作为<strong>参数</strong>传递给上层类，实现上层对下层的“控制”，而不是在上层类中new一个底层类</p>
<p>依赖注入的方式：</p>
<ol>
<li>Setter</li>
<li>Interface</li>
<li>Constructor</li>
<li>Annotation</li>
</ol>
<p>依赖倒置原则、IOC、DI、IOC容器的关系</p>
<p><img src="/images/DI%E3%80%81IOC%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="DI、IOC示意图"></p>
<p>IOC容器的优势：避免在各处使用new来创建类，并且可以做到统一维护</p>
<p><strong>Spring IOC示意图</strong></p>
<p><img src="/images/SpringIOC%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SpringIOC示意图"></p>
<h4 id="Spring-IOC容器的核心接口"><a href="#Spring-IOC容器的核心接口" class="headerlink" title="Spring IOC容器的核心接口"></a>Spring IOC容器的核心接口</h4><ol>
<li><p>BeanFactory</p>
</li>
<li><p>ApplicationContext</p>
</li>
</ol>
<p>其中BeanFactory是Spring框架的基础设施，面向Spring，而ApplicationContext面向使用Spring框架的开发者</p>
<p>BeanDefinition：主要用来描述Bean的定义</p>
<p>BeanDefinitionRegistry：提供向IOC容器注册BeanDefinition对象的方法</p>
<p><strong>BeanFactory</strong>：</p>
<ol>
<li>提供IOC的配置机制</li>
<li>包含Bean的各种定义，便于实例化Bean</li>
<li>建立Bean之间的依赖关系</li>
<li>Bean生命周期的控制</li>
</ol>
<h4 id="getBean方法的代码逻辑"><a href="#getBean方法的代码逻辑" class="headerlink" title="getBean方法的代码逻辑"></a>getBean方法的代码逻辑</h4><ol>
<li>转换beanName</li>
<li>从缓存中加载实例</li>
<li>实例化Bean</li>
<li>检测parentBeanFactory</li>
<li>初始化依赖的Bean</li>
<li>创建Bean</li>
</ol>
<h4 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h4><ul>
<li>singleton：Spring的默认作用域，容器里拥有唯一的Bean实例</li>
<li>prototype：针对每个getBean请求，容器都会创建一个Bean实例</li>
<li>request：为每个Http请求创建一个Bean实例</li>
<li>session：会为每个session创建一个Bean实例</li>
<li>globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Protlet有效</li>
</ul>
<h4 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h4><p><strong>创建</strong>：</p>
<p><img src="/images/Bean%E5%88%9B%E5%BB%BA.png" alt="Bean创建"></p>
<p><strong>销毁</strong>：</p>
<ul>
<li>若实现了DisposableBean接口，则会调用destroy方法</li>
<li>若配置了destroy-method属性，则会调用其配置的销毁方法</li>
</ul>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>关注点分离：不同的问题交给不同的部分去解决</p>
<ul>
<li><p>通用化功能代码的实现，对应的就是所谓的切面（Aspect）</p>
</li>
<li><p>业务功能代码和切面代码分开后，架构变得高内聚低耦合</p>
</li>
<li><p>确保功能的完整性：切面最终需要被合并到业务中（Weave）</p>
</li>
</ul>
<h4 id="AOP的三种织入方式"><a href="#AOP的三种织入方式" class="headerlink" title="AOP的三种织入方式"></a>AOP的三种织入方式</h4><ol>
<li>编译时织入：需要特殊的Java编译器，如AspectJ</li>
<li>类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkZ</li>
<li>运行时织入：Spring采用的方式，通过动态代理的方式，实现简单</li>
</ol>
<h4 id="主要名词"><a href="#主要名词" class="headerlink" title="主要名词"></a>主要名词</h4><p>Aspect：通用功能的代码实现</p>
<p>Target：被织入Aspect的对象</p>
<p>Join Point：可以作为切入点的机会，所有方法都可以作为切入点</p>
<p>Pointcut：Aspect实际被应用在的Join Point，支持正则</p>
<p>Advice：类里的方法以及这个方法如何织入到目标方法的方式</p>
<p>Weaving：Aop的实现过程</p>
<h4 id="Advice的种类"><a href="#Advice的种类" class="headerlink" title="Advice的种类"></a>Advice的种类</h4><ol>
<li>前置通知（Before）</li>
<li>后置通知（AfterReturning）</li>
<li>异常通知（AfterThrowing）</li>
<li>最终通知（After）</li>
<li>环绕通知（Around）</li>
</ol>
<h4 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h4><p>JDKProxy：通过Java的内部反射机制实现，核心是InvocationHandler接口和Proxy类</p>
<p>Cglib：借助ASM实现，以继承的方式动态生成目标类的代理</p>
<p><strong>代理模式</strong>：接口 + 真实实现类 + 代理类</p>
<p>Spring里的代理模式的实现</p>
<ol>
<li>真实实现类的逻辑包含在了getBean方法里</li>
<li>getBean方法返回的实际上是Proxy的实例</li>
<li>Proxy实例是Spring采用JDK Proxy或CGLIB动态生成的</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-只用位运算实现整数的加减乘除</title>
    <url>/2020/01/31/%E7%AE%97%E6%B3%95-%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个32位整数a和b，可正、可负、可0。不能使用算术运算符，分别实现a和b的加减乘除运算。如果a和b执行加减乘除的结果本来就会导致数据溢出，那么你可以不用负责。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>如果不考虑进位，<strong>a^b</strong>的值就是正确结果，因为0+0=0，0+1=1，1+0=1，1+1=(1)0。在只考虑进位的情况下，进位就是<strong>(a&amp;b) &lt;&lt; 1</strong>，因为只有都为1的情况下才会产生进位。</p>
<p>把完全不考虑进位的相加值和只考虑进位的相加的值再相加，就是最终结果。也就是一直重复这样的过程，直到进位产生的值完全消失，说明所有的过程都加完了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        sum = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>实现a-b只要实现a+(-b)即可，根据二进制数在机器中表达的规则，得到一个数的相反数，就是这个数的二进制数表达取反加一的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">negNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>axb的结果可以写成<br>$$<br>a<em>2^0</em>b_0 + a<em>2^1</em>b_1 + … + a<em>2^i</em>b_i + … + a<em>2^{31}</em>b_{31}<br>$$<br>也就是分配律</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            res = add(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;	<span class="comment">// 对应a*2^i</span></span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">1</span>;	<span class="comment">// 对应b_i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>我们找到b最多右移x位还小于a，则res低位第x位为1，然后我们更新a=a-b*2^x，一直重复直到a小于b。</p>
<p>以上过程只适用于a和b都不是负数的时候，所以a和b中的负数要转换为正数之后再操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNeg</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = isNeg(a) ? negNum(a) : a;</span><br><span class="line">    <span class="keyword">int</span> y = isNeg(b) ? negNum(b) : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从最低位开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt; -<span class="number">1</span>; i = minus(i, <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &gt;= y)&#123;</span><br><span class="line">            res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            x = minus(x, y &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同号为正，异号为负</span></span><br><span class="line">    <span class="keyword">return</span> isNeg(a) ^ isNeg(b) ? negNum(res) : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们直到32位整型的最小值为-2147483648，而最大值为2147483647，因此如果a或b为最小值，是转不成对应的正数的。</p>
<ul>
<li><p>如果a和b都不是最小值，则直接使用div函数即可</p>
</li>
<li><p>如果a和b都为最小值，则返回1</p>
</li>
<li><p>如果a不为最小值，而b为最小值，a/b为0，直接返回0</p>
</li>
<li><p>如果a为最小值，而b不为最小值，就比较复杂</p>
<ol>
<li><p>计算(a+1)/b的值，记为c</p>
</li>
<li><p>计算a-c*b的值，记为remain</p>
</li>
<li><p>计算remain/b，记为rest</p>
</li>
<li><p>返回c+rest</p>
<p>也就是分两部分计算之后相加</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"divisor is 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b == Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = div(add(a,<span class="number">1</span>),b);</span><br><span class="line">        <span class="keyword">int</span> remain = minus(a,multi(c,b));</span><br><span class="line">        <span class="keyword">int</span> rest = div(remain,b);</span><br><span class="line">        <span class="keyword">return</span> add(c,rest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> div(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-不用做任何比较判断找出两个数中较大的数</title>
    <url>/2020/01/31/%E7%AE%97%E6%B3%95-%E4%B8%8D%E7%94%A8%E5%81%9A%E4%BB%BB%E4%BD%95%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E8%BE%83%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个32位整数a和b，返回a和b中较大的。要求不做任何比较判断。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>第一种方法，得到a-b的值就知道返回a还是返回b.</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n^<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flip((n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a - b;</span><br><span class="line">    <span class="keyword">int</span> scA = sign(c);</span><br><span class="line">    <span class="keyword">int</span> scB = flip(scA);</span><br><span class="line">    <span class="keyword">return</span> a * scA + b * scB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sign()函数的功能是返回整数n的符号，正数和0最高位是0，0&amp;1=0，0^1=1，而负数最高位为1，1&amp;1=1，1^1=0，而scB通过与1异或来取反。</p>
<p>如果a-b&lt;0，则scA为0，scB=1，返回的就是b。</p>
<p>但是这样的解法存在a-b溢出就无法解决的问题。</p>
<p>具体解决方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a - b;</span><br><span class="line">    <span class="keyword">int</span> sa = sign(a);</span><br><span class="line">    <span class="keyword">int</span> sb = sign(b);</span><br><span class="line">    <span class="keyword">int</span> sc = sign(c);</span><br><span class="line">    <span class="keyword">int</span> difSab = sa ^ sb;</span><br><span class="line">    <span class="keyword">int</span> sameSab = flip(difSab);</span><br><span class="line">    <span class="keyword">int</span> returnA = difSab * sa + sameSab * sc;</span><br><span class="line">    <span class="keyword">int</span> reutrnB = flip(reutrnA);</span><br><span class="line">    <span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中difSab表示a和b的符号是否相同，1表示不同，0表示相同。</p>
<p>当a的符号与b的符号不同（difSab == 1, sameSab == 0）时，则有</p>
<ol>
<li>如果a为0或者正数，b为负数(sa == 1, sb == 0)，应该返回a</li>
<li>如果a为负数，b为0或者正数（sa == 0, sb == 1), 应该返回b</li>
</ol>
<p>如果a的符号和b的符号相同（difSab == 0,sameSab == 1）时，一定不会溢出，则有</p>
<ol>
<li>如果a-b为0或者正(sc == 1)，返回a</li>
<li>如果a-b为负（sc == 0），返回b</li>
</ol>
<p>综上可以归纳出应该返回<br>$$<br>a*(difSab * sa + sameSab * sc) + b * flip(difSab * sa + sameSab * sc)<br>$$</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-不用额外变量交换两个整数的值</title>
    <url>/2020/01/31/%E7%AE%97%E6%B3%95-%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如何不用任何额外变量交换两个整数的值</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>我们需要利用异或的性质，分别是</p>
<ul>
<li>a ^ a = 0</li>
<li>a ^ 0 = a</li>
</ul>
<p>因此对于交换操作 b = a, 我们可以从b = a ^ 0 得到，而 0 = b ^ b，所以b = a 等价于 b = a ^ b ^ b，同理a = b ^ a ^ a，我们提取c = a ^ b，那么b = c ^ b, a = c ^ a,而c我们可以先用a存储</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a = a ^ b;	<span class="comment">// c = a ^ b</span></span><br><span class="line">    b = a ^ b;	<span class="comment">// b = c ^ b</span></span><br><span class="line">    a = a ^ b;	<span class="comment">// a = c ^ a,此时a原先的值存储在b中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的IO机制</title>
    <url>/2020/01/31/Java%E7%9A%84IO%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="Java的IO机制"><a href="#Java的IO机制" class="headerlink" title="Java的IO机制"></a>Java的IO机制</h2><a id="more"></a>

<h3 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h3><p>Block-IO：InputStream和OutputStream（字节流），Reader和Writer（字符流）</p>
<p><img src="/images/BIO%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="BIO示意图"></p>
<p>NonBlock-IO：构建多路复用的、同步非阻塞的IO操作</p>
<p><img src="/images/NIO%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="NIO示意图"></p>
<p>NIO核心：Channels、Buffers、Selectors</p>
<p><img src="/images/Selector.png" alt="Selector"></p>
<p>IO多路复用：调用系统级别的select\poll\epoll</p>
<p><img src="/images/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="IO多路复用"></p>
<p>Asynchronous IO：基于事件和回调机制</p>
<p><img src="/images/AIO%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="AIO示意图"></p>
<p>AIO可以基于回调：实现CompletionHandler接口，调用时触发回调函数；或者返回Future，通过isDone()查看是否准备好，通过get()等待返回数据</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOPlainEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">// 将ServerSocket绑定到指定的端口里</span></span><br><span class="line">        <span class="keyword">final</span> ServerSocket socket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// 创建一个线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 阻塞直到收到新的客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket clientSocket = socket.accept();</span><br><span class="line">            System.out.println(<span class="string">"收到来自"</span> + clientSocket + <span class="string">"的连接"</span>);</span><br><span class="line">            <span class="comment">// 将请求提交给线程池去执行</span></span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream())))&#123;</span><br><span class="line">                    PrintWriter writer = <span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                        writer.println(br.readLine());</span><br><span class="line">                        writer.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOPlainEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"监听端口："</span> + port);</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket ss = serverSocketChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        <span class="comment">// 将ServerSocket绑定到指定的端口里</span></span><br><span class="line">        ss.bind(address);</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 将Channel注册到Selector里，并说明让Selector关注的点，这里是关注建立连接这个事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞等待就绪的Channel，即没有与客户端建立连接前就一直轮询</span></span><br><span class="line">                selector.select();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取到Selector里所有就绪的SelectedKey实例，每将一个channel绑定到一个selector就会产生一个SelectedKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = (SelectionKey) iterator.next();</span><br><span class="line">                <span class="comment">// 将就绪的SelectedKey从Selector中移除，因为马上就要处理它，防止重复执行</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 若SelectedKey处于Acceptable状态</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 接收客户端的连接</span></span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        System.out.println(<span class="string">"接收到客户端："</span> + client);</span><br><span class="line">                        client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// 像selector注册socketchannel；主要关注读写，并传入一个ByteBuffer实例供读写缓存</span></span><br><span class="line">                        client.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">100</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 若SelectedKey处于可读状态</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="comment">// 从channel里读取数据存入ByteBuffer里</span></span><br><span class="line">                        client.read(output);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 若SelectedKey处于可写状态</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</span><br><span class="line">                        output.flip();</span><br><span class="line">                        <span class="comment">// 将ByteBuffer里的数据写入到channel里</span></span><br><span class="line">                        client.write(output);</span><br><span class="line">                        output.compact();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.Buffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOPlainEchoServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"监听端口"</span> + port);</span><br><span class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        <span class="comment">// 将serverSocket绑定到指定的端口里</span></span><br><span class="line">        serverSocketChannel.bind(address);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 开始接收新的客户端请求，一旦一个客户端请求被接收，CompletionHandler就会被调用</span></span><br><span class="line">        serverSocketChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel channel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 一旦完成处理，再次接收新的客户端请求</span></span><br><span class="line">                serverSocketChannel.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">// 在channel里植入一个读操作EchoCompletionHandler，一旦buffer有数据写入，EchoCompletionHandler被唤醒</span></span><br><span class="line">                channel.read(buffer, buffer, <span class="keyword">new</span> EchoCompletionHandler(channel));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 若遇到异常，关闭channel</span></span><br><span class="line">                    serverSocketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoCompletionHandler</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel channel;</span><br><span class="line"></span><br><span class="line">        EchoCompletionHandler(AsynchronousSocketChannel channel)&#123;</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 在channel里植入一个读操作的CompletionHandler,一旦channel有数据写入，CompletionHandler就会被唤醒</span></span><br><span class="line">            channel.write(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果buffer里还有内容，则再次触发写入操作将buffer里的内容写入channel</span></span><br><span class="line">                        channel.write(buffer, buffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        buffer.compact();</span><br><span class="line">                        <span class="comment">// 如果channel还有内容要读入buffer里，则再次触发写入操作</span></span><br><span class="line">                        channel.read(buffer, buffer, EchoCompletionHandler.<span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th>属性/模型</th>
<th>阻塞BIO</th>
<th>非阻塞NIO</th>
<th>异步AIO</th>
</tr>
</thead>
<tbody><tr>
<td>blocking</td>
<td>阻塞并同步</td>
<td>非阻塞但同步</td>
<td>非阻塞并异步</td>
</tr>
<tr>
<td>线程数(server:client)</td>
<td>1：1</td>
<td>1：N</td>
<td>0：N</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单</td>
<td>较复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>J.U.C包的梳理</title>
    <url>/2020/01/31/J-U-C%E5%8C%85%E7%9A%84%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h2 id="J-U-C知识点梳理"><a href="#J-U-C知识点梳理" class="headerlink" title="J.U.C知识点梳理"></a>J.U.C知识点梳理</h2><p>CAS是java.util.concurrent.atomic包的基础</p>
<p>AQS是java.util.concurrent.locks包以及一些常用类比如Semophore,ReentrantLock等类的基础</p>
<a id="more"></a>

<h3 id="J-U-C包的分类"><a href="#J-U-C包的分类" class="headerlink" title="J.U.C包的分类"></a>J.U.C包的分类</h3><ul>
<li>线程执行器executor</li>
<li>锁locks</li>
<li>原子变量类atomic</li>
<li>并发工具类tools</li>
<li>并发集合collections</li>
</ul>
<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><p><strong>闭锁CountDownLatch</strong>：让主线程等待一组事件发生后继续执行，事件是指CountDownLatch里的countDown()方法</p>
<p><strong>栅栏CyclicBarrier</strong>：阻塞当前线程，等待其他线程。所有线程必须同时到达栅栏位置后，才能继续执行；所有线程到达栅栏后，可以触发执行另外一个预先设置的线程</p>
<p><strong>信号量Semaphore</strong>：控制某个资源可被同时访问的线程个数</p>
<p><strong>交换器Exchanger</strong>：两个线程到达同步点后，相互交换数据</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><strong>BlockingQueue</strong>：提供可阻塞的入队和出队操作</p>
<p>主要用于生产者-消费者模式，在多线程场景时生产者在队列尾部添加元素，而消费者线程在队列头部消费元素，通过这种方式能够达到将任务的生存和消费进行隔离的目的。</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界/无界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/2020/01/31/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><a id="more"></a>

<p><img src="/images/Collection%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="Collection思维导图"></p>
<p>自然排序重写compareTo、equals和hashcode方法</p>
<p>客户化排序，实现Comparator接口，然后作为参数传入集合中</p>
<p>优先判断客户化排序。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>HashMap</strong>：（Java8 以前）：数组+链表</p>
<p><img src="/images/HashMap8%E4%BB%A5%E5%89%8D.png" alt="HashMap8以前"></p>
<p>（Java8 及以后）：数组+链表+红黑树</p>
<p><img src="/images/HashMap8%E5%8F%8A%E4%BB%A5%E5%90%8E.png" alt="HashMap8及以后"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表变为红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树转为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 延时创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>put</strong>方法的逻辑：</p>
<ol>
<li>如果HashMap未被初始化过，则初始化</li>
<li>对Key求Hash值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值，就把链表转成红黑树</li>
<li>如果链表的长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量*负载因子0.75），就需要resize（扩容2倍后重排）</li>
</ol>
<p><strong>如何有效减少碰撞</strong>：</p>
<ul>
<li>扰动函数：促使元素位置分布均匀，减少碰撞几率</li>
<li>使用final对象（String、Integer），并采用合适的equals()和hashCode()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/hashmap%E7%9A%84hash%E6%96%B9%E6%B3%95.png" alt="hashmap的hash方法"></p>
<p>当桶的长度为2^n时，计算桶的下标不用再用取模运算，而可以直接用更高效的&amp;运行</p>
<p><strong>HashMap的扩容问题</strong>：</p>
<ol>
<li><p>多线程环境下，调整大小会存在条件竞争，容易造成死锁</p>
</li>
<li><p>rehashing是一个比较耗时的过程</p>
</li>
</ol>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>使用synchronized修饰方法，是线程安全的，但由于会导致串行，所以效率很低</p>
<p>如何优化？</p>
<p>通过锁细粒度化，将整锁拆解成多个锁进行优化</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>早期：通过分段锁Segment来实现。数组+链表</p>
<p>当前：CAS+synchronized使锁更细化。数组+链表+红黑树</p>
<p><strong>put</strong>方法的逻辑</p>
<ol>
<li><p>判断Node[]数组是否初始化，没有则进行初始化操作</p>
</li>
<li><p>通过hash定位数组的索引坐标，是否有Node节点，没有则使用CAS进行添加（链表的头节点），添加失败则进入下次循环。</p>
</li>
<li><p>检查到内部正在进行扩容，就帮助它一块扩容。</p>
</li>
<li><p>如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）</p>
<ol>
<li>如果是Node（链表结构）则执行链表的添加操作</li>
<li>如果是TreeNode（树型结构）则执行树添加操作</li>
</ol>
</li>
<li><p>判断链表长度是否已经达到临界值8，如果超过就转成红黑树</p>
</li>
</ol>
<p>总结：使用无锁操作CAS插入头节点，失败则循环重试；若头节点已存在，则尝试获取头节点的同步锁，再进行操作</p>
<h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><ol>
<li>HashMap线程不安全，数组+链表+红黑树</li>
<li>Hashtable线程安全，锁住整个对象，数组+链表</li>
<li>ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</li>
<li>HashMap的key、value均可为null，而其他的两个类不支持</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常认识</title>
    <url>/2020/01/31/Java%E5%BC%82%E5%B8%B8%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h3><a id="more"></a>

<p><strong>Error和Exception的区别</strong>：</p>
<ul>
<li>Error：程序无法处理的系统错误，编译器不做检查</li>
<li>Exception：程序可以处理的异常，捕获后可能恢复<ol>
<li>RuntimeException：不可预知的，程序应当自行避免</li>
<li>非RuntimeException：可预知的，从编译器校验的异常</li>
</ol>
</li>
</ul>
<p>从责任角度看：</p>
<ul>
<li>Error属于JVM需要负担的责任</li>
<li>RuntimeException是程序应该负担的责任</li>
<li>Checked Exception可检查异常是Java编译器应该负担的责任(try…catch…finally…/throws…)</li>
</ul>
<h3 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h3><p><strong>RuntimeException</strong>:</p>
<ol>
<li>NullPointerException - 空指针引用异常</li>
<li>ClassCastException - 类型强制转换异常</li>
<li>IllegalArgumentException - 传递非法参数异常</li>
<li>IndexOutOfBoundsException - 下标越界异常</li>
<li>NumberFormatException - 数字格式异常</li>
</ol>
<p><strong>非RuntimeException</strong>:</p>
<ol>
<li>ClassNotFoundException - 找不到指定class的异常</li>
<li>IOException - IO操作异常</li>
</ol>
<p><strong>Error</strong>：</p>
<ol>
<li>NoClassDefFoundError - 找不到class定义的异常</li>
<li>StackOverflowError - 深递归导致栈被耗尽而抛出的异常</li>
<li>OutOfMemoryError - 内存溢出异常</li>
</ol>
<h3 id="Java的异常处理机制"><a href="#Java的异常处理机制" class="headerlink" title="Java的异常处理机制"></a>Java的异常处理机制</h3><p>抛出异常：创建异常对象，交由运行时系统处理</p>
<p>捕获异常：寻找合适的异常处理器处理异常，否则终止运行（finally会在try的return语句之前执行）</p>
<h3 id="Java异常的处理原则"><a href="#Java异常的处理原则" class="headerlink" title="Java异常的处理原则"></a>Java异常的处理原则</h3><ul>
<li>具体明确：抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因；</li>
<li>提早抛出：应尽可能早的发现并抛出异常，便于精确定位位置；</li>
<li>延迟捕获：异常的捕获和处理应该尽可能延迟，让掌握更多信息的作用域来处理异常。</li>
</ul>
<h3 id="Java异常处理消耗性能"><a href="#Java异常处理消耗性能" class="headerlink" title="Java异常处理消耗性能"></a>Java异常处理消耗性能</h3><ol>
<li>try-catch块影响JVM的优化</li>
<li>异常对象实例需要保存栈快照等信息，开销较大</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-将整数字符串转成整数值</title>
    <url>/2020/01/30/%E7%AE%97%E6%B3%95-%E5%B0%86%E6%95%B4%E6%95%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90%E6%95%B4%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串str，如果str符合日常书写的整数形式，并且属于32位整数的范围，返回str所代表的整数值，否则返回0.</p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>str = “123”，返回123</p>
<p>str = “023”，不符合日常的书写习惯，返回0</p>
<p>str = “A13”，返回0</p>
<p>str = ”2147483647“，返回2147483647</p>
<p>str = “2147483648”，溢出了，返回0</p>
<p>str = “-123”，返回-123</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>首先<strong>检查</strong>是否符合日常书写的整数形式：</p>
<ol>
<li>如果str不以”-“开头，也不以数字字符开头，返回false</li>
<li>如果str以”-“开头，但是str的长度为1，即str==” - “，返回false，如果str的长度大于1，但是” - “之后紧跟0，返回false</li>
<li>如果str以”0“开头，但是str的长度大于1，返回false</li>
<li>此时检查str[1~N-1]是否都是数字，如果有一个不为数字则返回false</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[] chas)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chas[<span class="number">0</span>] != <span class="string">'-'</span> &amp;&amp; (chas[<span class="number">0</span>] &lt; <span class="string">'0'</span> || chas[<span class="number">0</span>] &gt; <span class="string">'9'</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chas[<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; (chas.length == <span class="number">1</span> || chas[<span class="number">1</span>] == <span class="string">'0'</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chas[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; chas.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chas.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chas[i] &lt; <span class="string">'0'</span> || chas[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进行<strong>转换</strong>过程：</p>
<ol>
<li>生成4个变量。布尔型常量posi，表示转换的结果是负数还是非负数；整型常量minq，等于Integer.MIN_VALUE/10；整型常量minr，等于Integer.MIN_VALUE%10；整型变量res，用于保存转换结果，初始化为0.</li>
<li>32位整数的最小值为-2147483648，最大值为2147483647。可以看出最小值的绝对值比最大值的绝对值大1，所以转换过程中的绝对值一律以负数的形式出现。</li>
<li>如果str以” - “开头，从str[1]开始遍历，否则从str[0]开始遍历。假设当前字符为a，那么’0‘-a就是当前字符所代表的负数形式，记为cur，如果在res加上cur之前，发现res已经小于minq，那么res*10+cur一定会溢出；如果res等于minq，但是cur小于minr，那么也一定会溢出。出现任何一种溢出情况，直接返回0.</li>
<li>遍历后得到的res根据posi符号决定返回值。如果res为32位整数的最小值，而posi为true，说明溢出，则返回0。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convert</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chas = str.toCharArray();</span><br><span class="line">    <span class="keyword">if</span>(!isValid(chas))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> posi = chas[<span class="number">0</span>] == <span class="string">'-'</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> minq = Integer.MIN_VALUE / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> minr = Integer.MIN_VALUE % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = posi ? <span class="number">0</span> : <span class="number">1</span>; i &lt; chas.length; i++)&#123;</span><br><span class="line">        cur = <span class="string">'0'</span> - chas[i];</span><br><span class="line">        <span class="keyword">if</span>((res &lt; minq) || (res == minq &amp;&amp; cur &lt; minr))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res == Integer.MIN_VALUE &amp;&amp; posi)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> posi ? -res : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-Java多线程程序的性能调优</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h1 id="Java虚拟机对内部锁的优化"><a href="#Java虚拟机对内部锁的优化" class="headerlink" title="Java虚拟机对内部锁的优化"></a>Java虚拟机对内部锁的优化</h1><a id="more"></a>

<p><strong>锁消除</strong><br><img src="https://img-blog.csdnimg.cn/20200116134334647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="锁消除"><br>锁消除优化能否被实施还取决于被调用的同步方法（或者带同步块的方法）是否能够被内联。<br>在锁消除的作用下，利用ThreadLocal将一个线程安全的对象（比如Random）作为一个线程特有对象来使用，不仅可以避免锁的争用，还可以彻底消除这些对象内部所使用的锁的开销。<br><strong>锁粗化</strong><br><img src="https://img-blog.csdnimg.cn/20200116134937690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="锁粗化"><br>锁粗化可能导致一个线程持续持有一个锁的时间变长，从而使得同步在该锁之上的其他线程在申请锁时的等待时间变长。</p>
<p><strong>偏向锁</strong><br>Java虚拟机会为每个对象维护一个偏好（Bias），即一个对象对应的内部锁第1次被一个线程获得，那么这个线程就会被记录为该对象的偏好线程。这个线程后续无论是再次申请该锁还是释放该锁，都无须借助原先昂贵的原子操作，从而减少了锁的申请与释放的开销。<br>当一个对象的偏好线程以外的其他线程申请该对象的内部锁时，Java虚拟机需要收回该对象对原偏好线程的“偏好”并重新设置该对象的偏好线程。</p>
<p><strong>适应性锁</strong><br>存在锁争用时我们可以将线程暂停（这种策略适合系统中绝大多数线程对该锁的持有时间较长的场景），或者采用忙等（这种策略比较适合绝大多数线程对该锁的持有时间较短的场景）<br>适应性锁就是能综合使用两种策略。这种优化也需要JIT编译器介入</p>
<h1 id="优化对锁的使用"><a href="#优化对锁的使用" class="headerlink" title="优化对锁的使用"></a>优化对锁的使用</h1><p><strong>锁的开销与锁争用监视</strong><br>上下文切换与线程调度的开销；内存同步、编译器优化受限的开销；限制可伸缩性。<br>减小锁的开销的一个基本思路就是消除锁的使用（使用锁的替代品）或者降低锁的争用程度。<br>影响锁的争用程度的因素有两个：程序申请锁的频率已经锁通常被持有的时间跨度。<br><strong>使用可参数化锁</strong><br>如果一个方法或者类内部锁使用的锁实例可以由该方法、类的客户端代码指定，那么我们称这个锁是可参数化的。<br><strong>减小临界区的长度</strong><br>减小临界区的长度可以减少锁被持有的时间从而降低锁被争用的概率，这有利于减少锁的开销。另外，减少锁的持有时间有利于Java虚拟机的适用性锁优化发挥作用。<br>临界区操作一般可以分为预处理操作、共享变量访问操作以及后处理操作。其中预处理操作和后处理操作往往是不涉及共享变量的访问的，因此把这两种操作挪到临界区之外可以在不导致线程安全问题的前提下减小临界区的长度。<br><strong>减小锁的粒度</strong><br><img src="https://img-blog.csdnimg.cn/20200116142254453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="通过拆分锁减小锁的粒度示意图"><br>锁分段是指对同一个数据结构内不同部分的数据使用不同锁实例进行加锁的技术。<br>ConcurrentHashMap执行put操作时的不同线程只要其提供的key值不一样，那么它们所需要使用的锁实例也可能是不一样的。</p>
<h1 id="减少系统内耗：上下文切换"><a href="#减少系统内耗：上下文切换" class="headerlink" title="减少系统内耗：上下文切换"></a>减少系统内耗：上下文切换</h1><p><strong>控制线程数量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplicitControlThreadCount</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">final</span> String data)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    process(data);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executorService.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>避免在临界区中执行阻塞式I/O(Blocking I/O)等阻塞操作。</strong>临界区中的阻塞操作会增加引导这个临界区的锁被争用的可能性。而被争用的锁又可能导致上下文切换，因此在临界区中执行阻塞操作会进一步增加上下文切换。<br><strong>避免在临界区中执行比较耗时的操作</strong><br><strong>减少Java虚拟机的垃圾回收</strong><br>由于移动存活对象意味着这些对象所在的内存地址发生变化，因此在移动存活对象前垃圾回收器需要将所有应用线程暂停，并在移动结束后再将所有应用线程活动唤醒。</p>
<h1 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h1><p>由于一个缓存行中可以存储多个变量的副本，因此即便是在两个线程各自仅访问各自的共享变量（它们之间不存在共同的共享变量）的情况下，一个线程更新其共享变量也可能导致另外一个线程访问其共享变量时产生缓存未命中，这种现象就被称为伪共享。<br><strong>Java对象内存布局</strong><br>Java对象在内存中的存储包括对象头（Object Header）和实例字段。其中，对象头会使用2个字（Word）的存储空间：第一个字用于存储对象的HashCode、锁的相关信息（比如偏向锁的偏向线程的ID）等信息；第二个字用于存储对象所属的类的指针。<br>规则1：对象是以8字节为粒度（Granularity）进行对齐（Aligned）的。<br>规则2：对象中的实例字段按照如下顺序而非其源代码声明顺序排列。</p>
<ul>
<li>long型变量和double型变量</li>
<li>int型变量和float型变量</li>
<li>short型变量和char型变量</li>
<li>boolean型变量和byte型变量</li>
<li>引用型变量<br>规则3： 继承自父类的实例字段不会与类本身定义的实例字段混杂在一起进行存储。</li>
<li><em>伪共享的侦测与消除*</em><br>消除伪共享的一个方法就是填充。填充就是通过在类中添加一些“无用的”实例变量来“干扰”对象的内存布局，以使特定的实例变量（或者某个实例）能够独自占用一个缓存行的空间，从而避免这些实例变量（或者实例）与其他实例变量（或者实例）被加载到同一个缓存行之中。<br>但是对缓存行宽度的依赖使得填充这种技术存在硬件层面的可移植性问题，对Java对象内存布局的依赖同样也使得填充这种技术存在软件层面的可移植性问题。<br>JDK1.8在@sun.misc.Contended注释的字段（或者类的实例）的前和后各自填充大小为缓存行宽度的2倍的填充空间。Java虚拟机则根据这个注解进行填充来使得被注解的实例变量或者类的实例能够被加载到单独的一个缓存行之中。<br>减少共享变量的访问频率有助于降低伪共享问题出现的频率。<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1></li>
</ul>
<ol>
<li>Java虚拟机自Java 6开始对内部锁进行了若干优化：锁消除、锁粗化、偏向锁以及适应性锁。除锁消除是Java 7开始引入的，其他优化均是在Java 6开始引入的，这些优化仅在Java虚拟机的server模式下起作用。这些优化默认都是开启的，且多数优化都可能依赖于JIT的内联优化，并且其本身也可能是通过JIT编译实现的。因此，这些优化都有其开销。锁消除优化能够彻底消除锁的开销，它依赖于逃逸分析技术。锁粗化优化能够减少线程申请/释放锁的频率，其代价是使临界区长度变大，从而可能导致进程在申请锁时的等待时间变长。偏向锁优化可以减小锁的申请/释放开销，它不适用于争用程度较高的锁。适应性锁优化可以减小锁申请的开销，有利于减少上下文切换。</li>
<li>锁的开销主要是由争用锁引起的。这些开销主要包括：上下文切换与线程调度开销、内存同步、编译器优化受限的开销以及限制可伸缩性。降低锁的开销可以从使用锁的替代品、降低锁的争用程度以及减少线程所需申请的锁的数量这几个方面入手。</li>
<li>使用可参数化锁可以减少线程所需申请的锁的数量从而降低锁的开销，但是它在一定程度上破坏了封装性。</li>
<li>减小临界区的长度可以减少锁的持有时间，从而降低锁的争用程度。减小临界区的长度有利于适用性锁优化发挥作用。在不影响线程安全的前提下，将临界区中的阻塞式I/O等阻塞操作以及较耗时的操作挪到临界区之外可以减小临界区的长度。</li>
<li>减小锁的粒度可以降低锁的申请频率从而降低锁的争用程度。减小锁的粒度常用技术包括锁拆分技术和锁分段技术。锁拆分技术在高争用情况下的效果可能并不明显；锁分段技术会使得对整个对象进行加锁比较困难乃至不可能。</li>
<li>减小上下文切换可以从这几个方面入手：控制线程数量、避免在临界区中执行阻塞式I/O等阻塞操作、避免在临界区中执行比较耗时的操作和减少Java虚拟机垃圾回收。</li>
<li>运用多线程设计模式也有助于提升多线程程序的性能，但是程序的复杂性也可能相应增加。</li>
<li>伪共享产生的前提是多个线程访问被缓存到同一个缓存行中的不同变量，它会导致大量的缓存未命中，从而增加内存访问操作的开销。了解Java对象的内存布局有助于分析与消除伪共享。Java对象内存布局的规则包括：对象是以8字节为粒度进行的对齐的、对象中的实例字段并非按照其源代码声明顺序排列以及继承自父类的实例字段不会与类本身定义的字段混杂在一起进行存储等。使用jol工具可以查看具体对象的内存布局情况。判断伪共享是否存在可以从分析多个线程是否存在共同的共享变量入手，并通过jol以及Linux内核工具perf来进一步分析与确认。伪共享可通过手工填充、自动填充以及降低共享变量的访问频率这几个方面来消除与规避。手工填充与自动填充可以在无须调整程序算法的前提下消除伪共享。手工填充的缺点比较多，使用该方法我们必须直到缓存行的宽度、Java对象的具体内存布局，这使得该方法存在硬件、软件层面的可移植性问题，并对人员的要求比较高。并且，我们还需要避免手工填充的字段被Java虚拟机优化掉。自动填充依赖于@Contened注解，它避免了手动填充的缺点，但是其消耗的额外空间更多。Java虚拟机对自动填充的之间需要通过Java虚拟机的开关“-XX:-RestrictContented”开启。虽然减少共享变量的访问频率所带来的效果可能比较明显，但是由于它可能涉及程序算法的调整，因此其适用范围比较有限。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-多线程编程的硬件基础与Java内存模型</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80%E4%B8%8EJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>高速缓存内部结构示意图</strong></p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200109173355948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="高速缓存内部结构示意图"><br><strong>缓存条目的结构</strong><br><img src="https://img-blog.csdnimg.cn/20200109173543492.png" alt="缓存条目的结构"><br>Data Block也被称为缓存行，它是高速缓存与主内存之间的数据交换最小单元，用于存储从主内存中读取或准备写往内存的数据。Tag则包含了与缓存行中数据相应的内存地址的部分信息（内存地址的高位部分比特）。Flag则用于表示响应缓存行的状态信息。<br>内存地址的解码结果包括tag、index以及offset三部分，index相当于桶号，tag相当于缓存条目的相对编号，offset是缓存行内的位置偏移。<br>MESI协议中一个缓存条目的Flag值有以下四种可能：Invalid（无效的，记为I）、shared（共享的，记为S），Exclusive（独占的，记为E）和Modified（更改过的，记为M）。</p>
<p><strong>Processor 0读取数据S的实现</strong><br><img src="https://img-blog.csdnimg.cn/2020010919245297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="Processor 0读取数据的实现"><br><strong>Processor 0写数据S的实现</strong><br><img src="https://img-blog.csdnimg.cn/20200109194138122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="Processor 0写数据的实现"><br><strong>写缓冲器</strong><br>写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。一个处理器无法读取另外一个处理器的写缓冲器中的内容。<br>内存写操作的执行处理器在将写操作的相关数据写入写缓冲器之后便认为该写操作已经完成，一个处理器接收到其他处理器所回复的针对同一个缓存条目的所有Invalidate Acknowledge消息的时候，该处理器会将写缓冲器中针对相应地址的写操作的结果写入相应的缓冲行中。<br><strong>无效化队列</strong><br>引入无效化队列后，处理器在接收到Invalidate消息之后并不会删除消息中指定地址对应的副本数据，而是将消息存入无效化队列之后就回复Invalidate Acknowledge消息，从而减少了写操作执行处理器所需的等待时间。<br><strong>存储转发</strong><br>处理器在执行读操作的时候会根据相应的内存地址查询写缓冲器。如果写缓冲器存在相应的条目，那么该条目所代表的写操作的结果数据就会直接作为该读操作的结果返回；否则处理器才从高速缓存中去读取数据。<br><strong>重排序</strong><br>写缓冲器可能导致StoreLoad重排序，如一个值的修改值在Processor 1写缓冲器中，那么其他处理器读到的还是Processor 1高速缓存器中的旧值<br>写缓冲器可能导致StoreStore重排序，同样也是因为新值在写缓冲器中，读取到的是旧值。<br>无效化队列可能导致LoadLoad重排序，原因是Invalidate消息还在无效化队列中，数据的值未被修改。<br><strong>可见性</strong><br>我们必须将写缓冲器中的内容写入其所在的处理器的高速缓存之中，即冲刷缓冲器，这需要内存屏障中的存储屏障；同时我们还需要处理无效化队列，这需要加载屏障。<br>写线程的执行处理器所执行的存储屏障保障了该线程对共享变量所作的更新对读线程来说是同步的；读线程的执行处理器所执行的加载屏障将写线程对共享变量所作的更新同步到该处理器的高速缓存中。<br><strong>基本内存屏障</strong><br>基本内存屏障是对一类指令的称呼，这类指令的作用是禁止该指令左侧的任何X操作与该指令右侧的任何Y操作之间进行重排序。比如StoreLoad屏障能够禁止其左侧的任何写操作与其右侧的任何读操作之间进行重排序。<br>LoadLoad屏障是通过清空无效化队列来实现禁止LoadLoad重排序的。<br>StoreStore屏障可以通过对写缓冲器中的条目进行标记来实现禁止StoreStore重排序。<br>StoreLoad屏障会清空无效化队列，并将写缓冲器中的条目冲刷（写入）高速缓存。</p>
<h2 id="Java同步机制与内存屏障"><a href="#Java同步机制与内存屏障" class="headerlink" title="Java同步机制与内存屏障"></a><strong>Java同步机制与内存屏障</strong></h2><p>获取屏障相当于LoadLoad屏障和LoadStore屏障的组合，它能够禁止该屏障之前的任何读操作与该屏障之后的任何读、写操作之间进行重排序。释放屏障相当于LoadStore屏障和StoreStore屏障的组合，它能够禁止该屏障之前的任何读、写操作与该屏障之后的任何写操作之间之间重排序。<br><strong>volatile</strong><br>有序性<br>Java虚拟机（JIT编译器）在volatile变量写操作之前插入的释放屏障使得该屏障之前的任何读、写操作都先于这个volatile变量写操作被提交，而Java虚拟机（JIT编译器）在volatile变量读操作之后插入的获取屏障使得这个volatile变量读操作先于该屏障之后的任何读、写操作被提交。<br>可见性<br>Java虚拟机（JIT编译器）在volatile变量写操作之后插入一个StoreLoad屏障。该屏障可以充当存储屏障，StoreLoad屏障通过清空其执行处理器的写缓冲器使得该屏障前的所有写操作的结果得以达到高速缓存，从而使这些更新对其他处理器而言是可同步的；充当加载屏障，以消除存储转发的副作用。<br>Java虚拟机（JIT编译器）在volatile变量读操作前插入一个加载屏障相当于LoadLoad屏障，它通过清空无效化队列来使得其后的读操作有机会读取到其他处理器的共享变量所做的更新。<br>可见，volatile对可见性的保障是通过写线程、读线程配对使用存储屏障和加载屏障实现的。<br><strong>synchronized</strong><br>有序性<br>Java虚拟机（JIT编译器）在monitorenter（用于申请锁的字节码指令）对应的指令后临界区开始前的地方插入一个获取屏障。Java虚拟机会在临界区结束后monitorexit（用于释放锁的字节码指令）对应的指令前的地方插入一个释放屏障。<br>可见性<br>Java虚拟机会在monitorexit对应的指令（相当于写操作）之后插入一个StoreLoad屏障。该屏障充当了存储屏障，从而确保锁的持有线程在释放锁之前所执行的所有操作的结果能够到达高速缓存，并消除了存储转发的副作用。<br><strong>优化</strong><br>内存屏障部分禁止重排序的代价就是它会阻止编译器（JIT编译器）、处理器做一些性能优化。另外一种代价就是其实现往往涉及冲刷写缓冲器和清空无效化队列，而这两个动作可能是比较耗时的。<br>优化包括省略、合并等。<br><strong>final</strong><br>Java虚拟机会在子操作final字段初始化之后插入一个StoreStore屏障以禁止子操作final字段初始化以及该操作前的所有写操作和对象发布之间的重排序。<br>包含final字段的对象引用对外可见的时候该对象的非final字段仍然可能是未初始化完毕的。</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>对引用类型以及几乎所有基本数据类型的共享变量进行的读、写操作，Java内存模型都保证它们具有原子性，而对long/double型的共享变量进行的读、写操作是否具有原子性而取决于具体的Java虚拟机实现。<br><strong>happen(s)-before关系</strong><br>假设动作A和动作B之间存在happens-before关系，称之为A happens-before B，那么Java内存模型保证A的操作结果对B可见，即A的操作结果会在B被执行前<strong>提交</strong>。<br>程序顺序规则：一个线程中的每一个动作都happens-before该线程中程序顺序上排在该动作之后的每一个动作。<br>内部锁规则：内部锁的释放happens-before后续每一个对该锁的申请。尽管锁对排他性的保障仅限于临界区内的代码，但是锁对可见性和有序性的保障却可以扩展到临界区之前。<br>volatile变量规则：对一个volatile变量的写操作happens-before后续每一个针对该变量的读操作。<br>线程启动规则：调用一个线程的start方法happens-before被启动的这个线程中的任何一个动作。<br>线程终止规则：一个线程中的任何一个动作都happens-before该线程的join方法的执行线程在join方法返回之后所执行的任意一个动作。<br><strong>对象的安全发布</strong><br>对象安全发布的实质——不仅仅使一个对象的引用对其他线程可见，还要保障该对象的引用对其他线程可见前，发布线程对该对象所执行的操作对其他线程来说是可见且有序的。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>高速缓存是一个存取速率远比主内存大而容量远比主内存小的存储部件，其引入弥补了处理器与主内存处理能力之间的鸿沟。高速缓存相当于一个由硬件实现的散列表，其键为内存地址，其值为从内存读取或者准备写入内存的数据。高速缓存中的每一个桶可包含若干个缓存条目。缓存条目中的Tag部分包含了内存地址的高位部分比特；Flag部分指示了缓存条目的有效性；缓存行用于存储从内存读取或者准备写入内存的数据，其容量在16~256字节之间不等，一个缓存行可用于存储多个变量。缓存命中意味着待读取或者写入内存的数据在高速缓存中存在相应的副本，这可以提高内存访问效率。缓存未命中包括读未命中和写未命中，它不利于性能，但是由于高速缓存容量的限制又往往是不可避免的。Linux内核工具perf可用来查看缓存未命中情况。现代处理器多采用多级高速缓存，典型的高速缓存层级包括L1 Cache、L2 Cache和L3 Cache.</li>
<li>缓存一致性协议保障了多个处理器上高速缓存中的数据副本的数据一致性，避免了一个处理器读取到共享变量的旧值以及避免一个处理器对共享变量所作的更新丢失。MESI协议是一个广为使用的缓存一致性协议，该协议下的缓存条目Flag可能值包括：M/E/S/I。内存读/写操作是通过处理器发送与接收相关消息并更新缓存条目的Flag实现的。这些消息包括：Read/Read Response、Invalidate/Invalidate Acknowledge、Read Invalidate、Writeback。</li>
<li>写缓冲器与无效化队列的引入弥补了MESI协议的性能缺点。</li>
<li>写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储部件。其引入使得内存写操作的执行处理器无序等待其他处理器回复Invalidate Acknowledge/Read Response消息便可以执行其他指令，从而减小内存写操作的延迟。写缓冲器能导致写线程对共享变量所做的更新无法被其他处理器同步过去。存储转发技术使得一个处理器可以直接从写缓冲器中读取该处理器先前执行的写操作的结果，但是它也可能导致可见性问题。另外，写缓冲器还会导致StoreLoad重排序和StoreStore重排序。</li>
<li>无效化队列的引入使得处理器在接收到Invalidate消息之后可以立即回复Invalidate Acknowledge消息，这减少了发送Invalidate消息的处理器的等待时间。无效化队列可能使写线程对共享变量所做的共享无法反映到读线程执行处理器的高速缓存中，即导致可见性问题。无效化队列可以导致LoadLoad重排序。</li>
<li>从硬件的角度来看，可见性的保障是通过写线程和读线程配对使用存储屏障和加载屏障实现的。存储屏障能够冲刷写缓冲器使得写线程对共享变量所作的更新能够被其他处理器同步，加载屏障能够清空无效化队列，使得写线程对共享变量所做的更新能够反映在读线程执行处理器的高速缓存之中。</li>
<li>获取屏障相当于LoadLoad屏障和LoadStore屏障的组合，释放屏障相当于StoreStore屏障和StoreLoad屏障的组合（有序）。LoadLoad屏障相当于加载屏障；而StoreLoad屏障是“全能型”屏障，它既可以充当存储屏障，也可以充当加载屏障。（可见）</li>
<li>Java虚拟机（JIT编译器）为了确保final关键字的语义，会在final字段初始化与构造器返回之前插入一个StoreStore屏障，这使得final字段初始化操作无法被重排到构造器之外，从而确保了构造器返回之后相应对象的final字段总是初始化完毕的。有序性的保障是通过写线程与读线程配对执行释放屏障和获取屏障实现的，同样这些屏障也是Java虚拟机（JIT编译器）替我们的应用程序插入的。Java虚拟机（JIT编译器）会在volatile变量写操作之后插入一个StoreLoad屏障，该屏障不仅充当了存储屏障以冲刷写缓冲器，还充当了加载屏障以清空无效化队列从而清除了存储转发技术的副作用。Java虚拟机（JIT编译器）会在volatile变量读操作前插入一个LoadLoad屏障，该屏障充当了加载屏障，用于清空无效化队列。</li>
<li>Java内存模型从“什么”（What）的角度来回答线程安全有关问题，JSR 133对Java内存模型进行了增强和修复。Java内存模型规定，long/double型变量以外的任何变量的读/写操作具有原子性；volatile变量修饰的long/double型变量的读/写操作也具有原子性。long/double型普通变量的读/写操作的原子性取决于具体的Java虚拟机。happens-before从可见性的角度对有序性进行描述。happens-before关系具有传递性和积累效果。Java内存模型定义的happens-before规则包括：程序顺序规则、内部锁规则、volatile规则、线程启动规则和线程终止规则。Java标准库本身也定义了一些happens-before规则。从语言的层面来看，这些规则是通过使用Java的同步机制实现的；从底层的角度来看，这些规则是由Java虚拟机、编译器以及处理器一同协作来落实的，内存屏障则是Java虚拟机、编译器和处理器之间的“沟通”纽带。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>硬件基础</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-Java多线程程序的调试与测试</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<ol>
<li><p>在调试过程中使用监视点有助于跟踪线程对共享变量的访问情况。调试多线程程序过程中将断点的暂挂策略设置为暂挂虚拟机策略有助于模拟单线程的调试环境，以便于定位与多线程本身无关的功能性问题；将断点的暂挂策略设置为暂挂线程则有利于定位与多线程有关的非功能性问题。</p>
<a id="more"></a>
</li>
<li><p>多线程程序测试的复杂性表现为多线程程序Bug具有不确定性、多线程同时受功能性问题与线程安全问题的影响、缺乏成熟的多线程程序测试工具等方面。应对多线程程序测试的困难性可以从提高代码的可测试性、使用静态检查工具、代码复审和选用简单有效的多线程测试工具这几个方面着手。</p>
</li>
<li><p>提高代码的可测试性可以从抽象与实现分离、数据与数据来源分离、依赖注入、关注点分离和使工作者线程数可以配置等几个方面入手。</p>
</li>
<li><p>使用静态检查工具能够帮助我们自动找出一些常见的“低级错误”。（FindBugs）</p>
</li>
<li><p>代码复审是挖掘多线程程序Bug的最有效途径，但是它对人员的要求也最高。为了减少代码复审的人工成本以提高复审效率，代码复审效率，代码复审通常应该在静态检查通过之后进行。</p>
</li>
<li><p>选用多线程程序测试工具、框架时的一个重要考量是简单些——测试代码的开发者能够更加专注于测试用例本身的实现而不是与测试工具本身有关的细节以及API。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>调试与测试</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-Java异步编程</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-Java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Java异步编程</strong></p>
<a id="more"></a>


<table>
    <tr>
        <th>方法</th>
        <th>适用条件及注意事项</th>
        <th>原理</th>  
        <th>备注</th>
    </tr >
    <tr >
        <td>public static ExecutorService newCachedThreadPool()</td>
        <td rowspan="2">适合用于执行大量耗时较短且提交比较频繁的任务。如果提交的任务执行耗时较长，那么可能导致线程池中的工作者线程无限制地增长，最后导致过多的上下文切换，从而使得整个系统变慢</td>
        <td rowspan="2">该方法的返回值相当于：new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable>());即核心线程池大小为0，最大线程池大小不受限，工作者线程允许的最大空闲时间(keepAliveTime)为60秒，内部以SynchronousQueue为工作者队列的一个线程池</td>
        <td rowspan="2">由于是SynchronousQueue，因此必须有take(),才能执行offer()，否则会入队失败，因此在该线程池中的所有工作者线程都在执行任务，即无空闲工作者线程的情况下给其提交任务会导致该任务无法被缓存成功。而ThreadPoolExecutor在任务缓存失败且线程池当前大小未达到最大线程池大小的情况下会创建并启动新的工作者线程。因此，如果任务执行慢，就会有越来越多的线程被创建。</td>
    </tr>
    <tr>
        <td>public static ExecutorService newCachedThreadPool(ThreadFactory threadfactory)</td>
    </tr>
    <tr>
        <td>public static ExecutorService newFixedThreadPool(int nThreads)</td>
        <td rowspan="2">由于该方法返回的线程池的核心线程池大小等于其最大线程池大小，因此该线程池中的工作者线程永远不会超时。我们必须在不再需要该线程池时主动将其关闭</td>
        <td rowspan="2">该方法的返回值相当于:new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable>());这是一种线程池大小一旦达到其核心线程池大小就既不会增加也不会减少工作者线程的固定大小的线程池。</td>
        <td rowspan="2"></td>
    </tr>
    <tr>
        <td>public static ExecutorService newFixedThreadPool(int nThreads,ThreadFactory threadFactory)</td>
    </tr>
    <tr>
        <td>public static ExecutorService newSingleThreadExecutor()</td>
        <td rowspan="2">适合用于实现单（多）生产者——单消费者模式。该方法的返回值无法被转换为ThreadPoolExecutor类型</td>
         <td rowspan="2">该方法的返回值基本相当于Executors.newFixedThreadPool(1)所返回的线程池</td>
        <td rowspan="2">该线程池确保了在任意一个时刻只有一个任务会被执行，这就形成了类似锁将原本并发的操作改为串行的操作的结果。</td>
    </tr>
    <tr>
        <td>public static ExecutorService newSingleThreadExecutor(ThreadFacotry threadFactory)</td>
    </tr>
</table>

<ol>
<li>ExecutorCompletionService每执行完一个异步任务，就将该任务对应的Future实例存入其内部维护的BlockingQueue实例之中，而其客户端代码则可以通过ExecutorCompletionService.take()调用来获取这个Future实例。</li>
<li>ExecutorService.invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)也能够用来批量提交异步任务，该方法能够并发执行tasks参数所指定的一批任务，但是该方法只有在tasks参数所指定的一批任务中的所有任务都执行结束之后才返回，其返回值是一个包含各个任务对应的Future实例的列表（List）。</li>
<li>FutureTask是Runnable接口的一个实现类，因此FutureTask表示的异步任务可以提交给专门的工作者线程执行，也可以交给Executor实例（比如线程池）执行；FutureTask还能够直接返回其代表的异步任务的处理结果。FutureTask是java.util.concurrent.RunnableFuture接口的一个实现类。由于RunnableFuture接口继承了Future接口和Runnable接口，因此FutureTask既是Runnable接口的实现类也是Future接口的实现类。FutureTask还支持以回调（Callback）的方式处理任务的执行结果。当FutureTask实例所代表的任务执行结束后，FutureTask.done()会被执行。<br>基于FutureTask的XML异步解析器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLDocumentParser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParsingTask <span class="title">newTask</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParsingTask(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ParsingTask <span class="title">newTask</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newTask(url, <span class="number">30000</span>, <span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装对XML解析结果进行处理的回调结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandler</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Document document)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParsingTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> InputStream in;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Executor executor;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ResultHandler resultHandler;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParsingTask</span><span class="params">(InputStream in, Executor executor,ResultHandler resultHandler)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">            <span class="keyword">this</span>.executor = executor;</span><br><span class="line">            <span class="keyword">this</span>.resultHandler = resultHandler;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParsingTask</span><span class="params">(InputStream in)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(in, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Future&lt;Document&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            FutureTask&lt;Document&gt; ft;</span><br><span class="line">            <span class="keyword">final</span> Callable&lt;Document&gt; task = <span class="keyword">new</span> Callable&lt;Document&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Document <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> doParse(in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">final</span> Executor theExecutor = executor;</span><br><span class="line">            <span class="comment">// 解析模式：异步/同步</span></span><br><span class="line">            <span class="comment">// true表示theExecutor不为null，那么就是异步</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isAsyncParsing = (<span class="keyword">null</span> != theExecutor);</span><br><span class="line">            <span class="keyword">final</span> ResultHandler rh;</span><br><span class="line">            <span class="keyword">if</span> (isAsyncParsing &amp;&amp; <span class="keyword">null</span> != (rh = resultHandler))&#123;</span><br><span class="line">                <span class="comment">// 异步</span></span><br><span class="line">                <span class="comment">// 将Callable转成Runnable</span></span><br><span class="line">                ft = <span class="keyword">new</span> FutureTask&lt;Document&gt;(task)&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">// task执行完成之后会执行done</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 回调ResultHandler的相关方法对XML解析结果进行处理</span></span><br><span class="line">                        callbackResultHandler(<span class="keyword">this</span>, rh);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ft = <span class="keyword">new</span> FutureTask&lt;Document&gt;(task);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isAsyncParsing)&#123;</span><br><span class="line">                <span class="comment">// 交给Executor执行，以支持异步</span></span><br><span class="line">                theExecutor.execute(ft);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接（同步）执行</span></span><br><span class="line">                ft.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ft;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">callbackResultHandler</span><span class="params">(FutureTask&lt;Document&gt; ft,ResultHandler rh)</span></span>&#123;</span><br><span class="line">            <span class="comment">// 获取任务结果前判断任务是否被取消</span></span><br><span class="line">            <span class="keyword">if</span> (ft.isCancelled())&#123;</span><br><span class="line">                System.out.println(<span class="string">"parsing cancelled."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Document doc = ft.get();</span><br><span class="line">                rh.onSuccess(doc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                rh.onError(e.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 具体处理过程</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> Document <span class="title">doParse</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ParsingTask <span class="title">setExecutor</span><span class="params">(Executor executor)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.executor = executor;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ParsingTask <span class="title">setResultHandler</span><span class="params">(ResultHandler resultHandler)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.resultHandler = resultHandler;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 异步</span></span><br><span class="line">        XMLDocumentParser.newTask(url).setExecutor(executor).setResultHandler(</span><br><span class="line">                <span class="keyword">new</span> ResultHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">                        process(document);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ).execute();</span><br><span class="line">        <span class="comment">// 同步</span></span><br><span class="line">        Future&lt;Document&gt; future;</span><br><span class="line">        future = XMLDocumentParser.newTask(url).execute();</span><br><span class="line">        process(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>AsyncTask抽象类同时实现了Runnable接口和Callable接口。当任务执行结束后，相应的AsyncTask实例的onResult方法会被调用以处理任务的执行结果；当任务执行过程中抛出异常时，相应的AsyncTask实例的onError方法会被调用以处理这个异常。由于AsyncTask在回调onResult、onError的方法的时候不是直接调用而是通过向Executor实例executor提交一个任务进行的，因此AsyncTask的任务执行（即AsyncTask.run()调用）可以是在一个工作者线程中进行的，而对任务执行结果的处理则可以在另外一个线程中进行。<br>支持重复执行的异步任务抽象类<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(Executor executor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> Executor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                command.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run()成为入口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Exception exp = <span class="keyword">null</span>;</span><br><span class="line">        V r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 执行task</span></span><br><span class="line">            r = call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            exp = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> V result = r;</span><br><span class="line">        <span class="comment">// 异步处理结果</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == exp)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    onResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Exception exceptionCaught = exp;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    onError(exceptionCaught);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(V result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
周期性任务的执行结果处理Demo<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodicTaskResultHandlingDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> AsyncTask&lt;Integer&gt; asyncTask = <span class="keyword">new</span> AsyncTask&lt;Integer&gt;(ses) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">final</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">final</span> String targetHost = host;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> doCall();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">private</span> Integer <span class="title">doCall</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                Integer r = Integer.valueOf(rnd.nextInt(<span class="number">4</span>));</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Integer result)</span> </span>&#123;</span><br><span class="line">                doSomething(result);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Integer r)</span></span>&#123;</span><br><span class="line">                System.out.println(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ses.scheduleAtFixedRate(asyncTask,<span class="number">0</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>从单个任务的角度来看，任务的执行方式是可以同步的，也可以是异步的。同步方式的优点是代码简单、直接，缺点是它往往意味着阻塞，因此不利于系统的吞吐率。异步方式的优点则是它往往意味着非阻塞，因此有利于系统的吞吐率，其代价是相对复杂的代码和额外的开销。阻塞/非阻塞是任务执行方式的属性，它们与任务执行方式没有必然的联系：同步任务既可能是阻塞的，也可能是非阻塞的；异步任务既可能是非阻塞的，也可能是阻塞的。对于同一个任务，我们既可以说它是同步任务也可以说它是异步任务，这取决于任务的执行方式以及我们的观察角度。</li>
<li>Runnable/Callable接口是对任务处理逻辑进行的抽象，而Executor接口是对任务的执行进行的抽象。Executor接口使得我们能够对任务的提交与任务的具体执行细节进行解耦，这为更改任务的具体执行细节提供了灵活性与便利。ExecutorService接口是对Executore接口的增强：它支持返回异步任务的处理结果、支持资源的管理接口、支持批量任务提交等。ThreadPoolExecutor是Executor/ExecutorService接口的一个实现类。实用工具类Executors为线程池的创建提供了快捷方法。CompletionService接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利，其默认实现类为ExecutorCompletionService。</li>
<li>FutureTask是Java标准库提供的Future接口实现类，它还实现了Runnable接口。因此，FutureTask可直接用来获取异步任务的处理结果，它还可以交给专门的工作者线程执行，也可以交给Executor实例执行，甚至由当前线程直接执行（同步）。一般来说，FutureTask是一次性使用的，一个FutureTask实例代表的任务只能够被执行一次。如果需要多次执行同一个任务，那么可以考虑本书介绍的AsyncTask类.</li>
<li>计划任务的执行方式包括延迟执行和周期性执行。ScheduledThreadPoolExecutor是ScheduledExecutorService接口的默认实现类，它可以用于执行计划任务。ScheduledFuture接口可用来获取延迟执行的任务的处理结果。如果要获取周期性执行的计划任务的处理结果，可以使用自定义的AsyncTask类。周期性执行的计划任务，其执行周期并不是固定的，而是受任务单次执行耗时的影响：提交给scheduleAtFixedRate方法执行的计划任务，其执行周期为max(Execution Time,period)；提交给scheduleWithFixedDelay方法执行的计划任务，其执行周期为Execution Time + delay.计划任务在执行过程中如果抛出未捕获的异常，那么该任务将不会被执行。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>Java异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-线程管理</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<ol>
<li><p>线程组是Thread.UncaughtExceptionHandler的一个实现类，它可以帮助我们检测线程的异常终止。多数情况下，我们可以忽略线程组这一概念以及线程组的存在。</p>
<a id="more"></a>
</li>
<li><p>Thread.UncaughtExceptionHandler接口使得我们能够侦测到线程运行过程中抛出的未捕获异常，以便做出相应的补救措施，例如创建并启动相应的替代线程。一个线程在其抛出未捕获的异常而终止前，总有一个UncaughtExceptionHandler实例会被选中。被选中的UncaughtExceptionHandler实例的uncaughtException方法会被该线程在终止前执行。UncaughtExceptionHandler实例选择的优先级：线程实例本身关联的UncaughtExceptionHandler实例&gt;线程所在线程组&gt;默认的UncaughtExceptionHandler。<img src="https://img-blog.csdnimg.cn/20191228164154939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="调用关系"></p>
</li>
<li><p>线程工厂ThreadFactory能够封锁线程的创建与配置逻辑，这使得我们能够对线程的创建与配置进行统一控制。</p>
</li>
<li><p>利用条件变量我们能够实现线程的暂挂与恢复，用于替代Thread.suspend()/resume()这两个废弃方法。</p>
</li>
<li><p>控制线程的暂挂与恢复的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseControl</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">176912312312321L</span>;</span><br><span class="line">    <span class="comment">// 线程暂挂标志</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> suspended = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condSuspended = newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂挂线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        suspended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 恢复线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proceed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            suspended = <span class="keyword">false</span>;</span><br><span class="line">            condSuspended.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前线程仅在线程暂挂标记不为true的情况下才执行指定的目标动作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@targetAction</span> 目标动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseIfNeccessary</span><span class="params">(Runnable targetAction)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (suspended)&#123;</span><br><span class="line">                condSuspended.await();</span><br><span class="line">            &#125;</span><br><span class="line">            targetAction.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20191229155547877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="线程池原理示意图"><br>6. 随着客户端不断提交任务，当前线程池大小也相应增加。在当前线程池大小达到核心线程池大小的时候，新来的任务会被存入到工作者队列中。当工作队列满的时候，线程池会继续创建新的工作者线程，直到当前线程池大小达到最大线程池大小。当线程池饱和时，即工作者队列已满且当前线程池大小达到最大线程池的情况下，客户端试图提交任务会被拒绝。在当前线程池大小超过线程池核心大小的时候，超过线程池核心大小部分的工作者线程空闲时间达到keepAliveTime所指定的时间后就会被清理掉，即这些工作者线程会自动终止并被从线程池中移除。<br>7. ThreadPoolExecutor.prestartAllCoreThreads()预先启动所有线程池核心线程<br>8. ThreadPoolExecutor.shutdown()/shutdownNow()关闭线程池<br>9. public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)<br>10.V call() throws Exception<br>V get() throws InterruptedException,ExecutionException<br>boolean cancel(boolean mayInterruptIfRunning)<br>Future.isDone()<br>V get(long timeout,TimeUnit unit) throws InterruptedException,ExecutionException,TimeoutException<br>客户端代码可以通过捕获Future.get()调用抛出的异常来知晓相应任务执行过程中抛出的异常;客户端线程通常需要在捕获TimeoutException之后执行Future.cancel(true)来取消相应任务的执行。<br>beforeExecute(Thread t,Runnable r)和afterExecute(Thread t,Runnable r)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.lucene.spatial3d.geom.Tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskResultRetrievalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N_CPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="keyword">final</span> ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, N_CPU*<span class="number">2</span>, <span class="number">4</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TaskResultRetrievalDemo demo = <span class="keyword">new</span> TaskResultRetrievalDemo();</span><br><span class="line">        Future&lt;String&gt; future = demo.recognizeImage(<span class="string">"/tmp/images/0001.png"</span>);</span><br><span class="line">        <span class="comment">// 执行其他操作</span></span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 仅在需要相应任务的处理结果时才调用Future.get()</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Tools.randomPause(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">recognizeImage</span><span class="params">(<span class="keyword">final</span> String imageFile)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> doRecognizeImage(<span class="keyword">new</span> File(imageFile));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doRecognizeImage</span><span class="params">(File imageFile)</span></span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 模拟过程</span></span><br><span class="line">        result = <span class="string">"abc"</span>;</span><br><span class="line">        Tools.randomPause(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>线程池时生产者-消费者模式的一个具体例子，它能够摊销线程的创建、启动与销毁的开销，并在一定程度上有利于减少线程调动的开销。线程池使得我们能够充分利用有限的线程资源。ThreadPoolExecutor支持核心线程大小以及最大线程池大小这两种阈值来控制线程池中的工作者线程总数。ThreadPoolExecutor支持对核心线程以外的空闲了指定时间的工作者线程进行清理，以减少不必要的资源消耗。RejectedExecutionHandler接口使得我们能够对被线程池拒绝的任务进行重试以提高系统的可靠性。Future接口使得我们可以获取提交给线程池执行的任务的处理结果、侦测任务处理异常以及取消任务的执行。当一个线程池实例不再被需要时，我们需要主动将其关闭以节约资源。ThreadPoolExecutor提供了一组能够对线程池进行监控的方法，通过这些方法我们能够了解线程池的当前线程池大小、工作队列的情况等数据。同一个线程池只能用于执行相互独立的任务，彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁。我们可以通过线程工厂为线程池中的工作者线程关联UncaughtExceptionHandler，但是这些UncaughtExceptionHandler只会对通过ThreadPoolExecutor.execute方法提交给线程池的任务起作用。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>线程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-线程的活性故障</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B4%BB%E6%80%A7%E6%95%85%E9%9A%9C/</url>
    <content><![CDATA[<ol>
<li><p>死锁会导致相关线程一直被暂停使得其任务无法进展。产生死锁的必要条件包括：资源互斥、资源不可抢占、占用并等待资源以及循环等待资源。我们可以通过查看线程转储手工检测死锁，也可以利用</p>
<a id="more"></a>

<p>ThreadMXBean.findDeadLockedThreads()方法进行死锁的自动检测。死锁的规避方法包括：粗锁法（使用一个粗粒度的锁代替多个锁）、锁排序法（相关线程使用全局统一的顺序申请锁）、使用ReentrantLock.tryLock(long,TimeUnit)来申请锁、使用开放调用（在调用外部方法时不加锁）以及使用锁的替代品。使用内部锁或者使用lock.lock()申请的显示锁导致的死锁是无法恢复的；使用lock.lockInterruptibly()申请的显示锁导致的死锁理论上是可恢复的，但实际操作性不强——自动恢复的尝试可能是徒劳且有害的（导致活锁）。</p>
</li>
<li><p>锁死是等待线程由于某种原因一直无法被唤醒而导致其任务无法进展的一种活性故障。信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使等待线程一直处于等待状态的一种活性故障。嵌套监视器锁死是嵌套锁导致通知线程无法获得其为唤醒等待线程所需的锁从而使其无法唤醒等待线程，最终使得通知线程与等待线程都一直处于等待状态的一种活性故障。嵌套监视器锁死可以通过查看线程转储进行检测。为规避嵌套监视器锁死，我们应该避免在嵌套锁的内层临界区内实现等待/通知。</p>
</li>
<li><p>线程饥饿指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种活性故障。把锁看成一种资源，那么死锁可被看作一种线程饥饿。饥饿可能演变成活锁。</p>
</li>
<li><p>活锁是线程一直在做无用功而使其任务一直无法进展的一种活性故障。试图进行死锁故障恢复可能导致活锁。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>活性故障</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-保障线程安全的设计技术</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E4%BF%9D%E9%9A%9C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="ThreadLocal的内部实现机制"><a href="#ThreadLocal的内部实现机制" class="headerlink" title="ThreadLocal的内部实现机制"></a>ThreadLocal的内部实现机制</h2><a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20191224200945423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="ThreadLocalMap"></p>
<p>在Tomcat环境下，Web应用自身定义的类（Custom Class）由类加载器（Class Loader）WebAppClassLoader负责加载，而Java标准库类（例如HashMap）由类加载器StandardClassLoader负责加载。每个类（类本身也是一种对象）都会持有对加载该类的类加载器的强引用，并且类加载器本身又会持有其加载过的所有类的强引用。另外每个对象（实例）都会持有对其相应类的强引用。<br><img src="https://img-blog.csdnimg.cn/20191224202140398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="线程特有对象与ThreadLocal的引用关系"></p>
<p>StandardClassLoader并不会持有对应用自身定义的类的引用，因此可以消除对线程局部变量的强引用，而对于TSO的可达强引用的消除需要通过在当前线程中调用ThreadLocal.remove()将线程特有对象从其所属的Entry中剥离（清理），便可以使线程特有对象以及线程局部变量都可以被垃圾回收。但是这也造成了线程特有对象的“退化”成“请求特有对象”。<br>结合项目来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除该用户信息可以打破线程对线程特有变量，即user和线程局部变量，即hostHolder的可达强引用防止内存泄漏</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    hostHolder.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Java运行时空间可分为堆空间、非堆空间以及栈空间。栈空间是线程的私有空间，而堆空间和非堆空间都是线程的共享空间。堆空间用于存储对象以及类的实例变量，它是Java虚拟机启动时分配的可以动态扩容的存储空间。非堆空间用于存储类的静态变量以及其他元数据，它是Java虚拟机启动时分配的可以动态扩容的存储空间。栈空间用于存储线程所执行的方法的局部变量、返回值等私有数据，它是线程创建时分配的容量固定不可变的存储空间。</li>
<li>无状态对象不包含任何实例变量以及可更新的静态变量，它具有固有的线程安全性。无状态对象的客户端代码在调用该对象的任何方法时都无须加锁，而无状态对象自身的方法实现可能仍然需要借助锁。仅包含静态方法的类并不能取代无状态对象。Servlet类通常需要被设计为无状态对象。</li>
<li>不可变对象也具有固有的线程安全性。严格意义上的不可变对象需要同时满足这几个条件：类本身采用final修饰，所有字段都是final字段，在对象初始化过程中this代表的当前对象没有逸出，引用了状态可变的对象的字段不能直接暴露给其他对象。如果需要将引用了状态可变的对象的字段暴露给其他对象，那么需要在返回该对象前进行防御性复制，或者返回一个不支持remove的Iterator实例。使用不可变对象建模时，系统状态的变化是通过创建新的不可变对象实现的。这种方式可能有利于提高垃圾回收效率，但也可能由于系统状态频繁变更、无状态对象占用较多内存空间等因素增加了垃圾回收的负担。不可变对象的典型应用场景包括：被建模对象的状态变化不频繁、同时对一组相关的数据进行写操作，因此需要保证原子性、使用不可变对象作为安全可靠的Map键。当被建模对象的状态变更比较频繁时，不可变对象也不见得就不能使用。此时，我们需要综合考虑被建模对象的规模、代码目标运行环境的Java虚拟机堆内存容量、系统对吞吐率和响应性的要求这几个因素。</li>
<li>线程特有对象也具有固有的线程安全性。ThreadLocal是线程访问其线程特有对象的代理。ThreadLocal也被称为线程局部变量，一个线程可以通过使用不同的线程局部变量来访问不同的线程特有对象实例。多个线程即使是使用同一个线程局部变量，其访问到的对象也是各自的线程特有对象。线程局部变量通常作为一个类的静态字段来使用。为避免线程局部变量的使用导致内存泄漏和伪内存泄漏，我们需要确保在线程特有对象不再被需要时将其“删除”（即调用ThreadLocal.remove()）。线程特有对象的典型应用场景包括：需要使用非线程安全对象，但又不希望因此而引入锁；使用线程安全对象，但希望避免其使用的锁的开销和相关问题；实现方法间的隐式参数传递；实现特定于线程间的单例模式。</li>
<li>装饰器模式也能够用于实现线程安全。在使用装饰器模式的情况下，实现同一组功能的对象有非线程安全版和线程安全版两版。这两种对象具有相同的接口，其中非线程安全版对象仅关注功能的实现，而外包装对象（线程安全版）主要关注线程安全的保障。外包装对象在功能方面是通过委托给相应的非线程安全对象来实现的。Java并发集合就是使用装饰器模式来保障线程安全的。使用装饰器模式实现线程安全的优点是它支持关注点分离，并有利于降低开发难度和提高代码的可测试性，也有利于提高使用的灵活性。其缺点是并发性不高，并可能导致遍历操作是非线程安全的。</li>
<li>并发集合一般可用于替代同步集合。其内部实现往往借助于CAS操作或者细粒度锁。并发集合支持线程安全的遍历操作，即对集合的遍历操作与更新操作是可以由不同线程并发执行的。并发集合实现线程安全的遍历操作有两种方式：快照和准实时。前者无法在遍历过程中反映其他线程对遍历集合所作的更新，而后者在遍历过程中可能反映其他线程对被遍历集合所作的更新。CopyOnWriteArrayList相当于ArrayList的线程安全版，CopyOnWriteArrayList的更新操作是通过创建一个新的数组newArray，并把老的数组的内容复制到newArray，然后对newArray进行更新并将array引用指向newArray，它适用于遍历操作远比更新操作频繁或者不希望在遍历的时候加锁的场景，在其他场景下我们仍然要考虑使用相应的同步集合。CopyOnWriteArraySet相当于HashSet的线程安全版，内部实现基于CopyOnWriteArrayList的。因此，CopyOnWriteArraySet使用场景与CopyOnWriteArrayList类似。ConcurrentLinkedQueue相当于LinkedList的线程安全版，其内部访问其共享状态变量的时候并不借助锁，而是使用CAS操作来保障线程安全的，与BlockingQueue的实现类相比，ConcurrentLinkedQueue适用于更新操作和遍历操作并发的场景。BlockingQueue的实现类更适合于多个线程并发更新同一队列的场景，如生产者——消费者模式中。ConcurrentHashMap相当于HashMap的线程安全版，其内部使用了粒度极小的锁来保障其线程安全，能够支持较高的并发性。ConcurrentSkipListMap相当于TreeMap的线程安全版，ConcurrentSkipListSet相当于TreeSet的线程安全版。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>保障线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-线程间协作</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C/</url>
    <content><![CDATA[<p>使用Object.wait()实现等待</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在调用wait方法前获得相应对象的内部锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">	<span class="keyword">while</span>(保护条件不成立)&#123;</span><br><span class="line">		someObject.wait();</span><br><span class="line">		<span class="comment">// wait()的操作主要是释放内部锁，当notify()函数唤醒之后</span></span><br><span class="line">		<span class="comment">// 占有CPU，然后开始申请内部锁</span></span><br><span class="line">		<span class="comment">// 申请之后执行wait()剩余指令</span></span><br><span class="line">		<span class="comment">// 由于锁可能被抢占可能导致保护条件又不满足，因此要在while之内</span></span><br><span class="line">	&#125;</span><br><span class="line">	doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Object.notify()实现通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">	updateSharedState();</span><br><span class="line">	someObject.notify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 整个函数结束才会释放内部锁</span></span><br></pre></td></tr></table></figure>
<p>Object.wait()的部分内部实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 执行线程必须持有当前对象对应的内部锁</span></span><br><span class="line">	<span class="keyword">if</span>(!Thread.holdsLock(<span class="keyword">this</span>))&#123;</span><br><span class="line">		<span class="function"><span class="keyword">throws</span> new <span class="title">IllegalMonitorStateException</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(当前对象不在等待集中)&#123;</span><br><span class="line">		<span class="comment">// 将当前线程加入当前对象的等待集中</span></span><br><span class="line">		addToWaitSet(Thread.currentThread());</span><br><span class="line">	&#125;</span><br><span class="line">	atomic&#123; <span class="comment">// 原子操作开始</span></span><br><span class="line">		<span class="comment">// 释放当前对象的内部锁</span></span><br><span class="line">		releaseLock(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// 暂停当前线程</span></span><br><span class="line">		block(Thread.currentThread());</span><br><span class="line">	&#125; <span class="comment">// 原子操作结束</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次申请当前对象的内部锁</span></span><br><span class="line">	acquireLock(<span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">// 将当前线程从当前对象的等待集中移除</span></span><br><span class="line">	removeFromWaitSet(Thread.currentThread());</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Condition接口的使用方法代码模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConditionUsage</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aGuaredMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(保护条件不成立)&#123;</span><br><span class="line">				condition.await();</span><br><span class="line">			&#125;</span><br><span class="line">			doAction();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> doNotification <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">// 更新共享变量</span></span><br><span class="line">			changeState();</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带流量控制功能的传输通道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreBasedChannel</span>&lt;<span class="title">P</span>&gt; <span class="keyword">implements</span> <span class="title">Channel</span>&lt;<span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;P&gt; queue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SemaphoreBasedChannel</span><span class="params">(BlockingQueue&lt;P&gt; queue, <span class="keyword">int</span> flowLimit)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(queue,flowLimit, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SemaphoreBasedChannel</span><span class="params">(BlockingQueue&lt;P&gt; queue, <span class="keyword">int</span> flowLimit, <span class="keyword">boolean</span> isFair)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.queue = queue;</span><br><span class="line">		<span class="keyword">this</span>.semaphore = <span class="keyword">new</span> Semaphore(flowLimit, isFair);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> P <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.take();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(P product)</span> <span class="keyword">throws</span> interruptedException </span>&#123;</span><br><span class="line">		semaphore.acquire();	<span class="comment">// 申请一个配额</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			queue.put(product);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			semaphore.release();	<span class="comment">// 返还一个配额</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通用的线程优雅停止办法实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminatableTaskRunner</span> <span class="keyword">implements</span> <span class="title">TaskRunnerSpec</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; channel;</span><br><span class="line">	<span class="comment">// 线程停止标志</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> inUser = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 待处理任务计数器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> AtomicInteger reservations = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Thread workerThread;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TerminatableTaskRunner</span><span class="params">(BlockingQueue&lt;Runnable&gt; channel)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.channel = channel;</span><br><span class="line">		<span class="keyword">this</span>.workerThread = <span class="keyword">new</span> WorkerThread();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TerminatableTaskRunner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Thread t = workerThread;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != t)&#123;</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		channel.put(task);</span><br><span class="line">		reservations.incrementAndGet();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Debug.info(<span class="string">"Shutting down service..."</span>);</span><br><span class="line">		inUse = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">final</span> Thread t = workerThread;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != t)&#123;</span><br><span class="line">			t.interrupt();	<span class="comment">// 中断之后等所有任务全部完成即可结束线程</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			Runnable task = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">					<span class="comment">// 线程不再被需要，且无待处理任务</span></span><br><span class="line">					<span class="keyword">if</span>(!inUse &amp;&amp; reservations.get() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					task = channel.take();</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						task.run();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					reservations.decrementAndGet();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">					workerThread = <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				Debug.info(<span class="string">"worker thread terminated."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>等待线程可以通过执行Object.wait()/wait(long)来实现等待。通知线程可以通过执行Object.notify()/notifyAll()来实现通知。等待线程、通知线程在执行Object.wait()/wait(long)、Object.notify()/notifyAll()时必须持有相应对象对应的内部锁。为了避免信号丢失问题以及欺骗性唤醒问题，等待线程将等待线程对保护条件的判断、Object.wait()/wait(long)的调用必须放在相应对象所引导的临界区中的一个循环语句中。</li>
<li>使用notify()替代notifyAll()必须使以下两个条件同时得以满足：<ul>
<li>一次通知仅需要唤醒至多一个线程；</li>
<li>对应对象上的所有等待线程都是同质等待线程。</li>
</ul>
</li>
<li>使用notify()替代notifyAll()可以减少等待/通知中产生的上下文切换。通知线程在执行完Object.notify()/notifyAll()后尽快释放相应对象的内部锁也有助于减少上下文切换。</li>
<li>条件变量(Condition接口)是wait/nofity的替代品。Condition接口的API与wait/notify类似：Condition.await()/awaitUntil(Date)相当于Object.wait()/wait(long);Condition.signal()/signalAll()相当于Object.notify()/notifyAll()。Condition.awaitUntil(Date)解决了Object.wait(long)存在的问题——无法区分其返回是否是由等待超时而导致的。</li>
<li>Condition接口本身只是对解决过早唤醒问题提供了支持。要真正解决过早唤醒问题，我们还需要通过应用代码维护保护条件变量之间的对应关系，并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件变量的signal/signalAll方法来实现通知。</li>
<li>CountDownLatch能够用来实现一个线程等待其他线程执行的特定操作的结束。等待线程执行CountDownLatch.await()，通知线程执行CountDownLatchDown()。为避免等待线程永远处于暂停状态而无法被唤醒，CountDownLatch.countDown()调用通常需要被放在finally块中。一个CountDownLatch实例只能实现一次等待/通知。对于同一个CountDownLatch实例latch,latch.countDown()的执行线程在执行该方法之前所执行的任何内存操作，对等待线程在latch.await()调用返回之后的代码都是可见且有序的。</li>
<li>CyclicBarrier能够用于实现多个线程间的相互等待。CyclicBarrier.await()既是等待方法又是通知方法。CyclicBarrier实例的所有参与方除最后一个线程外都相当于等待线程，最后一个线程相当于通知线程。与CountDownLatch不同的是，CyclicBarrier实例是可以复用的——一个CyclicBarrier实例可以实现多次等待/通知。在使用CountDownLatch足以满足要求的情况下，我们应该避免使用CyclicBarrier。CyclicBarrier的典型应用场景包括：使迭代(Iterative)算法并发化，在测试代码中模拟高并发。</li>
<li>在生产者—消费者模式中，生产者负责生产产品并通过传输通道将产品以线程安全的方式发布到消费者线程。消费者线程仅负责从传输通道中取出产品进行“消费”。产品既可以是数据，也可以是待处理的任务。BlockIngQueue的实现类ArrayBlockingQueue、LinkedBlockingQueue和SynchronousQueue等以及Exchanger类可作为传输通道。</li>
<li>生产者与消费者所执行的处理，即产品的生产与”消费“是并发的。这使得我们能够平衡生产者、消费者处理能力的差异，即避免了一方处理过慢对另一方产生影响。另外，生产者-消费者模式使得一个线程（消费者线程）可以处理多个任务，提高了线程的利用率。</li>
<li>使用无界队列作为传输通道时往往需要借助Semaphore控制生产者的生产速率。Semaphore相当于能够对程序访问虚拟资源的并发程度进行控制的配额调度器。Semaphore.acquire()用于申请配额，Semaphore.release()用于返还配额，Semaphore.release()调用总是放在finally块中。Semaphore.acquire()和Semaphore.releaser()总是配对使用的，这点需要由应用代码来确保。Semaphore对配额的调度既支持非公平策略（默认策略），也支持非公平策略。</li>
<li>PipedOutputStream/PipedInputStream是Java标准库类中生产者-消费者模式的一个具体例子。  PipedOutputStream/PipedInputStream适合在单生产者—单消费者模式中使用，应避免在单线程程序中使用 PipedOutputStream/PipedInputStream。生产者线程发生异常而导致其无法继续提供新的数据时，生产者线程必须主动提前关闭相应的 PipedOutputStream实例（调用 PipedOutputStream.close()）。</li>
<li>Exchanger类也可作为传输通道，它对双缓冲技术提供了支持：生产者与消费者各自维护一个缓冲区，双方通过执行Exchanger.exchange(V)来交换各自持有的缓冲区。当消费者在”消费“一个已填充完毕的缓冲区时，生产者可以对待填充的缓冲区进行填充（生产产品），从而实现了产品的”消费“与生成的并发。Exchanger类便于我们能够对产品的粒度进行优化。</li>
<li>Java线程中断机制相当于Java线程与线程间协作的一套协议框架：发起线程通过Thread.interrupt()调用给目标线程发送中断，这相当于将目标线程的线程中断标记置为true；目标线程则通过Thread.currentThread().isInterrupted()/Thread.interrupted()来获取或者获取并重置线程中断标记；发起线程给目标线程发送中断所导致的结果取决于目标线程对中断的响应方式。给目标线程发送中断还能够产生唤醒目标线程的效果。目标线程可以通过对InterruptedException进行处理的方式或者直接通过判断线程中断标记并执行相应的处理逻辑的方式来响应中断。对InterruptedException进行处理的正确方式包括：不捕获InterruptedException、捕获InterruptedException后重新将该异常抛出，以及捕获InterruptedException并在捕获该异常后中断当前线程。</li>
<li>需要主动停止线程的典型场景包括：服务或者系统关闭、错误处理以及用户取消任务。通用的线程优雅停止方法：发起线程更新目标线程的线程停止标记并给其发送中断，目标线程仅在当前无待处理任务且不会产生新的待处理任务的情况下才能run方法返回。Web应用自身启动的工作者线程需要由应用自身在Web应用停止时主动停止。</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>线程协作</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-牛刀小试：玩转线程</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E7%89%9B%E5%88%80%E5%B0%8F%E8%AF%95%EF%BC%9A%E7%8E%A9%E8%BD%AC%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li><p>挖掘出程序中的可并发点是现实多线程编程的目标——并发计算的前提。</p>
<a id="more"></a>
</li>
<li><p>实现并发化的策略包括基于数据的分割策略和基于任务的分割策略。前者从程序处理的数据角度入手，将原始输入分解为若干规模更小的子输入，并将这些子输入指派给专门的工作者线程处理。其结果是产生若干同质的工作者线程。后者从程序的处理逻辑角度入手，将原始任务处理逻辑按照任务的资源消耗属性或者处理步骤分解为若干子任务，并创建专门的工作者线程来执行这些子任务。其结果是产生多个相互协作的异质工作者线程。</p>
</li>
<li><p>多线程编程实践中需要注意一下几个问题。</p>
</li>
</ol>
<ul>
<li>考虑到多线程程序往往比相应的单线程程序要复杂，且未必比相应的单线程程序快，因此多线程编程的一个实施策略是考虑从单线程程序向多线程程序“进化”，而不是直接迈向“多线程”。</li>
<li>线程数的合理设置。设置线程数的基本原则就是避免随意设置、使线程数可配置或者可以动态计算得来。设置合理的线程数需要考虑系统的资源状况（处理器数目、内存大小等）、线程所执行的任务的特性（CPU密集型任务、I/O密集型任务）、资源使用情况规划（CPU使用率上限）以及程序运行过程中所使用到的其他稀缺资源情况（如数据库连接、文件句柄数）等因素。</li>
<li>多线程程序往往比相应的单线程程序产生更多的开销，且需要注意工作者线程的异常处理以及原始任务规模未知问题的应对。</li>
</ul>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-Java线程同步机制</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java线程同步机制的幕后助手是内存屏障。不同同步机制的功能强弱不同，相应的开销以及可能导致的问题也不同。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th></th>
<th>锁</th>
<th>volatile</th>
<th>CAS</th>
<th>final</th>
<th>static</th>
</tr>
</thead>
<tbody><tr>
<td>原子性保障</td>
<td>具备</td>
<td>具备</td>
<td>具备</td>
<td>不涉及</td>
<td>不涉及</td>
</tr>
<tr>
<td>可见性保障</td>
<td>具备</td>
<td>具备</td>
<td>不具备</td>
<td>不具备</td>
<td>具备</td>
</tr>
<tr>
<td>有序性保障</td>
<td>具备</td>
<td>具备</td>
<td>不涉及</td>
<td>具备</td>
<td>具备</td>
</tr>
<tr>
<td>上下文切换</td>
<td>可能</td>
<td>不会</td>
<td>不会</td>
<td>不会</td>
<td>可能</td>
</tr>
</tbody></table>
<ol>
<li>锁是Java平台中功能最强大的一种线程同步机制，同时其开销也最大，可能导致的问题也最多。被争用的锁会导致上下文切换，锁还可能导致死锁、锁死等线程活性故障。锁适用于存在多个线程对多个共享数据进行更新、check-then-act操作或者read-modity-write操作这样的场景。</li>
<li>锁的排他性以及Java虚拟机在临界区前后插入的内存屏障使得临界区中的操作具有原子性。由此，锁还保障了写线程在临界区中执行的操作在读线程看来是有序的，即保障了有序性。Java虚拟机在MonitorExit对应的机器码后插入的内存屏障则保障了可见性。锁能够保障线程安全的前提是访问同一组共享数据的多个线程必须同步在同一个锁之上，否则原子性、可见性和有序性均无法得以保障。在满足貌似串行语义的前提下，临界区内以及临界区外的操作可以在各自范围内重排序。临界区外的操作可能会被JIT编译器重排到临界区内，但临界区内的操作不会被编译器、处理器重排到临界区之外。<br><img src="https://img-blog.csdnimg.cn/20191212215250838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="内存屏障"></li>
<li>Java中的所有锁都是可重入的。内部锁(synchronized)仅支持非公平锁，因此它可能导致饥饿。而显式锁(ReentrantLock)既支持非公平锁又支持公平锁，显示锁可能导致锁泄露。内部锁和显式锁各有所长，各有所短。读写锁(ReadWriteLock)由于其内部实现的复杂性，仅适用于只读操作比更新操作要频繁得多且读线程持有锁的时间比较长得场景。读写锁(ReadWriteLock)中的读锁和写锁是一个锁实例所充当的两个角色，并不是两个独立的锁。</li>
<li>线程转储中可以包含锁的相关信息——线程在等待哪些锁，这些锁又是被哪些线程持有的。</li>
<li>volatile相当于轻量级锁。在线程安全保障方面与锁相同的是，volatile能够保障可见性、有序性；与锁不同的是volatile不具有排他性，也不会导致上下文切换。与锁类似，Java虚拟机实现volatile对有序性和可见性的保障也是借助于内存屏障。从这个角度来看，volatile变量写操作相当于释放锁，volatile变量读操作相当于获得锁——Java虚拟机通过在volatile变量写操作之前插入一个释放屏障，在volatile变量读操作之后插入一个获取屏障这种成对的释放屏障和获取屏障的使用实现了volatile对有序性的保障。类似，Java虚拟机在volatile变量写操作之后插入一个存储屏障，在volatile变量读操作之前插入一个加载屏障这种成对的存储屏障与加载屏障的使用实现了对可见性的保障。<br><img src="https://img-blog.csdnimg.cn/2019121222083247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="volatile变量读写"></li>
<li>在原子性方面，volatile仅能保障long/double型变量写操作的原子性。如果要保障对volatile变量的赋值操作的线程安全，那么赋值操作右边的表达式不能涉及任何共享变量（包括被赋值的变量本身）。volatile关键字在可见性、有序性和原子性方面的保障并不会对其修饰的数组元素的读、写操作起作用。</li>
<li>volatile变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。读取一个volatile变量总是意味着(通过高速缓存进行的)读内存操作，而不是从寄存器中读取。因此，volatile变量读操作的成本比读取普通变量要略高一点，但比在临界区中读取变量要低。</li>
<li>volatile的典型运用场景包括：一，使用volatile变量作为状态标志；二，使用volatile保障可见性；三，使用volatile变量代替锁；四，使用volatile实现简易版读写锁。</li>
<li>CAS使得我们可以在不借助锁的情况下保障read-modify-write操作、check-then-act操作的原子性，但是它并不保障可见性。原子变量类相当于基于CAS实现的增强型volatile变量（保障volatile无法保障的那一部分操作的原子性）。常用的原子变量类包括AtomicInteger、 AtomicLong、AtomicBoolean等。AtomicStampedReference则可以用于规避CAS的ABA问题。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(Variable V,Object A, Object B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A == V.get())&#123; <span class="comment">// check:检查变量值是否被其他线程修改过</span></span><br><span class="line">		V.set(B);	<span class="comment">// 更新变量值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;	<span class="comment">// 更新成功</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;	<span class="comment">// 变量值已被其他线程修改，更新失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	oldValue = count;	<span class="comment">// 读取共享变量的当前值</span></span><br><span class="line">	newValue = oldValue + <span class="number">1</span>; 	<span class="comment">// 计算共享变量的新值</span></span><br><span class="line">&#125; <span class="keyword">while</span> (!compareAndSwap(oldValue,newValue));</span><br></pre></td></tr></table></figure></li>
<li>static关键字能够保证一个线程即使在未使用其他同步机制的情况下也总是可以读取到一个类的静态变量的初始值（而不是默认值）。对于引用型静态变量，static还确保了该变量引用的对象已经初始化完毕。但是，static的这种可见性和有序性保障仅在一个线程初次读取静态变量的时候起作用。</li>
<li>final关键字在多线程环境下也有其特殊作用：当一个对象被发布到其他线程的时候，该对象的所有final字段（实例变量）都是初始化完毕的。而非final字段没有这种保障，即这些线程读取该对象的非final字段时所读取到的值可能仍然是相应字段的默认值。对于引用型final字段，final关键字还进一步确保该字段所引用的对象已经初始化完毕。</li>
<li>实现对象的安全发布，通常可以依照以下顺序选择适用且开销最小的线程同步机制。</li>
</ol>
<ul>
<li>使用static关键字修饰引用该对象的变量。</li>
<li>使用final关键字修饰引用该对象的变量。</li>
<li>使用volatile关键字修饰引用该对象的变量。</li>
<li>使用AtomicReference关键字修饰引用该对象的变量。</li>
<li>对访问该对象的代码进行加锁。<br>为避免将this代表的当前对象逸出到其他线程，我们应该避免在构造器中启动工作者线程。通常我们可以定义一个init方法，在该方法中启动工作者线程。在此基础上，定义一个工厂方法来创建（并返回）相应的实例，并在该方法中调用该实例的init方法。</li>
</ul>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>同步机制</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-多线程编程的目的与挑战</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8E%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[<ol>
<li><p>单线程程序所进行的计算本质上是串行。多线程编程的目标是将原本串行的计算改为并发乃至并行。</p>
<a id="more"></a>
</li>
<li><p>竞态（Race Condition）是指计算的正确性依赖于相对世界顺序(Relative Timing)或者线程的交错。竞态表现为计算的结果时而正确时而错误，它并不意味着计算的结果一定是错误的，其往往伴随着读脏数据、丢失更新的问题。竞态是访问（读取、更新）同一组共享变量的多个线程所执行的操作相互交错而导致的干扰（读脏数据）或者冲突（丢失更新）的结果。二维表分析法是分析和解释竞态的有效和常用工具。一个类能够导致竞态，那么它就不是线程安全的。线程安全意味着不存在竞态，但是不存在竞态却未必意味着线程安全。</p>
</li>
<li><p>线程安全问题表现为原子性、可见性和有序性这三个方面。这几个方面既相互区别，又相互联系。原子性的保障能够消除竞态。可见性描述了一个线程对共享变量的更新对于另一个线程而言是否可见，或者说什么情况下可见的问题。原子性和可见性一同得以保障了一个线程能够共享变量的相对新值，而不是一个半成品的“值”。有序性描述了一个处理器上运行的一个线程对共享变量所作的更新，在另外一个处理器上运行的其他线程看来，这些线程是以什么样的顺序观察到这些更新的问题。可见性是有序性的基础，而有序性又可能影响可见性。</p>
</li>
<li><p>原子操作是“不可分割”的操作。所谓“不可分割”包含两层含义：其一，访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会”看到“该操作执行了部分的中间效果；其二，访问一组共享变量的原子操作是不能够被交错的，这通常意味着互斥，即对于访问同一组共享变量的多个原子操作，一个线程执行其中一个操作的时候其他线程无法访问这组共享变量中的任意一个变量。将read-modify-write的操作和check-then-act转换为原子操作能够消除竞态。在Java语言中，对long/double型以外的任何变量的写操作都是原子的。volatile关键字修饰的long/double型写操作也具有原子性。针对任何变量的读操作都是原子操作。</p>
</li>
<li><p>可见性问题不是必然出现的，而一旦出现则可能导致灾难性后果。导致可见性问题的因素既有软件因素（JIT编译器）也有硬件因素（处理器和内存等存储设备）。可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障该线程能够读取到相应变量的最新值。父线程在启动子线程前对共享变量所作的更新对这个子线程可见，子线程执行期间对共享变量所作的更新对该线程的join()执行线程可见（从join返回处开始才可见的）。</p>
</li>
<li><p>编译器、处理器、存储子系统（写缓冲器和高速缓存等）和运行时（JIT编译器）都可能导致重排序。重排序是出于性能的需要并满足”貌似串行语义“的前提下进行的，它可能导致线程安全问题。与可见性问题类似，重排序也不是必然出现的。有序性的保障是通过部分地从逻辑上禁止重排序实现的。可见性是有序性的基础，而有序性反过来又可能影响可见性。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>重排序类型</th>
<th>重排序表现</th>
<th>重排序来源（主体）</th>
</tr>
</thead>
<tbody><tr>
<td>指令重排序</td>
<td>程序顺序与源代码顺序不一致</td>
<td>编译器</td>
</tr>
<tr>
<td>指令重排序</td>
<td>执行顺序与程序顺序不一致</td>
<td>JIT编译器、处理器</td>
</tr>
<tr>
<td>存储子系统重排序</td>
<td>源代码顺序、程序顺序和执行顺序这三者保持一致，但是感知顺序与执行顺序不一致</td>
<td>高速缓存、写缓冲器</td>
</tr>
<tr>
<td>7. 上下文切换可以看作多线程编程的必然产物，一方面它使得充分利用及其有限的处理器资源成为可能；另一方面它也增加了系统的开销。因此，多线程编程并未必比单线程的计算效率要高。程序运行过程中发生的上下文切换既有自发性上下文切换，也有非自发性上下文切换。Linux内核提供的perf命令可以帮助我们测量程序运行过程中发生的上下文切换的次数和频率。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8. 多线程程序可能由于资源稀缺性或者程序自身的错误和缺陷而一直处于非RUNNABLE状态，或是即使是处于RUNNABLE状态，但是其要执行的任务一直无法进展，即产生了活性故障。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9. 非公平调度策略是我们多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对较长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>多线程目的</tag>
        <tag>多线程挑战</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程-走近Java世界中的线程</title>
    <url>/2020/01/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E8%B5%B0%E8%BF%91Java%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li><p>进程是程序的运行实例，一个进程可以包含多个线程，这些线程共享其所在进程的资源。</p>
<a id="more"></a>
</li>
<li><p>线程是进程中可独立执行的最小单位。Java标准库类java.lang.Thread就是Java平台对线程的实现。特定线程总是在执行特定的任务，线程的run方法就是线所要执行任务的处理逻辑的入口方法，该方法由Java虚拟机直接调用执行。Java标准库接口java.lang.Runnable就是对任务的抽象，Thread类就是Runnable接口的一个实现类。</p>
</li>
<li><p>应用程序负责线程的创建与启动，而线程的调度器负责线程的调度和执行。Java平台中有两种方式创建线程：创建Thread的子类以及以Runnable接口实例为构造器参数直接通过new创建Thread实例。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程编程每章总结</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-19-项目部署和总结</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-19-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>之前我们都是在本机上跑整个项目，接下来我们要将这个项目部署到服务器上然后再通过路径来访问，当然这里我们使用虚拟机CentOS进行代替。</p>
<a id="more"></a>

<p>下图是我们项目的结构，可以看到我们是使用nginx服务器来分发请求到Tomcat的，这就是所谓的反向代理，通常情况下我们会有多个Tomcat服务器，但是我们虚拟机分配的资源很少所以只有一个Tomcat服务器，Tomcat服务器就是我们项目部署的位置，我们只要将项目放到Tomcat的webapp之下即可访问到，同时为了让项目可以跑起来，我们也必须要装上JRE，即Java运行环境，Maven用于将打包的WAR包解压出来，并下载相关依赖，以及项目用到的MySQL、Redis、Kafka、Elasticsearch和Wkhtmltopdf。<br><img src="https://img-blog.csdnimg.cn/20200117214410272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="项目部署结构"></p>
<p>接下来我们就在虚拟机上安装这些必要的软件包，通常情况下我们可以使用yum安装，因为yun安装十分方便，不用我们自己配置环境变量，但是有些yun上的包有些旧，我们还是需要自己去下载较新的版本引入yun中，然后再用yun安装，当然也有些需要自己去官网下载tar.gz或者zip压缩包然后自己解压并配置环境变量。<br><strong>需要下载压缩包</strong></p>
<p>其中tomcat、maven、elasticsearch、elasticsearch-analysis-ik和kakfa需要我们自己下载压缩包，我们可以直接下载到/root目录下。<br><img src="https://img-blog.csdnimg.cn/2020011721535225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="下载的压缩包"></p>
<p>我们可以使用tar -zvxf xxx -C /opt 命令将文件解压到opt目录下</p>
<p>然后修改/etc/profile,添加PATH=$PATH:xxx/bin来配置环境变量。<br><strong>yum安装</strong></p>
<p>Nginx、JRE、Redis、MySQL和Wkhtmltopdf我们都可以使用yum安装，其中MySQL我们先要去官网下载8.0的rpm包，然后使用yum install xxx.rpm 的命令将rpm包安装到yum的资源库中，然后再用yum安装。<br>yum安装我们只要yum list xxx来查看yum资源库中的相关内容，然后使用yum install -y xxx 即可完成安装。<br><strong>安装过程中的一些配置</strong></p>
<p><em>mysql*</em>：我们使用mysql -u root -p来登录mysql并进入，然后我们需要将生成sql的语句运行来建表，其顺序是init_schema.sql -&gt; init_data.sql -&gt; tables_mysql_innodb.sql，其中第三个是创建quartz所需的数据表</p>
<p><strong>maven</strong>：maven我们需要添加阿里云的镜像</p>
<p><strong>kafka</strong>：zookeeper的后台启动命令bin/zookeeper-server-start.sh -daemon config/zookeeper.properties<br>kafka的后台启动命令nohup bin/kafka-server-start.sh config/server.properties 1&gt;/dev/null 2&gt;&amp;1 &amp;</p>
<p><strong>elasticsearch</strong>：elasticsearch的分词是解压到elasticsearch/plugins/ik，对于elasticsearch的配置我们需要修改cluster.name，path.data和path.logs，然后jvm.options也要修改，让elasticsearch的启动内存为256M，最大内存为512M，防止服务器奔溃。<br>同时elasticsearch不能用root用户启动，因此我们需要创建一个用户，并且该用户拥有tmp和opt的权限。对此我们创建了nowcoder组下名为nowcoder1的用户，然后在tmp和opt路径下使用命令chown -R nowcoder1:nowcoder *来分配权限，然后使用su - nowcoder1切换至nowcoder1用户，然后使用elasticsearch  bin/elasticsearch -d命令后台启动elasticsearch。</p>
<p><strong>wkhtmltopdf</strong>：使用wkhtmltopdf我们需要安装一个虚拟的GUI程序，命令如下yum install -y xorg-x11-server-Xvfb.x86_64；然后我们可以这样来生成长图xvfb-run –server-args=”-screen 0, 1024x768x24” wkhtmltoimage <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> 1.png，由于xvfb-run –server-args=”-screen 0, 1024x768x24” wkhtmltoimage这部分是不变的，因此我们可以写成一个脚本然后使用”$@”来传参，具体我们写好之后可以这样使用/opt/wkhtmltoimage.sh https:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 2.png</p>
<p><strong>tomcat</strong>：我们首先将webapp下的其他项目全部删除，然后进入/root/community，使用命令mvn package -Dmaven.test.skip=true来得到target目录，然后进入target目录，使用mv ROOT.war /opt/apache-tomcat-9.0.30/webapps/命令将ROOT.war移动到webapps之下，然后使用命令startup.sh启动使用tomcat即可。</p>
<p><strong>nginx</strong>：nginx我们主要对/etc/nginx/conf进行配置，使得请求发送给tomcat处理，主要是对conf文件的server进行配置，具体如下。</p>
<p>配置之后我们访问192.168.16.100（默认80端口），nginx就会监听80端口，然后将请求交给myserver函数处理，而myserver中定义了server的路径即端口8080，即tomcat来处理。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实服务器</span></span><br><span class="line">upstream myserver &#123;</span><br><span class="line">	server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> max_fails=<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚拟服务器 反向代理到真实服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name <span class="number">192.168</span><span class="number">.16</span><span class="number">.100</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http:<span class="comment">//myserver;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用systemctl start nginx命令来启动nginx。</p>
<p>当然我们将项目移动到服务器之后需要对配置文件进行修改，我们可以有两份配置文件，分别对应开发阶段和服务器上线阶段，而项目本身我们只要只要修改引用的是develop配置文件还是produce配置文件即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># profile</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">produce</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># logback</span></span><br><span class="line"><span class="meta">logging.config</span>=<span class="string">classpath:logback-spring-$&#123;spring.profiles.active&#125;.xml</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020011722413810.png" alt="具体配置"></p>
<p>由于我们是对/进行请求处理，因此我们要将对/index的访问重定向到/上，同时我们现在只对192.168.16.100：80进行监听，因此我们需要去掉/community这一部分，所以在application.properties和js中都需要做修改，除此之外，我们还要对路径进行修改，原先存放在d:\work\data之下的都要改成\tmp之下了。</p>
<p>最后由于我们不再使用SpringBoot自带的Tomcat来启动项目，而tomcat有自带的main函数，因此我们项目的main函数不会被执行，我们需要通过配置来让我们项目的main函数启动，具体如下（不是很懂！！）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunityServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(CommunityApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们服务器使用的是mysql8.0因此对于jdbc的配置我们也需要修改，原先的5.6过旧了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># DataSourceProperties</span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=xxxxxxxxxx</span><br><span class="line">spring.datasource.type=com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=<span class="number">15</span></span><br><span class="line">spring.datasource.hikari.minimum-idle=<span class="number">5</span></span><br><span class="line">spring.datasource.hikari.idle-timeout=<span class="number">30000</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong></p>
<p>最后遇到了一个问题nginx永远返回502Bad Gateway，通过查询资料发现是服务器拒绝了网络代理，需要进行如下配置/usr/sbin/setsebool -P httpd_can_network_connect true。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>项目构成图<br><img src="https://img-blog.csdnimg.cn/20200117231026182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="项目结构"></p>
<p>网站结构图<br><img src="https://img-blog.csdnimg.cn/20200117231821882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="网站架构图"></p>
]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-18-单元测试和项目监控</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-18-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><a id="more"></a>

<p>开发过程中测试是十分重要的，在我们的开发过程中，测试是贯穿整个项目的，但是实际上我们有些测试之间是存在相互依赖关系的，这样或许会在之后的测试中产生麻烦，最好的方法就是每个测试类都是项目依赖的，我们在每个类中初始化测试数据，然后再进行测试，对比结果，测试完成之后再将数据删去。</p>
<p>Spring Boot Test中集成了很多测试工具，常用的注解有@BeforeClass，@AfterClass，@Before，@After，其中@BeforeClass和@AfterClass会在测试类构造之前和消解之后执行，@Before和@After会在该测试各个方法之前和之后执行。</p>
<p>接下来给出一个demo。在@Before注解声明的before()方法中我们对测试数据进行初始化，然后在测试方法中使用，然后在@After注解的after()方法中删除该数据。在测试方法中我们可以使用断言来判断测试方法是否通过。Assert.assertEquals()第一个参数表示期望值，第二个参数表示实际值，第三个参数是可选的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= CommunityApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    DiscussPost data;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"beforeClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AfterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化测试数据</span></span><br><span class="line">        data = <span class="keyword">new</span> DiscussPost();</span><br><span class="line">        data.setUserId(<span class="number">111</span>);</span><br><span class="line">        data.setTitle(<span class="string">"Test Title"</span>);</span><br><span class="line">        data.setContent(<span class="string">"test Content"</span>);</span><br><span class="line">        data.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        discussPostService.addDiscussPost(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除测试数据</span></span><br><span class="line">        discussPostService.updateStatus(data.getId(),<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DiscussPost post = discussPostService.findDiscussPostByid(data.getId());</span><br><span class="line">        Assert.assertNotNull(post);</span><br><span class="line">        Assert.assertEquals(data.getTitle(), post.getTitle());</span><br><span class="line">        Assert.assertEquals(data.getContent(), post.getContent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = discussPostService.updateScore(data.getId(),<span class="number">2000.00</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>,row);</span><br><span class="line"></span><br><span class="line">        DiscussPost post = discussPostService.findDiscussPostByid(data.getId());</span><br><span class="line">        Assert.assertEquals(<span class="number">2000.00</span>,post.getScore(),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不通过会给出错误提示<br><img src="https://img-blog.csdnimg.cn/20200111141647680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="错误提示"></p>
<h1 id="项目监控"><a href="#项目监控" class="headerlink" title="项目监控"></a>项目监控</h1><p>项目的监控我们需要用到spring boot actuator来帮助我们监控项目，其核心是EndPoints,即监控程序应用入口，可以通过http或者jmx来访问得到。其默认开发的端口有很多，我们可以进行配置，下面的配置表示引入全部的端口，然后排除/info和/caches，当然我们可以自定义配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># actuator</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">info,caches</span></span><br></pre></td></tr></table></figure>
<h2 id="引入自定义端口"><a href="#引入自定义端口" class="headerlink" title="引入自定义端口"></a>引入自定义端口</h2><p>我们可以通过@EndPoint注解引入自定义端口，比如我们实现一个连接数据库的自定义端口，我们在@EndPoint注解中声明id来表示访问路径，然后在相应的方法使用@ReadOperation来表示访问的方法是GET（@WriteOperation表示POST）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint</span>(id = <span class="string">"database"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseEndPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DatabaseEndPoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">checkConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                Connection conn = dataSource.getConnection();</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>,<span class="string">"获取连接成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"获取连接失败："</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">400</span>,<span class="string">"获取连接失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><p>对于项目监控的端点路径我们必须设置权限，必须是管理员才能访问，因此我们需要对权限进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(</span><br><span class="line">        <span class="string">"/discuss/delete"</span>,</span><br><span class="line">        <span class="string">"/data/**"</span>,</span><br><span class="line">        <span class="string">"/actuator/**"</span></span><br><span class="line">)</span><br><span class="line">.hasAnyAuthority(</span><br><span class="line">        AUTHORITY_ADMIN</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>项目监控</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-17-优化服务器性能</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-17-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>一般来说我们优化服务器的性能会考虑从缓存入手，对于分布式服务器我们采用redis这样的分布式缓存，但是有些数据不用考虑分布式，此时我们可以引入本地缓存，这里我们用性能更好的Caffeine。</p>
<a id="more"></a>

<p>如图是缓存的一个基本结构，app得到一个请求时，会从本地缓存中查看，如果没有命中，就去DB获得数据同时同步本地缓存。但是对于类似用户Token这样的不区分服务器的数据时，我们就需要使用分布式缓存。总的来说，分布式缓存需要网络连接，因此性能上差一点。<br><img src="https://img-blog.csdnimg.cn/2020010916291555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="本地缓存和分布式缓存"></p>
<p>在我们的项目中我们对热门帖子列表做缓存，这是因为热门帖子是每五分钟计算一次分数，因此引入缓存是有必要的，而对于首页的帖子如果引入缓存，那么每次用户发布一个帖子是无法立刻看到自己的帖子的，但是如果缓存的更新速度太快，反而会影响效率。</p>
<p>对于什么数据采用什么缓存是需要思考的，不然可能会适得其反。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>对caffeine的配置我们只要配置一个缓存的最大值和过期时间即可，这是我们在项目中需要用到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># caffeine</span><br><span class="line">caffeine.posts.max-size=<span class="number">15</span></span><br><span class="line">caffeine.posts.expire-seconds=<span class="number">180</span></span><br></pre></td></tr></table></figure>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>这是一篇对caffeine进行简单但是详细介绍的<a href="https://jianshu.com/p/15d0a9ce37dd" target="_blank" rel="noopener">博客</a></p>
<p>在我们的项目中我们主要使用LoadingCache，是一个同步缓存会阻塞的接口。</p>
<p>声明两个分别表示帖子列表的缓存和帖子总数的缓存列表的LoadingCache实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 帖子列表的缓存</span></span><br><span class="line"><span class="keyword">private</span> LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帖子总数的缓存</span></span><br><span class="line"><span class="keyword">private</span> LoadingCache&lt;Integer, Integer&gt; postRowsCache;</span><br></pre></td></tr></table></figure>
<p>我们先不实例化这两个对象，先来看看怎么在原来的方法中使用，当是查询热门帖子列表的时候，直接使用postListCache.get()方法即可，该方法会得到该cache中的内容，如果过期或者没有内容的话会调用其load()方法得到数据返回并同步缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title">findDiscussPosts</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> offset,<span class="keyword">int</span> limit, <span class="keyword">int</span> orderMode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只有当查询首页的热门帖子时才使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (userId == <span class="number">0</span> &amp;&amp; orderMode == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没有查到会调用其load方法同步数据，这是阻塞的</span></span><br><span class="line">        <span class="keyword">return</span> postListCache.get(offset + <span class="string">":"</span> + limit);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.debug(<span class="string">"load post list from DB."</span>);</span><br><span class="line">    <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId,offset,limit,orderMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们就来初始化帖子列表的缓存，我们可以在@PostConstruct注解标注的init()方法中初始化。我们使用Caffeine提供的newBuilder()方法来设置缓存的最大容量和过期方式和时间，然后在build()中匿名实例化一个CacheLoader对象即可。在该方法中我们首先检查key是否合法，合法的话就得到offset和limit，然后这里我们使用二级缓存的方式，caffeine-&gt;redis-&gt;DB这样的方式。<br><img src="https://img-blog.csdnimg.cn/20200109165535812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="缓存访问顺序"></p>
<p>因此，当本地缓存不存在的时候，我们先去redis里查，如果redis里没有就去数据库里查到需要的数据，然后存入redis并设置过期时间，然后返回该数据即可，caffeine会将该数据作为缓存进行同步。如果redis中有，首先查看是否过期，如果过期了也是从数据库里查询然后同步到redis和caffeine中，如果没有过期就将redis中的数据作为结果返回。</p>
<p>redis对于过期数据的处理一般是惰性删除，即过期之后不立刻删除，等到下次读/写的时候才会将数据删除，因此其实可以不用写过期之后的处理，同没有该key是一样的，但是为了逻辑的完善还是写上去了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化帖子列表缓存</span></span><br><span class="line">postListCache = Caffeine.newBuilder()</span><br><span class="line">        .maximumSize(maxSize)</span><br><span class="line">        .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">        .build(<span class="keyword">new</span> CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title">load</span><span class="params">(@NonNull String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="keyword">null</span> || key.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                String[] params = key.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">if</span> (params == <span class="keyword">null</span> || params.length != <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> offset = Integer.valueOf(params[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> limit = Integer.valueOf(params[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 二级缓存：Redis -&gt; mysql</span></span><br><span class="line">                String redisKey = RedisKeyUtil.getHotPostListKey(offset,limit);</span><br><span class="line">                <span class="comment">// 如果redis中不存在就去数据库里查，查到了就更新到redis中，然后返回作为本地缓存的同步</span></span><br><span class="line">                <span class="keyword">if</span> (!redisTemplate.hasKey(redisKey))&#123;</span><br><span class="line">                    logger.debug(<span class="string">"redis中没有缓存"</span>);</span><br><span class="line">                    logger.debug(<span class="string">"load post list from DB."</span>);</span><br><span class="line">                    List&lt;DiscussPost&gt; result = discussPostMapper.selectDiscussPosts(<span class="number">0</span>,offset,limit,<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span>(DiscussPost post : result)&#123;</span><br><span class="line">                        redisTemplate.opsForZSet().add(redisKey,post,post.getScore());</span><br><span class="line">                    &#125;</span><br><span class="line">                    redisTemplate.expire(redisKey,<span class="number">15</span> ,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(<span class="string">"redis中有缓存"</span>);</span><br><span class="line">                    <span class="comment">// 要查看redis数据是否过期</span></span><br><span class="line">                    System.out.println(redisTemplate.getExpire(redisKey));</span><br><span class="line">                    <span class="keyword">boolean</span> isExpired = redisTemplate.getExpire(redisKey) &lt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isExpired)&#123;</span><br><span class="line">                        <span class="comment">// 如果过期的话，就删去key，就去数据库里查</span></span><br><span class="line">                        logger.debug(<span class="string">"redis expired!"</span>);</span><br><span class="line">                        redisTemplate.delete(redisKey);</span><br><span class="line">                        logger.debug(<span class="string">"load post list from DB."</span>);</span><br><span class="line">                        List&lt;DiscussPost&gt; result = discussPostMapper.selectDiscussPosts(<span class="number">0</span>,offset,limit,<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">for</span>(DiscussPost post : result)&#123;</span><br><span class="line">                            redisTemplate.opsForZSet().add(redisKey,post,post.getScore());</span><br><span class="line">                        &#125;</span><br><span class="line">                        redisTemplate.expire(redisKey,<span class="number">7</span>*<span class="number">60</span> ,TimeUnit.SECONDS);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Set&lt;DiscussPost&gt; posts = redisTemplate.opsForZSet().reverseRange(redisKey,offset,limit);</span><br><span class="line">                        logger.debug(<span class="string">"redis len: "</span> + redisTemplate.opsForZSet().zCard(redisKey));</span><br><span class="line">                        logger.debug(<span class="string">"load post list from redis."</span>);</span><br><span class="line">                        List&lt;DiscussPost&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        <span class="keyword">for</span>(DiscussPost post : posts)&#123;</span><br><span class="line">                            list.add(post);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> list;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这样就实现了对热门帖子的二级缓存，然后我们需要对缓存的性能进行简单的测试，这里我们使用jmeter进行测试，我们使用120个线程组以随机时间对不使用缓存的热门页进行访问，查看其吞吐量，然后以同样的条件访问带缓存的热门帖子进行对比吞吐量。<br><img src="https://img-blog.csdnimg.cn/20200109171851724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="有缓存"><br><img src="https://img-blog.csdnimg.cn/2020010917221465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="没有缓存的"></p>
<p>我们可以看到有缓存的吞吐量有200+，而没有缓存的吞吐量只有14不到，吞吐量的差距是十分巨大的。</p>
]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>优化性能</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-16-将文件上传至云服务器</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-16-%E5%B0%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%87%B3%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>我们常常有将文件上传云服务器的需求，尤其是对于图片这样的静态资源，这次我们需要实现的就是将用户头像上传至云服务器和将生成的长图也上传至云服务器。</p>
<p>对于上传有两种方式，一种是客户端上传，一种是服务器直传。</p>
<a id="more"></a>

<h2 id="客户端上传"><a href="#客户端上传" class="headerlink" title="客户端上传"></a>客户端上传</h2><p>对于头像这样的初始文件在用户本地的资源，我们采用的是客户端上传。这里我们使用的是七牛云，这是它对象存储的开发者中心<a href="https://developer.qiniu.com/kodo" target="_blank" rel="noopener">文档</a>。</p>
<p>我们首先来实现用户头像上传的功能，可以参考七牛云直传文件的<a href="https://developer.qiniu.com/kodo/api/1312/upload" target="_blank" rel="noopener">文档</a>。可以看到在请求的元素中上传凭证，文件名和文件是必须的。因此我们在后端需要做的就是构建上传凭证和文件名，然后前端读取文件，然后用js发送异步请求即可。</p>
<p>在收到setting请求时，我们通过UUID得到随机文件名，之所以不用用户id来做标识，是因为方便之后用户查看历史记录，同时也为了避免云服务器的缓存存在使得更改不会立即生效，但是用别的用户名就可以通过改变头像路径立即生效，然后使用七牛云提供的类和方法生成policy，”returnBody”用于设置如果上传成功，我们需要收到什么样的响应，这里我们设置为需要收到{“code”:200}的返回，然后生成Auth实例，使用create，传入私人的ak和sk构建授权，然后用该授权调用uploadToken得到具体的上传凭证，具体的API我们可以在七牛云的<a href="https://developer.qiniu.com/kodo/sdk/1239/java#simple-uptoken" target="_blank" rel="noopener">Java SDK</a>中看到，最后我们把上传凭证和文件名放入model中传给模板即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/setting"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSettingPage</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 上传文件的名称</span></span><br><span class="line">    <span class="comment">// 避免缓存影响，并且能有历史记录</span></span><br><span class="line">    String fileName = CommunityUtil.generateUUID();</span><br><span class="line">    <span class="comment">// 设置响应信息</span></span><br><span class="line">    StringMap policy = <span class="keyword">new</span> StringMap();</span><br><span class="line">    <span class="comment">// 成功会返回&#123;"code":200&#125;</span></span><br><span class="line">    policy.put(<span class="string">"returnBody"</span>, CommunityUtil.getJSONString(<span class="number">200</span>));</span><br><span class="line">    <span class="comment">// 生成上传凭证</span></span><br><span class="line">    Auth auth = Auth.create(accessKey,secretKey);</span><br><span class="line">    String uploadToken = auth.uploadToken(headerBucketName, fileName, <span class="number">3600</span>, policy);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"uploadToken"</span>,uploadToken);</span><br><span class="line">    model.addAttribute(<span class="string">"fileName"</span>,fileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/site/setting"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在前端需要写一个js来进行文件上传。</p>
<p>具体就是为表单的submit指定为upload方法，upload方法返回false，表示执行完upload方法的内容，就不用执行接下来的逻辑了。</p>
<p>在upload方法中，我们使用ajax，向七牛云上传文件，如果成功的话，我们就发出请求来更新用户头像，具体就是传入当前的文件名，然后交给服务器处理，如果更新成功，我们就刷新页面即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#uploadForm"</span>).submit(upload);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">"http://upload-z1.qiniup.com"</span>,</span><br><span class="line">        method: <span class="string">"post"</span>,</span><br><span class="line">        <span class="comment">// 不要将文件转成字符串</span></span><br><span class="line">        processData: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 让浏览器自己处理</span></span><br><span class="line">        contentType: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 数据为表单</span></span><br><span class="line">        data: <span class="keyword">new</span> FormData($(<span class="string">"#uploadForm"</span>)[<span class="number">0</span>]),</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data &amp;&amp; data.code == <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="comment">// 更新头像路径</span></span><br><span class="line">                $.post(</span><br><span class="line">                    CONTEXT_PATH + <span class="string">"/user/header/url"</span>,</span><br><span class="line">                    &#123;<span class="string">"fileName"</span>:$(<span class="string">"input[name='key']"</span>).val()&#125;,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        data = $.parseJSON(data);</span><br><span class="line">                        <span class="keyword">if</span> (data.code == <span class="number">200</span>)&#123;</span><br><span class="line">                            <span class="built_in">window</span>.location.reload();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            alert(data.msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"上传失败！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而服务器更新用户头像就是将申请的七牛云的存头像的域名+文件名即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新头像的路径</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/header/url"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateHeaderUrl</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(fileName))&#123;</span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">"文件名不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String url = headerBucketUrl+<span class="string">"/"</span>+fileName;</span><br><span class="line">    userService.updateHeader(hostHolder.getUser().getId(),url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务器直传"><a href="#服务器直传" class="headerlink" title="服务器直传"></a>服务器直传</h2><p>对于生成长图我们是在服务器本地生成的长图，因此需要由服务器直传。</p>
<p>生成长图是放入消息队列中的，因此对于Controller层，我们只要将图片路径改一下就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回访问路径</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// map.put("shareUrl", domain + contextPath + "/share/image/" + fileName);</span></span><br><span class="line">map.put(<span class="string">"shareUrl"</span>,shareBucketUrl + <span class="string">"/"</span> + fileName);</span><br></pre></td></tr></table></figure>
<p>在消费生成长图事件的方法中，我们需要有一个定时任务去查询长图是否生成了，如果生成了就将它上传至云服务器中，每隔500ms去查询一次，当然有可能出现错误，我们可以设置一个超时时间和上传次数，如果时间超过30s还没有生成，那么肯定是生成出现问题了，直接结束定时任务，而上传次数超过三次，我们也认为无法上传成功，直接结束任务。</p>
<p>同时，在kafka消费事件的地方，我们不用quartz来实现多线程，因为不会存在分布式时不一致的问题，kafka对于每个事件只会有一个服务器去处理，因此可以用线程池来做。</p>
<p>我们实现一个任务来完成这个逻辑，我们需要得到文件的后缀名、文件用于上传，Future用于结束任务，开始时间用于计算是否超时，上传次数用于判断上传是否失败。在构造方法中我们初始化文件名和开始时间，然后用setFutue将任务的Future实例设置为它本身的future，然后在run()方法中判断是否失败，如果失败了就将任务取消，如果还没有失败，就查询文件是否存在，存在的话就依次设置响应信息，上传凭证和机房路径，然后上传，根据响应结果，如果成功就结束任务，如果失败就继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="comment">// 文件后缀</span></span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line">    <span class="comment">// 启动任务的返回值</span></span><br><span class="line">    <span class="keyword">private</span> Future future;</span><br><span class="line">    <span class="comment">// 开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="comment">// 上传次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uploadTimes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadTask</span><span class="params">(String fileName, String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFuture</span><span class="params">(Future future)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.future = future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成图片失败</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; <span class="number">30000</span>)&#123;</span><br><span class="line">            logger.error(<span class="string">"执行时间过长，终止任务："</span> + fileName);</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上传失败</span></span><br><span class="line">        <span class="keyword">if</span> (uploadTimes &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            logger.error(<span class="string">"上传次数过多，终止任务："</span> + fileName);</span><br><span class="line">            future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = wkImageStorage + <span class="string">"/"</span> + fileName + suffix;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">            logger.info(String.format(<span class="string">"开始第%d次上传[%s]"</span>, ++uploadTimes,fileName));</span><br><span class="line">            <span class="comment">// 设置响应信息</span></span><br><span class="line">            StringMap policy = <span class="keyword">new</span> StringMap();</span><br><span class="line">            policy.put(<span class="string">"returnBody"</span>, CommunityUtil.getJSONString(<span class="number">200</span>));</span><br><span class="line">            <span class="comment">// 生成上传凭证</span></span><br><span class="line">            Auth auth = Auth.create(accessKey,secretKey);</span><br><span class="line">            String uploadToken = auth.uploadToken(shareBucketName,fileName,<span class="number">3600</span>,policy);</span><br><span class="line">            <span class="comment">// 指定上传机房</span></span><br><span class="line">            UploadManager manager = <span class="keyword">new</span> UploadManager(<span class="keyword">new</span> Configuration(Zone.zone1()));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 开始上传图片</span></span><br><span class="line">                Response response = manager.put(</span><br><span class="line">                        path, fileName, uploadToken, <span class="keyword">null</span>, <span class="string">"image/"</span> + suffix, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 处理响应结果</span></span><br><span class="line">                JSONObject json = JSONObject.parseObject(response.bodyString());</span><br><span class="line">                <span class="keyword">if</span> (json == <span class="keyword">null</span> || json.get(<span class="string">"code"</span>) == <span class="keyword">null</span> || !json.get(<span class="string">"code"</span>).toString().equals(<span class="string">"200"</span>))&#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"第%d次上传失败[%s]"</span>,uploadTimes,fileName));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">"第%d次上传成功[%s]"</span>,uploadTimes,fileName));</span><br><span class="line">                    future.cancel(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (QiniuException e)&#123;</span><br><span class="line">                logger.info(String.format(<span class="string">"第%d次上传失败[%s]"</span>,uploadTimes,fileName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"等待图片生成["</span>+fileName+<span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消费事件方法中，我们这样执行任务：实例化一个task，然后使用Spring可执行定时任务的线程池执行该任务，由于是异步任务，因此可以得到该任务的Future实例，然后设置task的future。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UploadTask task = <span class="keyword">new</span> UploadTask(fileName,suffix);</span><br><span class="line">Future future = taskScheduler.scheduleAtFixedRate(task, <span class="number">500</span>);</span><br><span class="line">task.setFuture(future);</span><br></pre></td></tr></table></figure>
<p>在上传文件的时候遇到了HTTPS的证书问题，通过查看七牛云SDK的源码找到了https上传的url生成SSL证书进行解决。（太坑了！官方手册的URL不一样！）</p>
]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>上传至云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-15-生成长图</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-15-%E7%94%9F%E6%88%90%E9%95%BF%E5%9B%BE/</url>
    <content><![CDATA[<p>在我们使用app的时候有很多情况需要分享，比如背单词每日打卡，而分享实际上就是将当前页面截图然后保存下来，这里我们就需要模拟APP来实现Web的生成长图并查看。</p>
<a id="more"></a>

<p>在这里我们需要用到wkhtmltopdf，这是一个将html页面转换成image或者pdf的工具，具体命令是类似wkhtmltoimage –quality 75 <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> d:/work/data，其中wkhtmltoimage表示将html转换成image，–quality 75表示将图片压缩到75%，再后面跟的是html的url和图片保存的路径。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在配置上我们需要将wkhtmltopdf的指令和路径配置到application.properties中</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wk</span></span><br><span class="line"><span class="meta">wk.image.command</span>=<span class="string">d:/work/wkhtmltopdf/bin/wkhtmltoimage</span></span><br><span class="line"><span class="meta">wk.image.storage</span>=<span class="string">d:/work/data/wk-images</span></span><br></pre></td></tr></table></figure>
<p>然后，wkhtmltopdf并不会自己创建目录，因此我们要确保目录是存在的。我们可以写一个config类，然后写一个初始化方法，使用@PostConstruct注解确保只会在服务启动时初始化一次，在该方法中检查路径是否存在，不存在就创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WkConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WkConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;wk.image.storage&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String wkImageStorage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建WK图片目录</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(wkImageStorage);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">            logger.info(<span class="string">"创建WK图片目录："</span> + wkImageStorage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>我们采用消息队列来实现生成长图功能，当controller收到一个生成长图的请求时我们将任务放入消息队列中，然后然后一个可以访问图片的路径即可。</p>
<p>这里为了简便，我们就要求用户将路径以参数的方式传过来，我们获取url，然后使用UUID生成随机的文件名，将这些参数放入Event实例中，然后返回一个带长图路径的map即可，对于路径我们设置为domain + contextPath + “/share/image/“ + fileName。</p>
<p>然后我们在写一个Controller用于输出png文件即可。这里和之前显示头像是一致的。具体就是用File指向文件，然后使用FileInputStream装饰File实例，将内容读取到byte数组buffer中去，然后再将buffer数组中的写到response的OutputStream输出流实例中，循环中读取完全部数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareController</span> <span class="keyword">implements</span> <span class="title">CommunityConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShareController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EventProducer eventProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;community.path.domain&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.servlet.context-path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String contextPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;wk.image.storage&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String wkImageStorage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/share"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">share</span><span class="params">(String htmlUrl)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 文件名</span></span><br><span class="line">        String fileName = CommunityUtil.generateUUID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步生成长图</span></span><br><span class="line">        Event event = <span class="keyword">new</span> Event()</span><br><span class="line">                .setTopic(TOPIC_SHARE)</span><br><span class="line">                .setData(<span class="string">"htmlUrl"</span>,htmlUrl)</span><br><span class="line">                .setData(<span class="string">"fileName"</span>,fileName)</span><br><span class="line">                .setData(<span class="string">"suffix"</span>,<span class="string">".png"</span>);</span><br><span class="line">        eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回访问路径</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"shareUrl"</span>, domain + contextPath + <span class="string">"/share/image/"</span> + fileName);</span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>,<span class="keyword">null</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取长图</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/share/image/&#123;fileName&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShareImage</span><span class="params">(@PathVariable(<span class="string">"fileName"</span>)</span> String fileName, HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(fileName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"文件名不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"image/png"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(wkImageStorage+<span class="string">"/"</span>+fileName+<span class="string">".png"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OutputStream os = response.getOutputStream();</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"获取长图失败:"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成长图"><a href="#生成长图" class="headerlink" title="生成长图"></a>生成长图</h2><p>我们需要消费Topic为share的任务来生成长图。</p>
<p>使用ConsumerRecord实例来获取event，检查空值和消息格式和之前一致，然后我们得到htmlUrl,fileName,suffix，拼接出wkhtmltoimage命令，然后调用Runtime.getRuntime().exec(cmd)即可，注意该语句是请求操作系统去执行cmd指令，因此是异步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费分享时间</span></span><br><span class="line"><span class="meta">@KafkaListener</span>(topics = TOPIC_SHARE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleShareMessage</span><span class="params">(ConsumerRecord record)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span> || record.value() == <span class="keyword">null</span> )&#123;</span><br><span class="line">        logger.error(<span class="string">"消息的内容为空！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event event = JSONObject.parseObject(record.value().toString(), Event<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>)&#123;</span><br><span class="line">        logger.error(<span class="string">"消息格式错误！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String htmlUrl = (String) event.getData().get(<span class="string">"htmlUrl"</span>);</span><br><span class="line">    String fileName = (String) event.getData().get(<span class="string">"fileName"</span>);</span><br><span class="line">    String suffix = (String) event.getData().get(<span class="string">"suffix"</span>);</span><br><span class="line"></span><br><span class="line">    String cmd = wkImageCommand + <span class="string">" --quality 75 "</span> + htmlUrl + <span class="string">" "</span> + wkImageStorage</span><br><span class="line">            + <span class="string">"/"</span> + fileName + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">        logger.info(<span class="string">"生成长图成功："</span> + cmd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"生成长图失败:"</span> + e.getMessage());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>生成长图</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-14-热帖排行</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-14-%E7%83%AD%E5%B8%96%E6%8E%92%E8%A1%8C/</url>
    <content><![CDATA[<p>我们需要实现首页对帖子进行排序的功能，具体就是计算每个帖子的分数，然后按分数降序排列。</p>
<a id="more"></a>

<p>因此，我们需要解决的是两个问题，第一个是如何计算帖子分数，第二个是在何时对帖子分数进行计算。</p>
<p>首先，计算帖子分数，我们希望发布越新的帖子的分数要更高一点，然后其变化能够平缓一点，不要出现分数骤降的情况。参考了牛客本身的公式，我们采用这样的公式<br>$$<br>socre=log(精华分数+评论数<em>10+点赞数</em>2)+（发布时间-牛客纪元）<br>$$<br>然后是第二个问题，我们何时进行计算，首先每个帖子在更新时进行计算肯定是没有必要的，因为这样对服务器压力太大了，比如一个热帖同时有100人点赞，那服务器就要计算100边，但是用到的只有最后一个结果。</p>
<p>因此，我们可以采用定时任务的方式进行，比如每隔一小时计算一次，因此我们需要确定的是哪些帖子需要进行计算，对其用redis进行缓存起来，所用的类型很显然是set，因为需要去重，并且不要求顺序。</p>
<p>在计算完成之后，我们需要更新mysql的数据、elasticsearch的数据。</p>
<p>首先，我们定义存储帖子的redis的key，采用post:score的键，然后所有需要计算的帖子放入即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 帖子分数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPostScoreKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_POST + SPLIT + <span class="string">"score"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们实现具体的job.该job需要实现Job接口的execute方法。首先，我们需要声明一个Date类型的值作为牛客纪元，然后在static块中初始化。</p>
<p>在execute方法中，我们使用BoundSetOperations实例来对set集合进行操作，判断set的大小，如果大于零，则调用refresh方法，参数为从set中弹出的一个Post实例。</p>
<p>在refresh方法中，我们得到是否加精、评论数量、点赞数量和发帖时间，然后对score进行计算，计算完成后我们更新帖子和elasticsearch服务器内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostScoreRefreshJob</span> <span class="keyword">implements</span> <span class="title">Job</span>, <span class="title">CommunityConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PostScoreRefreshJob<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LikeService likeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 牛客纪元</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Date epoch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            epoch = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2014-08-01 00:00:00"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"初始化牛客纪元失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        String redisKey = RedisKeyUtil.getPostScoreKey();</span><br><span class="line">        BoundSetOperations operations = redisTemplate.boundSetOps(redisKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (operations.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            logger.info(<span class="string">"任务取消，没有需要刷新的帖子！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"[任务开始] 正在刷新帖子分数："</span> + operations.size());</span><br><span class="line">        <span class="keyword">while</span> (operations.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.refresh((Integer) operations.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"[任务结束] 刷新帖子分数完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(<span class="keyword">int</span> postId)</span></span>&#123;</span><br><span class="line">        DiscussPost post = discussPostService.findDiscussPostByid(postId);</span><br><span class="line">        <span class="keyword">if</span> (post == <span class="keyword">null</span>)&#123;</span><br><span class="line">            logger.error(<span class="string">"该帖子不存在，id="</span>+postId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否加精</span></span><br><span class="line">        <span class="keyword">boolean</span> wonderful = post.getStatus() == <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 评论数量</span></span><br><span class="line">        <span class="keyword">int</span> commentCount = post.getCommentCount();</span><br><span class="line">        <span class="comment">// 点赞数量</span></span><br><span class="line">        <span class="keyword">long</span> likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST,postId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算权重</span></span><br><span class="line">        <span class="keyword">double</span> w = (wonderful? <span class="number">75</span> : <span class="number">0</span>) + commentCount * <span class="number">10</span> + likeCount * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分数 = 帖子权重 + 距离天数</span></span><br><span class="line">        <span class="keyword">double</span> score = Math.log10(Math.max(w, <span class="number">1</span>))</span><br><span class="line">                + (post.getCreateTime().getTime() - epoch.getTime()) / (<span class="number">1000</span>*<span class="number">3600</span>*<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新帖子分数</span></span><br><span class="line">        discussPostService.updateScore(postId,score);</span><br><span class="line">        <span class="comment">// 同步搜索数据</span></span><br><span class="line">        post.setScore(score);</span><br><span class="line">        elasticsearchService.saveDiscussPost(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们在何时将帖子加入redis缓存呢？首先就是发布帖子的时候，然后就是点赞、评论和加精处。<br>比如，在加精完成之后，我们将帖子加入redis中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加精</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/wonderful"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setWonderful</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    discussPostService.updateStatus(id,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发发帖事件</span></span><br><span class="line">    Event event = <span class="keyword">new</span> Event()</span><br><span class="line">            .setTopic(TOPIC_PUBLISH)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">            .setEntityId(id);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算帖子分数</span></span><br><span class="line">    String redisKey = RedisKeyUtil.getPostScoreKey();</span><br><span class="line">    redisTemplate.opsForSet().add(redisKey,id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时Job已经完全就绪了，然后我们需要对JobDetail和Trigger进行配置，配置步骤和上一篇<a href="https://blog.csdn.net/qq_41916811/article/details/103788705" target="_blank" rel="noopener">博客</a>同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刷新帖子分数任务</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobDetailFactoryBean <span class="title">postScoreRefreshJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    JobDetailFactoryBean factoryBean = <span class="keyword">new</span> JobDetailFactoryBean();</span><br><span class="line">    factoryBean.setJobClass(PostScoreRefreshJob<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    factoryBean.setName(<span class="string">"postScoreRefreshJob"</span>);</span><br><span class="line">    factoryBean.setGroup(<span class="string">"communityJobGroup"</span>);</span><br><span class="line">    <span class="comment">// 任务是否持久保存</span></span><br><span class="line">    factoryBean.setDurability(<span class="keyword">true</span>);</span><br><span class="line">    factoryBean.setRequestsRecovery(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleTriggerFactoryBean <span class="title">postScoreRefreshTrigger</span><span class="params">(JobDetail postScoreRefreshJobDetail)</span></span>&#123;</span><br><span class="line">    SimpleTriggerFactoryBean factoryBean = <span class="keyword">new</span> SimpleTriggerFactoryBean();</span><br><span class="line">    factoryBean.setJobDetail(postScoreRefreshJobDetail);</span><br><span class="line">    factoryBean.setName(<span class="string">"postScoreRefreshTrigger"</span>);</span><br><span class="line">    factoryBean.setGroup(<span class="string">"communityTriggerGroup"</span>);</span><br><span class="line">    factoryBean.setRepeatInterval(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">    factoryBean.setJobDataMap(<span class="keyword">new</span> JobDataMap());</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是展现，用户在首页点击最热可以查看按分数排名的帖子，因此我们需要对得到首页帖子的接口进行略微修改，我们需要引入一个排序模式参数，如果是1，我们就按热度进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;DiscussPost&gt; <span class="title">selectDiscussPosts</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> offset, <span class="keyword">int</span> limit, <span class="keyword">int</span> orderMode)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDiscussPosts"</span> <span class="attr">resultType</span>=<span class="string">"DiscussPost"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectFields"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from discuss_post</span><br><span class="line">    where status != 2</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userId!=0"</span>&gt;</span></span><br><span class="line">        and user_id = #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"orderMode==0"</span>&gt;</span></span><br><span class="line">        order by type desc, create_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"orderMode==1"</span>&gt;</span></span><br><span class="line">        order by type desc, score desc, create_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时在controller中我们需要修改一些细节，首先是得到orderMode参数，默认设为0，然后对分页路径加上orderMode参数，最后是往model中加入orderMode参数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIndexPage</span><span class="params">(Model model, Page page,</span></span></span><br><span class="line"><span class="function"><span class="params">                               @RequestParam(name = <span class="string">"orderMode"</span>, defaultValue = <span class="string">"0"</span>)</span> <span class="keyword">int</span> orderMode)</span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">......</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">**/</span></span></span><br><span class="line"><span class="function">page.<span class="title">setPath</span><span class="params">(<span class="string">"/index?orderMode="</span> + orderMode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">"orderMode"</span>,orderMode);</span><br></pre></td></tr></table></figure>
<p>最后是在模板中，我们对最新和最热按钮加上路径即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav nav-tabs mb-3"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:class</span>=<span class="string">"|nav-link $&#123;orderMode==0?'active':''&#125;|"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index(orderMode=0)&#125;"</span>&gt;</span>最新<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:class</span>=<span class="string">"|nav-link $&#123;orderMode==1?'active':''&#125;|"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/index(orderMode=1)&#125;"</span>&gt;</span>最热<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>热帖排行</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-13-Spring线程池和Quartz</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-13-Spring%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CQuartz/</url>
    <content><![CDATA[<p>对于线程池的相关内容可以查看<a href="https://blog.csdn.net/qq_41916811/article/details/103745937" target="_blank" rel="noopener">线程管理</a>和<a href="https://blog.csdn.net/qq_41916811/article/details/103768949" target="_blank" rel="noopener">Java异步编程</a></p>
<p>这里主要是对SpringBoot的线程池使用和Quartz使用进行简单的介绍</p>
<a id="more"></a>

<h1 id="SpringBoot线程池"><a href="#SpringBoot线程池" class="headerlink" title="SpringBoot线程池"></a>SpringBoot线程池</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我们主要对线程池的核心线程数、最大线程数和工作队列大小进行配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TaskExecutionProperties</span></span><br><span class="line"><span class="comment">#  随着客户端不断提交任务，当前线程池大小也相应增加。在当前线程池大小达到核心线程池大小的时候，</span></span><br><span class="line"><span class="comment">#  新来的任务会被存入到工作者队列中。当工作队列满的时候，线程池会继续创建新的工作者线程，</span></span><br><span class="line"><span class="comment">#  直到当前线程池大小达到最大线程池大小。当线程池饱和时，</span></span><br><span class="line"><span class="comment">#  即工作者队列已满且当前线程池大小达到最大线程池的情况下，客户端试图提交任务会被拒绝。</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.core-size</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>=<span class="string">15</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TaskSchedulingProperties</span></span><br><span class="line"><span class="meta">spring.task.scheduling.pool.size</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>
<p>然后声明一个配置类，使用@EnableScheduling和@EnableAsync注解启动定时和异步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>然后在具体的task上面使用@Async表示是异步操作，@Schedule表示是定时任务，initialDelay表示启动延迟，fixedRate表示两次任务开始的间隔，单位都是毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以让该方法在多线程环境下被异步调用</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"execute1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled</span>(initialDelay = <span class="number">10000</span>, fixedRate = <span class="number">1000</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    logger.debug(<span class="string">"execute1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>对于异步任务我们只要直接调用任务即可，而定时任务不需要调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadPoolTaskExecutorSimple</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        alphaService.execute1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><p>quartz有三个要素，分别是Schedule、Trigger和JobDetail+Job</p>
<ol>
<li>Scheduler：调度器。所有的调度都是由它控制。</li>
<li>Trigger： 触发器。决定什么时候来执行任务。</li>
<li>JobDetail &amp; Job： JobDetail定义的是任务数据，而真正的执行逻辑是在Job中。使用JobDetail + Job而不是Job，这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2>quartz能够在分布式的时候很好地解决就是因为引入了数据库，这样就能做到数据同步了。具体分布如下<br><img src="https://img-blog.csdnimg.cn/2019123121143414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="Quartz"></li>
</ol>
<p>我们在application.properties中需要对持久化存储进行配置，而DB中的表可以从官网下载得到<br><img src="https://img-blog.csdnimg.cn/2019123121163662.png" alt="quartz数据表"></p>
<p>我们主要对jobStore和threadPool的实现类和驱动进行配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># QuartzProperties</span></span><br><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br><span class="line"><span class="meta">spring.quartz.scheduler-name</span>=<span class="string">communityScheduler</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.scheduler.instanceId</span>=<span class="string">AUTO</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.jobStore.class</span>=<span class="string">org.quartz.impl.jdbcjobstore.JobStoreTX</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.jobStore.driverDelegateClass</span>=<span class="string">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.jobStore.isClustered</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.threadPool.class</span>=<span class="string">org.quartz.simpl.SimpleThreadPool</span></span><br><span class="line"><span class="meta">spring.quartz.properties.org.quartz.threadPool.threadCount</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现对quartz配置的持久化存储，否则程序会从内存中得到quartz的配置信息。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接下来，我们定义一个简单的Job,实现Job接口，即实现execute方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlphaJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": execute a quartz job."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们还需要对JobDetail和Trigger进行配置，这些配置在运行之后会被写入数据库进行存储。</p>
<p>配置JobDetail我们使用JobDetailFactoryBean实例，该实例封装了JobDetail的实例化过程，我们只要配置setJobClass（指定任务），设置名字，设置组名和任务是否永久存储、任务是否可以恢复等参数即可完成对JobDetailFactoryBean的配置，然后该实例中就会有一个按我们配置的JobDetail。</p>
<p>配置Trigger我们也是使用SimpleTriggerFactoryBean，传入JobDetailFactoryBean得到它管理的JobDetail，然后设置setJobDetail、setName、setGroup、重复频率和JobDataMap（不太清楚）即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FactoryBean可简化Bean的实例化过程:</span></span><br><span class="line">    <span class="comment">// 1.通过FactoryBean封装Bean的实例化过程</span></span><br><span class="line">    <span class="comment">// 2.将FactoryBean装配到容器里</span></span><br><span class="line">    <span class="comment">// 3.将FactoryBean注入给其他的Bean</span></span><br><span class="line">    <span class="comment">// 4.该Bean得到的是FactoryBean所管理的对象实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置JobDetail</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JobDetailFactoryBean <span class="title">alphaJobDetail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JobDetailFactoryBean factoryBean = <span class="keyword">new</span> JobDetailFactoryBean();</span><br><span class="line">        factoryBean.setJobClass(AlphaJob<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        factoryBean.setName(<span class="string">"alphaJob"</span>);</span><br><span class="line">        factoryBean.setGroup(<span class="string">"alphaJobGroup"</span>);</span><br><span class="line">        <span class="comment">// 任务是否持久保存</span></span><br><span class="line">        factoryBean.setDurability(<span class="keyword">true</span>);</span><br><span class="line">        factoryBean.setRequestsRecovery(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Trigger() SimpleTriggerFactoryBean CronTriggerFactoryBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleTriggerFactoryBean <span class="title">alphaTrigger</span><span class="params">(JobDetail alphaJobDetail)</span></span>&#123;</span><br><span class="line">        SimpleTriggerFactoryBean factoryBean = <span class="keyword">new</span> SimpleTriggerFactoryBean();</span><br><span class="line">        factoryBean.setJobDetail(alphaJobDetail);</span><br><span class="line">        factoryBean.setName(<span class="string">"alphaTrigger"</span>);</span><br><span class="line">        factoryBean.setGroup(<span class="string">"alphaTriggerGroup"</span>);</span><br><span class="line">        factoryBean.setRepeatInterval(<span class="number">3000</span>);</span><br><span class="line">        factoryBean.setJobDataMap(<span class="keyword">new</span> JobDataMap());</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时启动程序，Quartz管理的任务就会自动执行，同时数据库中会有数据被存储。</p>
<p>当然我们也可以删除任务，调用schedule的deleteJob删除方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> result = scheduler.deleteJob(<span class="keyword">new</span> JobKey(<span class="string">"alphaJob"</span>,<span class="string">"alphaJobGroup"</span>));</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-12-统计数据，Redis高级数据结构</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-12-%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%EF%BC%8CRedis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>我们网站需要统计UV（独立访客）和DAU（每日活跃用户）。对于UV我们以每个ip的访问作为一次有效访问，同一个ip的多次访问算做一次，而DAU我们以每个用户id为一次有效访问。</p>
<a id="more"></a>

<p>对于统计，我们使用redis作为我们的数据库，对于UV我们采用HyperLoglog作为数据类型，Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的，但是标准误差是 0.81%。一般每个 HyperLogLog 键只需要花费 12 KB 内存。对于DAU，我们使用bitmap来统计，用户访问过就将以用户id为下标的位置为1即可。</p>
<h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><p>在service层我们需要实现4个方法，分别是将ip计入AU，按时间统计AU，将用户id计入DAU，按时间统计DAU。</p>
<p>对于单日UV,我们设计这样的redisKey——uv:date，而对于区间UV，我们设计这样的redisKey——uv:startDate:endDate。</p>
<p>将ip计入UV，我们首先根据日期得到key，使用redisTemplate.opsForHyperLoglog.add将ip加入redis中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将指定的IP计入UV</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUV</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">    String redisKey = RedisKeyUtil.getUVKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    redisTemplate.opsForHyperLogLog().add(redisKey,ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于统计时间区间内的uv，我们需要使用redisTemplate.opsForHyperLoglog().union()，需要两个参数，一个是合并后的数据的redisKey，另一个是需要合并的redisKey列表。因此我们要做的就是将传入的startDate，endDate转成一个日期列表。使用Calendar来将实例设置为start，然后每次加一天，直到当前时间在end之后。合并数据完成之后，我们使用size()放回hyperLogLog的大小就是我们需要的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计指定日期范围内的UV</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">calculateUV</span><span class="params">(Date start,Date end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="keyword">null</span> || end == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整理该日期范围内的key</span></span><br><span class="line">    List&lt;String&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTime(start);</span><br><span class="line">    <span class="keyword">while</span> (!calendar.getTime().after(end))&#123;</span><br><span class="line">        keyList.add(RedisKeyUtil.getUVKey(df.format(calendar.getTime())));</span><br><span class="line">        calendar.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并数据</span></span><br><span class="line">    String redisKey = RedisKeyUtil.getUVKey(df.format(start),df.format(end));</span><br><span class="line">    redisTemplate.opsForHyperLogLog().union(redisKey, keyList.toArray());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回统计结果</span></span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHyperLogLog().size(redisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将用户id计入DAU，我们只要使用redisTemplate.opsForValue().setBit()方法即可，将以用户id为下表的那一位置为1即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将指定用户计入DAU</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordDAU</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    String redisKey = RedisKeyUtil.getDAUKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    redisTemplate.opsForValue().setBit(redisKey, userId, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计时间区内的DAU我们需要使用redisTemplate的连接操作，同样的需要一个redisKey的数组。但是该数组的类型需要为byte[]，而进行OR运算我们需要用到redisTemplate.execute，并且使用一个RedisCallback实例作为参数，并把其doInRedis方法的结果作为返回值。在该方法中有一个RedisConnection参数，而我们就是利用该参数进行位运算，选择OR运算，再传入作为结果的redisKey和需要运算的redisKey的列表即可，然后使用connection.bitCount()得到为true的全部位数之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统计指定日期范围内的DAU</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">calculateDAU</span><span class="params">(Date start,Date end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="keyword">null</span> || end == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整理该日期范围内的key</span></span><br><span class="line">    List&lt;<span class="keyword">byte</span>[]&gt; keyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTime(start);</span><br><span class="line">    <span class="keyword">while</span> (!calendar.getTime().after(end))&#123;</span><br><span class="line">        keyList.add(RedisKeyUtil.getDAUKey(df.format(calendar.getTime())).getBytes());</span><br><span class="line">        calendar.add(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行OR运算</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>) redisTemplate.execute(<span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            String redisKey = RedisKeyUtil.getDAUKey(df.format(start),df.format(end));</span><br><span class="line">            connection.bitOp(RedisStringCommands.BitOperation.OR,</span><br><span class="line">                    redisKey.getBytes(),keyList.toArray(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">return</span> connection.bitCount(redisKey.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>在controller层，首先我们要增加UV和DAU，因此我们需要新建一个拦截器，在请求之前更新UV和DAU。使用request.getRemoteHost()得到用户ip，然后加入UV即可，如果用户登录了的话，就将用户计入DAU。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataService dataService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 统计UV</span></span><br><span class="line">        String ip = request.getRemoteHost();</span><br><span class="line">        dataService.recordUV(ip);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计DAU</span></span><br><span class="line">        User user = hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            dataService.recordDAU(user.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在统计数据时，我们使用@DateTimeFormat(pattern = “yyyy-MM-dd”)得到前端传过来的startDate和endDate，然后调用dataService计算UV方法即可，然后加入到model中，再转发给/data请求继续处理，而/data请求其实就是渲染data.html页面，统计活跃用户也是同理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataService dataService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计页面</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/data"</span>,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDataPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/admin/data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计网站UV</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/data/uv"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUV</span><span class="params">(@DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd"</span>)</span> Date start,</span></span><br><span class="line"><span class="function">                        @<span class="title">DateTimeFormat</span><span class="params">(pattern = <span class="string">"yyyy-MM-dd"</span>)</span> Date end, Model model)</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> uv = dataService.calculateUV(start,end);</span><br><span class="line">        model.addAttribute(<span class="string">"uvResult"</span>,uv);</span><br><span class="line">        model.addAttribute(<span class="string">"uvStartDate"</span>,start);</span><br><span class="line">        model.addAttribute(<span class="string">"uvEndDate"</span>,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计活跃用户</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/data/dau"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDAU</span><span class="params">(@DateTimeFormat(pattern = <span class="string">"yyyy-MM-dd"</span>)</span> Date start,</span></span><br><span class="line"><span class="function">                        @<span class="title">DateTimeFormat</span><span class="params">(pattern = <span class="string">"yyyy-MM-dd"</span>)</span> Date end, Model model)</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> dau = dataService.calculateDAU(start,end);</span><br><span class="line">        model.addAttribute(<span class="string">"dauResult"</span>,dau);</span><br><span class="line">        model.addAttribute(<span class="string">"dauStartDate"</span>,start);</span><br><span class="line">        model.addAttribute(<span class="string">"dauEndDate"</span>,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/data"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>统计数据</tag>
        <tag>redis高级数据</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-11-置顶、加精、删除</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-11-%E7%BD%AE%E9%A1%B6%E3%80%81%E5%8A%A0%E7%B2%BE%E3%80%81%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<p>对于帖子进行置顶、加精和删除，其实就是对帖子的type和status进行修改，本质上来说就是对帖子数据的修改，但是这里涉及到权限问题，只有版主能对帖子进行置顶和加精，只有管理员能对帖子进行删除。</p>
<a id="more"></a>

<h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><p>在dao层我们只需增加两个两个更新方法,根据id进行修改即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateType</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateStatus</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>在service层调用dao层方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateType</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discussPostMapper.updateType(id,type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateStatus</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> status)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discussPostMapper.updateStatus(id,status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>在controller层，我们调用service层方法即可，同时对于置顶和加精我们要触发发帖事件，将帖子同步到elasticsearch服务器中，而删除我们要触发删帖事件，将elasticsearch服务器中的帖子删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置顶</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/top"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setTop</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    discussPostService.updateType(id,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发发帖事件</span></span><br><span class="line">    Event event = <span class="keyword">new</span> Event()</span><br><span class="line">            .setTopic(TOPIC_PUBLISH)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">            .setEntityId(id);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加精</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/wonderful"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setWonderful</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    discussPostService.updateStatus(id,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发发帖事件</span></span><br><span class="line">    Event event = <span class="keyword">new</span> Event()</span><br><span class="line">            .setTopic(TOPIC_PUBLISH)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">            .setEntityId(id);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/delete"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setDelete</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    discussPostService.updateStatus(id,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发删帖事件</span></span><br><span class="line">    Event event = <span class="keyword">new</span> Event()</span><br><span class="line">            .setTopic(TOPIC_DELETE)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">            .setEntityId(id);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们需要新建一个删除帖子的消费者,直接调用elasticsearchService的delete方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费删帖事件</span></span><br><span class="line"><span class="meta">@KafkaListener</span>(topics = &#123;TOPIC_DELETE&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDeleteMessage</span><span class="params">(ConsumerRecord record)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span> || record.value() == <span class="keyword">null</span> )&#123;</span><br><span class="line">        logger.error(<span class="string">"消息的内容为空！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event event = JSONObject.parseObject(record.value().toString(), Event<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>)&#123;</span><br><span class="line">        logger.error(<span class="string">"消息格式错误！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elasticsearchService.deleteDiscussPost(event.getEntityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>然后，我们在js中实现异步请求逻辑即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 置顶</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.post(</span><br><span class="line">        CONTEXT_PATH + <span class="string">"/discuss/top"</span>,</span><br><span class="line">        &#123;<span class="string">"id"</span>:$(<span class="string">"#postId"</span>).val()&#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            data = $.parseJSON(data);</span><br><span class="line">            <span class="keyword">if</span> (data.code == <span class="number">200</span>)&#123;</span><br><span class="line">                $(<span class="string">"#topBtn"</span>).attr(<span class="string">"disabled"</span>,<span class="string">"disabled"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加精</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setWonderful</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.post(</span><br><span class="line">        CONTEXT_PATH + <span class="string">"/discuss/wonderful"</span>,</span><br><span class="line">        &#123;<span class="string">"id"</span>:$(<span class="string">"#postId"</span>).val()&#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            data = $.parseJSON(data);</span><br><span class="line">            <span class="keyword">if</span> (data.code == <span class="number">200</span>)&#123;</span><br><span class="line">                $(<span class="string">"#wonderfulBtn"</span>).attr(<span class="string">"disabled"</span>,<span class="string">"disabled"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDelete</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.post(</span><br><span class="line">        CONTEXT_PATH + <span class="string">"/discuss/delete"</span>,</span><br><span class="line">        &#123;<span class="string">"id"</span>:$(<span class="string">"#postId"</span>).val()&#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            data = $.parseJSON(data);</span><br><span class="line">            <span class="keyword">if</span> (data.code == <span class="number">200</span>)&#123;</span><br><span class="line">                location.href = CONTEXT_PATH + <span class="string">"/index"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(data.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>我们实现了所有的基本功能之后就可以加入权限控制了，主要是在SecurityConfig中配置即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(</span><br><span class="line">        <span class="string">"/discuss/top"</span>,</span><br><span class="line">        <span class="string">"/discuss/wonderful"</span></span><br><span class="line">)</span><br><span class="line">.hasAnyAuthority(</span><br><span class="line">        AUTHORITY_MODERATOR</span><br><span class="line">)</span><br><span class="line">.antMatchers(</span><br><span class="line">        <span class="string">"/discuss/delete"</span></span><br><span class="line">)</span><br><span class="line">.hasAnyAuthority(</span><br><span class="line">        AUTHORITY_ADMIN</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>配置完成之后权限就配置完成了，但是还有一些细节，如果用户没有权限就不要显示按钮。thymelead对于spring security是支持的，但我们需要导入一个pom包，然后在HTML中配置即可,通过使用sec:authorize=”hasAnyAuthority(‘xx’)”即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float-right"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"postId"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;post.id&#125;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-danger btn-sm"</span> <span class="attr">id</span>=<span class="string">"topBtn"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">th:disabled</span>=<span class="string">"$&#123;post.type==1&#125;"</span> <span class="attr">sec:authorize</span>=<span class="string">"hasAnyAuthority('moderator')"</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-danger btn-sm"</span> <span class="attr">id</span>=<span class="string">"wonderfulBtn"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">th:disabled</span>=<span class="string">"$&#123;post.status==1&#125;"</span> <span class="attr">sec:authorize</span>=<span class="string">"hasAnyAuthority('moderator')"</span>&gt;</span>加精<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-danger btn-sm"</span> <span class="attr">id</span>=<span class="string">"deleteBtn"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">th:disabled</span>=<span class="string">"$&#123;post.status==2&#125;"</span> <span class="attr">sec:authorize</span>=<span class="string">"hasAnyAuthority('admin')"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>置顶</tag>
        <tag>加精</tag>
        <tag>删除</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-10-Spring-Security</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-10-Spring-Security/</url>
    <content><![CDATA[<p>当引入spring security的依赖之后，spring security就会对我们项目的登录和权限进行接管，因此在接入我们系统之前，我们先使用一个demo进行实验。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20191228163838328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt=""></p>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>很显然，spring security的实体类应该是User类，相较于之前的User类，引入Spring Security之后，我们要让User类实现UserDetails接口，要实现五个方法，分别是账号是否过期，账号是否锁定，凭证是否过期，账号是否可用，以及得到权限。</p>
<p>对于前四个方法我们不用做特殊处理，直接返回true即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true: 账号未过期</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true: 账号未锁定</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true: 凭证未过期</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true: 账号可用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于获得权限的方法，我们主要根据数据库中user表的type字段得到权限。因为返回的是GrantedAuthority子类型的集合，而我们一个用户只有一个角色，因此我们声明一个list，往里面加入一个GrantedAuthority实例即可，采用匿名实现的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到权限</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">    List&lt;GrantedAuthority&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> GrantedAuthority()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"ADMIN"</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"USER"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>对于service层，我们需要UserService实现UserDetailsService接口，该接口主要实现一个方法，loadUserByUsername()，这里我们直接调用mapper接口即可。同时由于实体类已经实现了UserDetails接口，因此这里可以直接返回User类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findUserByName(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>我们需要定义一个Security的配置类，该类继承自WebSecurityConfigurerAdapter，而我们需要重写一些方法。</p>
<p>首先是对静态资源我们不做拦截，该方法的参数是WebSecurity，我们设置对/resources目录下的资源都不做拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略静态资源的访问</span></span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二，就是要配置验证账号密码的方法了，该方法的参数是AuthenticationManagerBuilder实例，根据名字就知道这是一个构造AuthenticationManager的构造器，而AuthenticationManager是我们认证的核心接口。<br>本来我们可以使用spring security提供的passwordEncoder来进行验证，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置的认证规则</span></span><br><span class="line">auth.userDetailsService(userService).passwordEncoder(<span class="keyword">new</span> Pbkdf2PasswordEncoder(<span class="string">"12345"</span>));</span><br></pre></td></tr></table></figure>
<p>但是我们在密码中加入了不同的盐因此不太方便，因此需要自定义认证规则。自定义规则我们需要使用authenticationProvider方法，然后传入一个AuthenticationProvider实例即可。这是因为AuthenticationProvider是ProviderManager的元素，即一个ProviderManager有很多AuthenticationProvider实例，而一个AuthenticationProvider实例负责一种认证，即ProviderManager将认证委托给某个AuthenticationProvider，这是一种委托模式。而ProviderManager又是AuthenticationManager接口的默认实现类。</p>
<p><strong>总的来说我们需要AuthenticationManager接口来进行认证，这里我们使用它的默认实现类ProviderManager来进行认证，而该实现类需要AuthenticationProvider实例，因此我们使用builder构造器传入AuthenticationProvider即可。</strong></p>
<p>同样的，我们采用匿名的方式实现AuthenticationProvider实例，在我们的实现中，我们需要实现两个方法，分别是authenticate()和supports()，其中supports方法用于得到当前AuthenticationProvider实例支持的是哪种认证方式，这里我们支持的是UsernamePasswordAuthenticationToken认证，即用户名密码认证。</p>
<p>而authenticate()方法则就是用于认证，其参数Authentication实例封装了认证信息，不同的认证方式封装了不同的信息，这里很显然是用户名和密码，我们通过getName和getCredentials得到用户名密码，然后进行验证，如果不正确抛出相应的异常即可，Filter会进行处理。如果认证通过，我们也需要返回一个Authentication实例，但是是一个认证通过的实例，也就是一个Token，这里我们使用的是UsernamePasswordAuthenticationToken类，该类的构造函数需要传入三个参数，分别是principal，即通过认证的主要信息；credentials，即证书；authorities，即权限。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuthenticationManager: 认证的核心接口</span></span><br><span class="line"><span class="comment">// AuthenticationManagerBuilder: 用于构建AuthenticationManager对象</span></span><br><span class="line"><span class="comment">// ProviderManager: AuthenticationManager接口的默认实现类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 内置的认证规则</span></span><br><span class="line">    <span class="comment">// auth.userDetailsService(userService).passwordEncoder(new Pbkdf2PasswordEncoder("12345"));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义认证规则</span></span><br><span class="line">    <span class="comment">// AuthenticationProvider: ProviderManager持有一组AuthenticationProvider，每个AuthenticationProvider负责一种认证</span></span><br><span class="line">    <span class="comment">// 委托模式：ProviderManager将认证委托给了AuthenticationProvider.</span></span><br><span class="line">    auth.authenticationProvider(<span class="keyword">new</span> AuthenticationProvider() &#123;</span><br><span class="line">        <span class="comment">// Authentication: 用于封装认证信息的接口，不同的实现类代表不同的类型的认证信息</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">            String username = authentication.getName();</span><br><span class="line">            String password = (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">            User user = userService.findUserByName(username);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"账号不存在！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            password = CommunityUtil.md5(password + user.getSalt());</span><br><span class="line">            <span class="keyword">if</span> (!user.getPassword().equals(password))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="string">"密码不正确！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// principal: 认证的主要信息; credentials: 证书; authorities: 权限;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user, user.getPassword(), user.getAuthorities());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前AuthenticationProvider支持哪种类型的认证</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// UsernamePasswordAuthenticationToken: Authentication接口常用的实现类</span></span><br><span class="line">            <span class="keyword">return</span> UsernamePasswordAuthenticationToken<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">aClass</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个重写方法，我们主要进行一些其他的配置，包括登录、登出、授权、处理验证码和记住我。该方法的参数是HttpSecurity实例</p>
<p><strong>登录</strong>我们主要通过配置http.formLogin()来实现，loginPage()表示登录页面的路径，而loginProcessingUrl()表示表单发出的请求的路径，与form中的action对应，同时form中的method必须是post。successHandler和failureHandler分别表示验证成功和失败之后的处理，我们通过匿名的方式实例化AuthenticationSuccessHandler和AuthenticationFailureHandler。对于成功，我们直接重定向到主页即可，而失败的话，我们需要将错误通过request进行传递同时还是在登录页面，需要传递信息，因此需要进行转发。</p>
<p><strong>登出</strong>我们需要配置logoutUrl，即登出的请求路径，以及成功登出的处理，这里我们就直接重定向到主页即可。于<strong>权限</strong>的配置，我们通过http.authorizeRequests()进行配置，通过antMatchers()配置路径，hasAnyAuthority()表示需要的权限。另外对于权限认证失败我们通过exceptionHandling().accessDeniedPage()进行重定向到/denied页面</p>
<p><strong>验证码</strong>的认证我们需要通过增加Filter来实现，并且要在用户名密码认证之前进行，因此我们使用http.addFilterBefore()方法，并且第二个参数指定为UsernamePasswordAuthenticationFilter.class。而第一个参数我们需要一个filter实例，同样也采用匿名实现的方式，主要是实现doFilter()方法，在该方法中，如果当前请求是登录请求，那么我们就进行验证码校验，如果不对，就通过转发的方式回到登录页面，如果通过了，就然请求继续执行下去，即filterChain.doFilter(request,response)。</p>
<p><strong>记住我</strong>我们主要通过http.rememberMe()来进行配置，tokenRepository()指定存储方式，这里我们采用存储在内存中的方式，tokenValiditySeconds()指定存储时间，userDetailsService()指定验证的方法。同时在login的form中checkbox的name必须是remember-me</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 登录相关的配置</span></span><br><span class="line">    http.formLogin()</span><br><span class="line">            .loginPage(<span class="string">"/loginpage"</span>)</span><br><span class="line">            .loginProcessingUrl(<span class="string">"/login"</span>)</span><br><span class="line">            .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    response.sendRedirect(request.getContextPath() + <span class="string">"/index"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    request.setAttribute(<span class="string">"error"</span>, e.getMessage());</span><br><span class="line">                    request.getRequestDispatcher(<span class="string">"/loginpage"</span>).forward(request,response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    http.logout()</span><br><span class="line">            .logoutUrl(<span class="string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    response.sendRedirect(request.getContextPath() + <span class="string">"/index"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对授权进行配置</span></span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/letter"</span>).hasAnyAuthority(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>)</span><br><span class="line">            .antMatchers(<span class="string">"/admin"</span>).hasAnyAuthority(<span class="string">"ADMIN"</span>)</span><br><span class="line">            .and().exceptionHandling().accessDeniedPage(<span class="string">"/denied"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加Filter,处理验证码</span></span><br><span class="line">    http.addFilterBefore(<span class="keyword">new</span> Filter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">            HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line">            <span class="keyword">if</span> (request.getServletPath().equals(<span class="string">"/login"</span>))&#123;</span><br><span class="line">                String verifyCode = request.getParameter(<span class="string">"verifyCode"</span>);</span><br><span class="line">                <span class="keyword">if</span> (verifyCode == <span class="keyword">null</span> || !verifyCode.equalsIgnoreCase(<span class="string">"1234"</span>))&#123;</span><br><span class="line">                    request.setAttribute(<span class="string">"error"</span>,<span class="string">"验证码错误！"</span>);</span><br><span class="line">                    request.getRequestDispatcher(<span class="string">"/loginpage"</span>).forward(request,response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 让请求继续向下执行</span></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记住我</span></span><br><span class="line">    http.rememberMe()</span><br><span class="line">            .tokenRepository(<span class="keyword">new</span> InMemoryTokenRepositoryImpl())</span><br><span class="line">            .tokenValiditySeconds(<span class="number">3600</span> * <span class="number">24</span>)</span><br><span class="line">            .userDetailsService(userService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>认证成功之后，SecurityContextHolder会将结果存入SecurityContext中，我们可以从中取得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 认证成功后，结果会通过SecurityContextHolder存入SecurityContext中</span></span><br><span class="line">Object obj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"loginUser"</span>,obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加入项目"><a href="#加入项目" class="headerlink" title="加入项目"></a>加入项目</h2><p>接下来我们要将Spring Security加入到我们的community项目中。</p>
<p>首先，我们要将之前实现的LoginRequiredInterceptor注释掉，让Spring Security来接管登录。</p>
<p>在配置方面，我们只要实现两个配置方法即可，对于登录验证我们已经实现了，不需要Spring Security接管。<br>静态资源配置和之前一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="string">"/resources/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是在权限方面的配置。首先我们要使用http.authorizeRequests()来配置权限，对于一些路径需要用户必须登录，因此角色必须是USER、ADMIN、MODERATOR才可以。</p>
<p>然后我们要配置权限不够时的处理，通过http.exceptionHandling()来进行配置。权限不够分为未登录和登录之后权限不够的情况。</p>
<p>未登录我们使用authenticationEntryPoint()来进行认证，通过实例化一个AuthenticationEntryPoint实例，实现commence()方法即可，在该方法中，我们需要对是否是异步请求进行区分，通过获得request头的x-requested-with字段来进行判断，如果是XMLHttpRequest，那么就是异步请求，对于异步请求我们使用response的Write返回一个JSON字符串即可，而如果不是异步请求的话直接重定向到登录页即可。</p>
<p>对于权限不够，我们使用accessDeniedHandler()方法，实例化AccessDeniedHandler，实现handle方法即可，同样按是否是异步进行分，异步还是发一个JSON字符串，不是异步就重定向到denied页面。<br>最后，我们要对logout进行配置，在spring security中对logout路径进行了拦截，但是我们已经自己实现了logout，因此我们将spring security的logout路径更换掉，防止拦截了我们项目的请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 授权</span></span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(</span><br><span class="line">                    <span class="string">"/user/setting"</span>,</span><br><span class="line">                    <span class="string">"/user/upload"</span>,</span><br><span class="line">                    <span class="string">"/discuss/add"</span>,</span><br><span class="line">                    <span class="string">"/comment/add/**"</span>,</span><br><span class="line">                    <span class="string">"/letter/**"</span>,</span><br><span class="line">                    <span class="string">"/notice/**"</span>,</span><br><span class="line">                    <span class="string">"/like"</span>,</span><br><span class="line">                    <span class="string">"/follow"</span>,</span><br><span class="line">                    <span class="string">"/unfollow"</span></span><br><span class="line">            )</span><br><span class="line">            .hasAnyAuthority(</span><br><span class="line">                    AUTHORITY_USER,</span><br><span class="line">                    AUTHORITY_ADMIN,</span><br><span class="line">                    AUTHORITY_MODERATOR</span><br><span class="line">            )</span><br><span class="line">            .anyRequest().permitAll()</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 权限不够时的认证</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint(<span class="keyword">new</span> AuthenticationEntryPoint() &#123;</span><br><span class="line">                <span class="comment">// 这里是没登陆时的处理</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    String xRequestedWith = request.getHeader(<span class="string">"x-requested-with"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"XMLHttpRequest"</span>.equals(xRequestedWith))&#123;</span><br><span class="line">                        <span class="comment">// 异步</span></span><br><span class="line">                        response.setContentType(<span class="string">"application/plain;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter writer = response.getWriter();</span><br><span class="line">                        writer.write(CommunityUtil.getJSONString(<span class="number">403</span>,<span class="string">"你还没有登录"</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.sendRedirect(request.getContextPath() + <span class="string">"/login"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .accessDeniedHandler(<span class="keyword">new</span> AccessDeniedHandler() &#123;</span><br><span class="line">                <span class="comment">// 这里是权限不足时的处理</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    String xRequestedWith = request.getHeader(<span class="string">"x-requested-with"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"XMLHttpRequest"</span>.equals(xRequestedWith))&#123;</span><br><span class="line">                        <span class="comment">// 异步</span></span><br><span class="line">                        response.setContentType(<span class="string">"application/plain;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter writer = response.getWriter();</span><br><span class="line">                        writer.write(CommunityUtil.getJSONString(<span class="number">403</span>,<span class="string">"你没有访问此功能的权限!"</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        response.sendRedirect(request.getContextPath() + <span class="string">"/denied"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// Security底层默认会拦截logout请求进行处理</span></span><br><span class="line">    <span class="comment">// 覆盖它默认的逻辑，才能执行我们的逻辑</span></span><br><span class="line">    http.logout().logoutUrl(<span class="string">"/securitylogout"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样基本上，我们就将spring security配置好了，但是由于我们是自己实现登录认证的，因此SecurityContext中并没有存入用户认证之后的Token，这样spring security就无法对当前用户进行认证，因此我们还需要将认证信息加入到SecurityContext中。</p>
<p>首先我们要在UserService中加入得到用户权限的方法，同样的也是将type转成GrantedAuthority实例加入到List中返回即可，同之前一样.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到用户的权限</span></span><br><span class="line"><span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities(<span class="keyword">int</span> userId)&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.findUserById(userId);</span><br><span class="line">    List&lt;GrantedAuthority&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> GrantedAuthority() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (user.getType())&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> AUTHORITY_ADMIN;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> AUTHORITY_MODERATOR;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> AUTHORITY_USER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，我们何时将权限加入到SecurityContext中内。实际上，我们是通过拦截器在controller请求之前对凭证进行认证的，那么很自然的我们可以在这里凭证认证完成之后加入权限.实例化一个UsernamePasswordAuthenticationToken，这和我们在demo中的实现是一样的，然后实例化一个SecurityContextImpl，传入authentication即可完成SecurityContextHolder的Context的设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建用户认证的结果，并存入SecurityContext，以便于security进行授权</span></span><br><span class="line">Authentication authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">        user,user.getPassword(), userService.getAuthorities(user.getId()));</span><br><span class="line">SecurityContextHolder.setContext(<span class="keyword">new</span> SecurityContextImpl(authentication));</span><br></pre></td></tr></table></figure>
<p>同hostholder一样，在完成请求之后我们也要将权限清空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    hostHolder.clear();</span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在登出那边也要进行清除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/logout"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(@CookieValue(<span class="string">"ticket"</span>)</span> String ticket)</span>&#123;</span><br><span class="line">    userService.logout(ticket);</span><br><span class="line">    <span class="comment">// 清理权限</span></span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><p>spring security加入了防止csrf攻击，具体就是在表单中加入一个_csrf的token，这样就能防止cookie被盗用冒充身份的攻击了。而表单之外的csrf防御我们可以这样实现。</p>
<p>首先在HTML中，我们在meta中声明csrf令牌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">访问该页面时，在此处生成csrf令牌</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"_csrf"</span> <span class="attr">th:content</span>=<span class="string">"$&#123;_csrf.token&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"_csrf_header"</span> <span class="attr">th:content</span>=<span class="string">"$&#123;_csrf.headerName&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，在JS中我们要将csrf令牌加入到请求头中即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> token = $(<span class="string">"meta[name='_csrf']"</span>).attr(<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">var</span> header = $(<span class="string">"meta[name='_csrf_header']"</span>).attr(<span class="string">"content"</span>);</span><br><span class="line">$(<span class="built_in">document</span>).ajaxSend(<span class="function"><span class="keyword">function</span> (<span class="params">e, xhr, options</span>) </span>&#123;</span><br><span class="line">	xhr.setRequestHeader(header,token);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是由于我们是开发因此可以先将csrf防御关闭。</p>
]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>spring security</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-9-Elasticsearch之帖子搜索</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-9-Elasticsearch%E4%B9%8B%E5%B8%96%E5%AD%90%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><p>安装好elasticsearch之后，我们可以通过postman访问9200端口查看一些信息，下面给出一些基本的命令</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看节点状态</span></span><br><span class="line">localhost:<span class="number">9200</span>/_cat/indices?v</span><br><span class="line"><span class="comment">// 向test索引中加入id为3的数据，在body中设置json格式数据</span></span><br><span class="line">localhost:<span class="number">9200</span>/test/_doc/<span class="number">3</span></span><br><span class="line"><span class="comment">// 删除test索引中id为1的数据</span></span><br><span class="line">localhost:<span class="number">9200</span>/test/_doc/<span class="number">1</span></span><br><span class="line"><span class="comment">// 在body中实现多条件查询</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"query"</span>:&#123;</span><br><span class="line">		<span class="string">"multi_match"</span>:&#123;</span><br><span class="line">			<span class="string">"query"</span>:<span class="string">"互联网"</span>,</span><br><span class="line">			<span class="string">"fields"</span>:[<span class="string">"title"</span>,<span class="string">"content"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先我们在pom.xml中引入相关依赖，但是每次引入都会报错，经过多次查询资料，发现是SSL证书的问题，具体可以参考<a href="https://www.cnblogs.com/wpbxin/p/11746229.html" target="_blank" rel="noopener">博客</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们需要在application.properties中配置节点名称和路径，在SpringBoot中我们使用的是9300端口</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ElasticSearchProperties</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-name</span>=<span class="string">nowcoder</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">127.0.0.1:9300</span></span><br></pre></td></tr></table></figure>
<p>这里要注意，elasticsearch和redis的网络部分都是基于netty实现的，因此我们要做一些配置避免发送冲突，具体就是在App启动的地方做一个配置（具体需要百度下。。。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在构造器之前</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 解决netty启动冲突问题</span></span><br><span class="line">	<span class="comment">// Netty4Utils.setAvailableProcessors()</span></span><br><span class="line">	System.setProperty(<span class="string">"es.set.netty.runtime.available.processors"</span>,<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h2><p>在Springboot中我们使用elasticsearch，实现要对能搜索的实体进行配置，使用@Document将实体和索引（也就是数据库中的表）相联系，使用@Id设置索引中哪个字段为id，@Field来设置索引中的字段。</p>
<p>@Document中indexName表示索引名字，type表示分隔符，shards表示分片，replicas表示副本数量。</p>
<p>@Field中type表示数据类型，analyzer表示解析器，ik_max_word表示将一句话拆分成尽可能多的词语，ik_smart表示符合尝试的解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"discusspost"</span>,type = <span class="string">"_doc"</span>,shards = <span class="number">6</span>, replicas = <span class="number">3</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscussPost</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// analyzer 解析器 对一句话尽可能拆分成多个词条 聪明的拆分。。</span></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, analyzer = <span class="string">"ik_max_word"</span>, searchAnalyzer = <span class="string">"ik_smart"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Text, analyzer = <span class="string">"ik_max_word"</span>, searchAnalyzer = <span class="string">"ik_smart"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Date)</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Integer)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> commentCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(type = FieldType.Double)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br></pre></td></tr></table></figure>
<h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><p>有了对实体中字段的注解，在dao层我们只要继承ElasticsearchRepository，并指明实体类型和ID类型即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscussPostRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">DiscussPost</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>在service层，我们主要实现三个方法，分别是保存数据、删除数据和查询数据，其中保存和删除我们直接使用dao层的Repository即可，调用save和deleteById</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveDiscussPost</span><span class="params">(DiscussPost post)</span></span>&#123;</span><br><span class="line">    discussPostRepository.save(post);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDiscussPost</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    discussPostRepository.deleteById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而搜索相对复杂一点。首先，我们要传入关键字、当前页和限制条数来构造搜索条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">        <span class="comment">// 构造多字段查询</span></span><br><span class="line">        .withQuery(QueryBuilders.multiMatchQuery(keyword,<span class="string">"title"</span>,<span class="string">"content"</span>))</span><br><span class="line">        <span class="comment">// 设置排序字段为type,score,createTime 倒序</span></span><br><span class="line">        .withSort(SortBuilders.fieldSort(<span class="string">"type"</span>).order(SortOrder.DESC))</span><br><span class="line">        .withSort(SortBuilders.fieldSort(<span class="string">"score"</span>).order(SortOrder.DESC))</span><br><span class="line">        .withSort(SortBuilders.fieldSort(<span class="string">"createTime"</span>).order(SortOrder.DESC))</span><br><span class="line">        <span class="comment">// 设置分页 page表示当前页</span></span><br><span class="line">        .withPageable(PageRequest.of(current,limit))</span><br><span class="line">        <span class="comment">// 设置高亮的前标签和后标签</span></span><br><span class="line">        .withHighlightFields(</span><br><span class="line">                <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">"title"</span>).preTags(<span class="string">"&lt;em&gt;"</span>).postTags(<span class="string">"&lt;/em&gt;"</span>),</span><br><span class="line">                <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">"content"</span>).preTags(<span class="string">"&lt;em&gt;"</span>).postTags(<span class="string">"&lt;/em&gt;"</span>)</span><br><span class="line">        ).build();</span><br></pre></td></tr></table></figure>
<p>有了搜索条件之后，我们就需要使用elasticsearchTemplate进行搜索了，通过使用queryForPage方法，queryForPage方法的返回类型是org.springframework.data.domain.Page&lt;DiscussPost&gt;，因此我们需要传入实体类.class和搜索条件，然后匿名实现一个SearchResultMapper()方法，用于对elasticsearchTemplate得到的结果进行相应的处理，然后再返回。</p>
<p>在匿名类中我们使用SearchResponse来接收elasticsearchTemplate返回的结果，在该方法中我们首先得到全部数据，如果数据不为空的话，我们遍历所有数据，对于每一条数据通过hit.getSourceAsMap().get(“xxx”)得到信息实例化一个post对象，然后得到高亮数据，通过hit.getHighlightFields().get(“title”)得到title的，content的也同理，然后如果高亮数据不为空，那么我们将添加了em标签的数据设置为post的title和content。最后我们使用一个AggregatedPageImpl的构造方法传入list和其他固定参数对结果进行返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// elasticsearchTemplate得到结果交给SearchResultMapper处理之后再返回</span></span><br><span class="line"><span class="keyword">return</span> elasticsearchTemplate.queryForPage(searchQuery, DiscussPost<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">SearchResultMapper</span>() </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AggregatedPage&lt;T&gt; <span class="title">mapResults</span><span class="params">(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到所有命中数据</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        <span class="keyword">if</span> (hits.getTotalHits() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;DiscussPost&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits)&#123;</span><br><span class="line">            DiscussPost post = <span class="keyword">new</span> DiscussPost();</span><br><span class="line">            <span class="comment">// 得到每个被遍历数据的信息，然后设置post</span></span><br><span class="line">            String id = hit.getSourceAsMap().get(<span class="string">"id"</span>).toString();</span><br><span class="line">            post.setId(Integer.valueOf(id));</span><br><span class="line"></span><br><span class="line">            String userId = hit.getSourceAsMap().get(<span class="string">"userId"</span>).toString();</span><br><span class="line">            post.setUserId(Integer.valueOf(userId));</span><br><span class="line"></span><br><span class="line">            String title = hit.getSourceAsMap().get(<span class="string">"title"</span>).toString();</span><br><span class="line">            post.setTitle(title);</span><br><span class="line"></span><br><span class="line">            String content = hit.getSourceAsMap().get(<span class="string">"content"</span>).toString();</span><br><span class="line">            post.setContent(content);</span><br><span class="line"></span><br><span class="line">            String status = hit.getSourceAsMap().get(<span class="string">"status"</span>).toString();</span><br><span class="line">            post.setStatus(Integer.valueOf(status));</span><br><span class="line"></span><br><span class="line">            String createTime = hit.getSourceAsMap().get(<span class="string">"createTime"</span>).toString();</span><br><span class="line">            post.setCreateTime(<span class="keyword">new</span> Date(Long.valueOf(createTime)));</span><br><span class="line"></span><br><span class="line">            String commentCount = hit.getSourceAsMap().get(<span class="string">"commentCount"</span>).toString();</span><br><span class="line">            post.setCommentCount(Integer.valueOf(commentCount));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理高亮结果</span></span><br><span class="line">            <span class="comment">// 得到title字段的高亮数据</span></span><br><span class="line">            HighlightField titleField = hit.getHighlightFields().get(<span class="string">"title"</span>);</span><br><span class="line">            <span class="keyword">if</span> (titleField != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 只取第一个高亮</span></span><br><span class="line">                post.setTitle(titleField.getFragments()[<span class="number">0</span>].toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HighlightField contentField = hit.getHighlightFields().get(<span class="string">"content"</span>);</span><br><span class="line">            <span class="keyword">if</span> (contentField != <span class="keyword">null</span>)&#123;</span><br><span class="line">                post.setTitle(contentField.getFragments()[<span class="number">0</span>].toString());</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(post);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对返回数据进行初始化，传入list，其他都是固定的（目前）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AggregatedPageImpl(list,pageable,</span><br><span class="line">                hits.getTotalHits(), searchResponse.getAggregations(),</span><br><span class="line">                searchResponse.getScrollId(), hits.getMaxScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>在controller层我们首先处理发布帖子和修改帖子之后将帖子加入到elasticsearch服务器中的处理，这里我们使用消息队列来进行实现，同样的对于一个事件我们需要指定主题，触发事件的人和实体类型、实体id，然后使用eventProducer.fireEvent(event)发布事件。具体我们要在发布帖子和用户对帖子进行评论的时候加入事件触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发发帖事件</span></span><br><span class="line">Event event = <span class="keyword">new</span> Event()</span><br><span class="line">        .setTopic(TOPIC_PUBLISH)</span><br><span class="line">        .setUserId(user.getId())</span><br><span class="line">        .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">        .setEntityId(discussPost.getId());</span><br><span class="line">eventProducer.fireEvent(event);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST) &#123;</span><br><span class="line">    <span class="comment">// 触发发帖事件</span></span><br><span class="line">    event = <span class="keyword">new</span> Event()</span><br><span class="line">            .setTopic(TOPIC_PUBLISH)</span><br><span class="line">            .setUserId(hostHolder.getUser().getId())</span><br><span class="line">            .setEntityType(ENTITY_TYPE_POST)</span><br><span class="line">            .setEntityId(discussPostId);</span><br><span class="line">    eventProducer.fireEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，对于该类事件，我们需要加入一个新的消费者进行消费。</p>
<p>同样地通过设置主题，判断消息内容和格式，然后调用dao加入数据即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费发帖事件</span></span><br><span class="line"><span class="meta">@KafkaListener</span>(topics = &#123;TOPIC_PUBLISH&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePublishMessage</span><span class="params">(ConsumerRecord record)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="keyword">null</span> || record.value() == <span class="keyword">null</span> )&#123;</span><br><span class="line">        logger.error(<span class="string">"消息的内容为空！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Event event = JSONObject.parseObject(record.value().toString(), Event<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>)&#123;</span><br><span class="line">        logger.error(<span class="string">"消息格式错误！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DiscussPost post = discussPostService.findDiscussPostByid(event.getEntityId());</span><br><span class="line">    elasticsearchService.saveDiscussPost(post);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是对搜索结果进行处理的controller了</p>
<p>首先通过service得到搜索结果，然后同之间一样，根据帖子的作者id得到作者user实例，根据帖子id查询点赞数量，然后聚合到map中，再将map传入list中，最后将list传给model</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchController</span> <span class="keyword">implements</span> <span class="title">CommunityConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LikeService likeService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// /search?keyword=xxx</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/search"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">search</span><span class="params">(String keyword, Page page, Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 搜索帖子</span></span><br><span class="line">        org.springframework.data.domain.Page&lt;DiscussPost&gt; searchResult =</span><br><span class="line">                elasticsearchService.searchDiscussPost(keyword,page.getCurrent()-<span class="number">1</span>,page.getLimit());</span><br><span class="line">        <span class="comment">// 聚合数据</span></span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (searchResult != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (DiscussPost post : searchResult)&#123;</span><br><span class="line">                Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                <span class="comment">// 帖子</span></span><br><span class="line">                map.put(<span class="string">"post"</span>,post);</span><br><span class="line">                <span class="comment">// 作者</span></span><br><span class="line">                map.put(<span class="string">"user"</span>,userService.findUserById(post.getUserId()));</span><br><span class="line">                <span class="comment">// 点赞数量</span></span><br><span class="line">                map.put(<span class="string">"likeCount"</span>,likeService.findEntityLikeCount(ENTITY_TYPE_POST,post.getId()));</span><br><span class="line"></span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">"discussPosts"</span>,discussPosts);</span><br><span class="line">        model.addAttribute(<span class="string">"keyword"</span>,keyword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分页信息</span></span><br><span class="line">        page.setPath(<span class="string">"/search?keyword="</span>+keyword);</span><br><span class="line">        page.setRows(searchResult == <span class="keyword">null</span> ? <span class="number">0</span> : (<span class="keyword">int</span>) searchResult.getTotalElements());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/search"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-8-kafka之系统通知</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-8-kafka%E4%B9%8B%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p>在这个部分我们要将kafka分布式流媒体平台接入我们的系统，用作系统通知。</p>
<a id="more"></a>

<p>zookeeper启动命令</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">.<span class="symbol">\b</span>in<span class="symbol">\w</span>indows<span class="symbol">\z</span>ookeeper-server-start.bat .<span class="symbol">\c</span>onfig<span class="symbol">\z</span>ookeeper.properties</span><br></pre></td></tr></table></figure>
<p>kafka启动命令</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">.<span class="symbol">\b</span>in<span class="symbol">\w</span>indows<span class="symbol">\k</span>afka-server-start.bat .<span class="symbol">\c</span>onfig<span class="symbol">\s</span>erver.properties</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>我们在pom中加入相关配置之后只需要在application.properties中配置kafka服务的端口号、group-id和自动提交的配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># KafkaPropertoes</span></span><br><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">community-consumer-group</span></span><br><span class="line"><span class="comment"># 是否自动提交</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.enable-auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 自动提交的频率(ms)</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-commit-interval</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>
<h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>我们使用消息队列只要是为了处理用户被评论、点赞和关注之后生成一个消息存入数据库中然后发送给用户。根据需求，我们需要告诉用户消息的种类是什么(评论、点赞还是关注)，这条消息是什么，这条消息是由哪个用户产生的。因此，我们可以设计这样一个类来表示事件，用topic表示消息类型，用entityTpye和entityId来定位评论或者帖子，用entityUserId来表示实体的所有者，userId来表示这个事件是谁触发的。data是用于存储其他信息的。</p>
<p>我们注意到这个类中的setter方法的返回值都是实体，这是因为在设置值的时候比较方便，可以连续使用set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> entityType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> entityId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> entityUserId;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setTopic</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topic = topic;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEntityType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setEntityType</span><span class="params">(<span class="keyword">int</span> entityType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityType = entityType;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEntityId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setEntityId</span><span class="params">(<span class="keyword">int</span> entityId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityId = entityId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEntityUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityUserId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setEntityUserId</span><span class="params">(<span class="keyword">int</span> entityUserId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityUserId = entityUserId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">setData</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.put(key,value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者就是消息的产生者，在我们的业务中，就是当发送评论、点赞和关注时将消息放入特定的主题队列中等待消费者消费即可。在SpringBoot中我们可以使用KafkaTemplate类的实例很方便的实现生产者方法。</p>
<p>我们使用fireEvent方法来封装KafkaTemplate的send方法，send方法就是向指定的topic队列中发送一个消息，这里我们发送的是event对象转成json之后的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(Event event)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 将事件发布到指定的主题</span></span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p>在SpringBoot中我们使用@KafkaListener来实现对消息队列的监听，当收到消息时就会触发相应的方法，我们使用ConsumerRecord类的实例来接收消息队列中的消息。</p>
<p>在我们的业务中，我们首先判断是否由收到消息，然后把收到的消息字符串转换为Event对象，然后我们将该消息经过处理存储到message数据库中。</p>
<p>在message数据表中，我们设置消息的发送者id为系统ID，消息的接收者id为event的entityUserId,消息的会话Id我们可以设置为事件的主题，而消息的内容我们可以用一个map来存储，需要放入event的userId,entityType和entityId，如果data中有数据我们也要放入其中。然后把map转成json格式的字符串放入数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventConsumer</span> <span class="keyword">implements</span> <span class="title">CommunityConstant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(EventConsumer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;TOPIC_COMMENT,TOPIC_FOLLOW,TOPIC_LIKE&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCommentMessage</span><span class="params">(ConsumerRecord record)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (record == <span class="keyword">null</span> || record.value() == <span class="keyword">null</span> )&#123;</span><br><span class="line">            logger.error(<span class="string">"消息的内容为空！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Event event = JSONObject.parseObject(record.value().toString(), Event<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>)&#123;</span><br><span class="line">            logger.error(<span class="string">"消息格式错误！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送站内通知</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"userId"</span>,event.getUserId());</span><br><span class="line">        content.put(<span class="string">"entityType"</span>,event.getEntityType());</span><br><span class="line">        content.put(<span class="string">"entityId"</span>,event.getEntityId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!event.getData().isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,Object&gt; entry : event.getData().entrySet())&#123;</span><br><span class="line">                content.put(entry.getKey(),entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><p>这里，我们以评论为例。当增加评论的时候，我们需要将该消息加入到消息队列中，因此我们需要声明Event实例。对于评论我们设置主题为comment，设置用户id为当前发表评论的用户id，设置实体的种类和id都是当前评论目标的目标的种类和id，然后在data中我们要传入当前帖子的id，方便查看详情时定位到该帖子。对于评论对象的不同，我们使用不同的service来查询不同的实体得到entityUserId。当声明好事件之后，我们就可以调用生产者来发送消息了。</p>
<p>注意在这里我们在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发评论事件</span></span><br><span class="line">Event event = <span class="keyword">new</span> Event()</span><br><span class="line">        .setTopic(TOPIC_COMMENT)</span><br><span class="line">        .setUserId(hostHolder.getUser().getId())</span><br><span class="line">        .setEntityType(comment.getEntityType())</span><br><span class="line">        .setEntityId(comment.getEntityId())</span><br><span class="line">        .setData(<span class="string">"postId"</span>,discussPostId);</span><br><span class="line"><span class="keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;</span><br><span class="line">    DiscussPost target = discussPostService.findDiscussPostByid(comment.getEntityId());</span><br><span class="line">    event.setEntityUserId(target.getUserId());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_COMMENT)&#123;</span><br><span class="line">    Comment target = commentService.findCommentById(comment.getEntityId());</span><br><span class="line">    event.setEntityUserId(target.getUserId());</span><br><span class="line">&#125;</span><br><span class="line">eventProducer.fireEvent(event);</span><br></pre></td></tr></table></figure>
<h1 id="显示通知"><a href="#显示通知" class="headerlink" title="显示通知"></a>显示通知</h1><p>显示通知的逻辑和显示私信的逻辑类似。</p>
<p>然后要多加一个拦截器用于计算用户未读消息的数量（私信+系统通知），因为在导航栏中因此可以加入到拦截器中，这样用户在线时收到消息就能及时看到（去别的页面就可以）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; modelAndView != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> letterUnreadCount = messageService.findLetterUnreadCount(user.getId(),<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">int</span> noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(),<span class="keyword">null</span>);</span><br><span class="line">            modelAndView.addObject(<span class="string">"allUnreadCount"</span>,letterUnreadCount+noticeUnreadCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-7-优化登录模块</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-7-%E4%BC%98%E5%8C%96%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="使用Redis存储验证码"><a href="#使用Redis存储验证码" class="headerlink" title="使用Redis存储验证码"></a>使用Redis存储验证码</h1><a id="more"></a>

<p>验证码需要频繁的访问与刷新，对性能要求较高。验证码不需要永久保存，通常在很短时间后就会失效，同时在分布式部署时，存在Session共享的问题。因此原先我们将验证码存在session中的方法需要进行重构。<br>我们可以将验证码存入到redis中，但是这里有一个问题，就是要将验证码和用户对应起来，但是此时用户没有登录，没有id，因此我们可以用一个随机码临时地标记一下这个用户。因此我们可以这样设计key，kaptcha:owner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_KAPTCHA = <span class="string">"kaptcha"</span>;</span><br><span class="line"><span class="comment">// 登录验证码</span></span><br><span class="line"><span class="comment">// owner为用户未登录时临时的凭证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKaptchaKey</span><span class="params">(String owner)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_KAPTCHA + SPLIT + owner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在生成验证码的时候，我们随机生成一个标识符，我们需要将这个标识符存入cookie中，设置好过期时间传给浏览器，然后将验证码存入redis中，同时也需要设计redis的过期时间60s</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证码的owner</span></span><br><span class="line">String kaptchaOwner = CommunityUtil.generateUUID();</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"kaptchaOwner"</span>,kaptchaOwner);</span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>);</span><br><span class="line"><span class="comment">// 整个项目下都有效</span></span><br><span class="line">cookie.setPath(contextPath);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"><span class="comment">// 将验证码存入redis</span></span><br><span class="line">String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">redisTemplate.opsForValue().set(redisKey,text,<span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>在验证验证码的时候我们需要从cookie中得到这个临时标识符，要注意判断该cookie是否已经过期了，如果没有过期就以该标识得到key，然后得到验证码即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String kaptcha = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 如果cookie没有失效</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotBlank(kaptchaOwner))&#123;</span><br><span class="line">    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);</span><br><span class="line">    kaptcha = (String) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用Redis存储登录凭证"><a href="#使用Redis存储登录凭证" class="headerlink" title="使用Redis存储登录凭证"></a>使用Redis存储登录凭证</h1><p>在每次controller请求前，我们都会拦截请求，查询cookie中的登录凭证，并进行验证。这其中涉及到两次数据库操作，一次是根据ticket得到LoginTicket，一次是根据LoginTicket查询用户然后加入到hostHolder中，因此这样效率可以说是极低。因此我们需要将频繁的数据库操作改成redis操作。</p>
<p>首先我们要设计redis的key，可以这样设计ticket:具体的ticket，然后在存储对象时，我们只要用opsForValue()即可，redis会将对象序列化为json格式的值存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_TICKET = <span class="string">"ticket"</span>;</span><br><span class="line"><span class="comment">// 登录的凭证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTicketKey</span><span class="params">(String ticket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_TICKET + SPLIT + ticket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们这样存储LoginTicket对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());</span><br><span class="line"><span class="comment">// redis会将对象序列化为json格式字符串后存入</span></span><br><span class="line">redisTemplate.opsForValue().set(redisKey,loginTicket);</span><br></pre></td></tr></table></figure>
<p>在查询的时候我们就从redis中查询，并返回该对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoginTicket <span class="title">findLoginTicket</span><span class="params">(String ticket)</span></span>&#123;</span><br><span class="line">        <span class="comment">//return loginTicketMapper.selectByTicket(ticket);</span></span><br><span class="line">    String redisKey = RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">    <span class="keyword">return</span> (LoginTicket) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在登出的时候我们需要修改该凭证的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(String ticket)</span></span>&#123;</span><br><span class="line">        <span class="comment">//loginTicketMapper.updateStatus(ticket,1);</span></span><br><span class="line"></span><br><span class="line">    String redisKey = RedisKeyUtil.getTicketKey(ticket);</span><br><span class="line">    LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">    loginTicket.setStatus(<span class="number">1</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(redisKey,loginTicket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们需要对根据id查询用户方法进行优化，也就是findUserById()方法。我们可以这样实现，首先我们从缓存中取值，如果取不到，那么我们就去数据库中取，然后存入redis中，当数据变更时我们需要清楚缓存数据。<br>我们可以这样设计存储用户的key：user:具体的user</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_USER = <span class="string">"user"</span>;</span><br><span class="line"><span class="comment">// 用户</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserKey</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_USER + SPLIT + userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从缓存中取值就是构建key，然后调用get()方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.优先从缓冲中取值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">getCache</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    String redisKey = RedisKeyUtil.getUserKey(userId);</span><br><span class="line">    <span class="keyword">return</span> (User) redisTemplate.opsForValue().get(redisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从数据库中取得之后加入redis，我们需要设置过期时间为24小时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.取不到时就初始化缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">initCache</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    User user = userMapper.selectById(userId);</span><br><span class="line">    String redisKey = RedisKeyUtil.getUserKey(userId);</span><br><span class="line">    redisTemplate.opsForValue().set(redisKey,user,<span class="number">3600</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除缓存数据只要调用delete()方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.当数据变更时清除缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    String redisKey = RedisKeyUtil.getUserKey(userId);</span><br><span class="line">    redisTemplate.delete(redisKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了这三个私有方法之后，我们就可以来优化findUserById方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">//return userMapper.selectById(id);</span></span><br><span class="line">    User user = getCache(id);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">        user = initCache(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后清理缓存我们可以在修改中使用，比如修改头像之后清空缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateHeader</span><span class="params">(<span class="keyword">int</span> userId, String headerUrl)</span></span>&#123;</span><br><span class="line">        <span class="comment">//return userMapper.updateHeader(userId,headerUrl);</span></span><br><span class="line">    <span class="keyword">int</span> rows = userMapper.updateHeader(userId,headerUrl);</span><br><span class="line">    clearCache(userId);</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>优化登录</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-6-点赞和关注</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-6-%E7%82%B9%E8%B5%9E%E5%92%8C%E5%85%B3%E6%B3%A8/</url>
    <content><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>Spring整合Redis我们只需要引入依赖之后配置Redis即可</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">- spring-boot-starter-data-redis</span><br></pre></td></tr></table></figure>
<p>而配置Redis我们主要是配置数据库参数和编写配置类，构造RedisTemplate</p>
<p>在application.properties中我们只要设置必须的redis库，主机和端口号</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RedisProperties</span></span><br><span class="line"><span class="comment"># 选择0-15的哪一个库</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">11</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
<p>而在配置类中，我们主要通过RedisConnectionFactory数据库连接工厂将我们创建的RedisTemplate实例和redis连接，然后我们需要设置key和value的序列化方法，除此之外对于Hash类型的key和value我们要单独设置，在这里我们就设置为Redis提供的序列方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义第三方的Bean</span></span><br><span class="line">    <span class="comment">// RedisConnectionFactory为数据库连接工厂，在方法中声明，spring会自动装入容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        <span class="comment">// 设置hash的key的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置hash的value的序列化方式</span></span><br><span class="line">        template.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使设置生效</span></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><p>点赞支持对帖子、评论点赞，第一次点赞，第二次取消点赞。前端的需求有统计帖子的点赞数量、统计评论的点赞数量，以及显示当前用户的点赞状态。</p>
<p>这样的业务我们不再对controller和前端页面给出展示，最核心的应该是redis的设计和实现。</p>
<p>首先是点赞功能，我们需要存储的是某个实体被哪些用户点赞了，每一个实体可以拥有一个key，value应该是set类型，存放的是点赞用户的id。因此我们可以这样设计key：like:entity:entityType:entityId -&gt; set(userId)<br>在redisKeyUtil工具类中我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLIT = <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_ENTITY_LIKE = <span class="string">"like:entity"</span>;</span><br><span class="line"><span class="comment">// 某个实体的赞</span></span><br><span class="line"><span class="comment">// like:entity:entityType:entityId -&gt; set(userId)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getEntityLikeKey</span><span class="params">(<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_ENTITY_LIKE + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于查询该用户是否给该实体点过赞只要在以该实体生成的key的redis中是否有该用户即可；查询某个实体的点赞数量只要查询该实体存储的用户数量有几个。</p>
<p>但是我们还有一个需求就是得到某个用户收到的赞，包括他发布的帖子和评论收到的赞，因此遍历原来的数据是不可能的，因此我们还需要一个数据库用来存储每个用户收到的赞，每次用户点赞的时候，我们不但让用户点赞的实体点赞增加，也让该实体的主人点赞也增加。</p>
<p>对于key我们可以这样设计like:user:userId -&gt; int，值只要用value存储即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个用户的赞</span></span><br><span class="line"><span class="comment">// like:user:userId -&gt; int</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserLikeKey</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_USER_LIKE + SPLIT + userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样所有的需求都可以满足了，然后我们就可以开发service层了。</p>
<p>最主要的就是点赞了，由于需要修改两个数据库，因此我们需要引入事务。在redis中事务执行中不会乱入其他语句，事务使用的是乐观锁，这种方式运行exec前修改和查询。redis通过watch来检测数据，在执行exec前，检测的数据被其他人更改会抛出错误，取消执行，而在执行时保证不会插入其他语句来实现隔离。在执行事务时是所有语句一起执行的（？）因此查询语句要放在事务之外执行。</p>
<p>点赞方法需要传入点赞用户id，实体类型，实体id和实体主人id。使用execute（）方法执行事务，在SessionCallback参数中执行具体代码，并把执行结果作为参数。在SessionCallback参数的execute方法中我们通过RedisOperations类型参数对redis进行操作，multi()方法用于开始事务。首先按照我们之前约定构造key，然后查询该用户是否已经对该实体点过赞了，如果点了，我们就将该用户从该实体的赞的数据库中移除，然后把实体目标用户收到的赞减一，如果没有点过赞，就增加即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点赞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">like</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId,<span class="keyword">int</span> entityUserId)</span></span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);</span><br><span class="line">            String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);</span><br><span class="line">            <span class="comment">// 在事务外查询</span></span><br><span class="line">            <span class="keyword">boolean</span> isMember = operations.opsForSet().isMember(entityLikeKey,userId);</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isMember)&#123;</span><br><span class="line">                operations.opsForSet().remove(entityLikeKey,userId);</span><br><span class="line">                operations.opsForValue().decrement(userLikeKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                operations.opsForSet().add(entityLikeKey,userId);</span><br><span class="line">                operations.opsForValue().increment(userLikeKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某个实体被点赞数量只要查看以该实体组成的key的数据库中有多少数据即可，使用size（）方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某实体点赞的数量，一个实体由type和id定位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findEntityLikeCount</span><span class="params">(<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForSet().size(entityLikeKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某人是否对某个实体点过赞我们只要在该实体中查询是否有该用户的id即可，使用isMember()方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某人是否对某实体点过赞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findEntityLikeStatus</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType,entityId);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForSet().isMember(entityLikeKey,userId) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某个用户获得的赞，只要取得该用户的redis数据库的值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某个用户获得的赞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUserLikeCount</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">    String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);</span><br><span class="line">    Integer count = (Integer)redisTemplate.opsForValue().get(userLikeKey);</span><br><span class="line">    <span class="keyword">return</span> count == <span class="keyword">null</span> ? <span class="number">0</span> : count.intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h1><p>关注的需求就是统计用户的关注数和粉丝数，关注的对象可以是用户、帖子、题目等，可以抽象为实体。</p>
<p>首先我们需要处理某个用户关注的实体，由于有多种实体，因此对于不同的关注实体我们存入不同的数据表中，因此我们可以以followee:userId:entityType为key，以有序集合zset作为值，该zset以entityId为key，以当前时间为value(score)，表示该用户对该实体关注了哪些内容，分数是多少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_FOLLOWEE = <span class="string">"followee"</span>;</span><br><span class="line"><span class="comment">// 某个用户关注的实体</span></span><br><span class="line"><span class="comment">// followee:userId:entityType -&gt; zset(entityId,now)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFolloweeKey</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_FOLLOWEE + SPLIT + userId + SPLIT + entityType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而某个实体拥有的粉丝我们需要通过实体类型和实体id指定实体，以此为key，而值我们还是用有序集合，存入粉丝id，即用户id，以及当前时间作为分数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_FOLLOWER = <span class="string">"follower"</span>;</span><br><span class="line"><span class="comment">// 某个实体拥有的粉丝</span></span><br><span class="line"><span class="comment">// follower:entityType:entityId -&gt; zset(userId,now)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFollowerKey</span><span class="params">(<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PREFIX_FOLLOWER + SPLIT + entityType + SPLIT + entityId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在service层实现即可。</p>
<p>首先是关注和取消关注的实现，两者基本一致，这里只给出关注部分。我们需要传入用户id和实体类型实体id，和点赞一样，我们要在事务里执行，分别给该用户的关注中加入该实体，以及给该实体的粉丝中加入该用户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);</span><br><span class="line">            String followerKey = RedisKeyUtil.getFollowerKey(entityType,entityId);</span><br><span class="line"></span><br><span class="line">            operations.multi();</span><br><span class="line"></span><br><span class="line">            operations.opsForZSet().add(followeeKey,entityId, System.currentTimeMillis());</span><br><span class="line">            operations.opsForZSet().add(followerKey,userId,System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">return</span> operations.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某用户关注的实体数量，我们需要得到该用户id和需要查询的实体类型来构建key，然后查询该key的数据库中的数据量即可，zset使用zCard即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询关注的实体数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findFolloweeCount</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType)</span></span>&#123;</span><br><span class="line">    String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followeeKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某实体的粉丝数量，我们需要传入该实体的类型和id</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询实体的粉丝数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findFollowerCount</span><span class="params">(<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    String followerKey = RedisKeyUtil.getFollowerKey(entityType,entityId);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForZSet().zCard(followerKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询当前用户是否关注了该实体，我们只要在该用户的关注对象里查找是否有该实体即可。使用score得到该用户的分数，如果不存在就得不到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询当前用户是否已关注该实体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasFollowed</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> entityType,<span class="keyword">int</span> entityId)</span></span>&#123;</span><br><span class="line">    String followeeKey = RedisKeyUtil.getFolloweeKey(userId,entityType);</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForZSet().score(followeeKey,entityId) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们还有两个需求就是得到某个用户关注的人，以及该用户的粉丝有哪些。</p>
<p>对于某个用户关注的人我们只要将实体类型设置为用户构建key，得到相应的zset，然后遍历即可。我们要根据时间排序，因此使用reverseRange()方法，然后由于要分页，所以我们要通过offset和limit设置开始索引和结束索引。在遍历过程中，我们将得到的userId得到用户放入map中，将得到的now转换为Date类型之后也放入map中，然后将map放入list中，最后将list返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某个用户关注的人</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; findFollowees(<span class="keyword">int</span> userId,<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)&#123;</span><br><span class="line">    String followeeKey = RedisKeyUtil.getFolloweeKey(userId,ENTITY_TYPE_USER);</span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followeeKey,offset,offset+limit-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (targetIds == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer targetId: targetIds)&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        User user = userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">"user"</span>,user);</span><br><span class="line">        Double score = redisTemplate.opsForZSet().score(followeeKey,targetId);</span><br><span class="line">        map.put(<span class="string">"followTime"</span>,<span class="keyword">new</span> Date(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某用户的粉丝也是同理，只要将实体设置为用户，然后传入改用户的id构建key，然后遍历即可。过程和查询用户关注对象类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询某用户的粉丝</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String,Object&gt;&gt; findFollowers(<span class="keyword">int</span> userId,<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)&#123;</span><br><span class="line">    String followerKey = RedisKeyUtil.getFollowerKey(ENTITY_TYPE_USER,userId);</span><br><span class="line">    Set&lt;Integer&gt; targetIds = redisTemplate.opsForZSet().reverseRange(followerKey,offset,offset+limit-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (targetIds == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer targetId: targetIds)&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        User user = userService.findUserById(targetId);</span><br><span class="line">        map.put(<span class="string">"user"</span>,user);</span><br><span class="line">        Double score = redisTemplate.opsForZSet().score(followerKey,targetId);</span><br><span class="line">        map.put(<span class="string">"followTime"</span>,<span class="keyword">new</span> Date(score.longValue()));</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>点赞</tag>
        <tag>关注</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-5-私信</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-5-%E7%A7%81%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="私信"><a href="#私信" class="headerlink" title="私信"></a>私信</h1><a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20191201193249127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="私信的数据表"></p>
<p>我们定义的私信字段为id,from_id,to_id,conversation_id（为from_id和to_id的拼接，小的在前面）,content为内容，status为状态，以及create_time。</p>
<p>在dao层我们主要定义了查询当前用户的会话列表、会话数量、某个会话详情、某个会话消息数量以及新增数量、修改消息状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询当前用户的会话列表,针对每个会话只返回一条最新的私信。</span></span><br><span class="line">    <span class="function">List&lt;Message&gt; <span class="title">selectConversation</span><span class="params">(<span class="keyword">int</span> userId,<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">    <span class="comment">// 查询当前用户的会话数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">selectConversationCount</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">    <span class="comment">// 查询某个会话所包含的私信列表</span></span><br><span class="line">    <span class="function">List&lt;Message&gt; <span class="title">selectLetters</span><span class="params">(String conversationId,<span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">    <span class="comment">// 查询某个会话包含的私信数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">selectLetterCount</span><span class="params">(String conversationId)</span></span>;</span><br><span class="line">    <span class="comment">// 查询未读私信的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">selectLetterUnreadCount</span><span class="params">(<span class="keyword">int</span> userId, String conversationId)</span></span>;</span><br><span class="line">    <span class="comment">// 新增消息</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="comment">// 修改消息的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateStatus</span><span class="params">(List&lt;Integer&gt; ids, <span class="keyword">int</span> status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在mapper层我们主要看两个方法的实现。</p>
<p>在这里要注意的就是to和from与用户之间的关系</p>
<p>第一个是查询全部的会话，并返回第一条最新消息。首先我们得到当前用户发送的或者接收的未删除的且不是系统通知的全部会话，然后以conversation_id进行分组，然后得到每个分组最大的id（最新私信），然后在外层得到这些id对应的message即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectConversation"</span> <span class="attr">resultType</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectFields"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from message</span><br><span class="line">    where id in (</span><br><span class="line">        select max(id) from message</span><br><span class="line">        where status != 2</span><br><span class="line">        and from_id != 1</span><br><span class="line">        and (from_id = #&#123;userId&#125; or to_id = #&#123;userId&#125;)</span><br><span class="line">        group by conversation_id</span><br><span class="line">    )</span><br><span class="line">    order by id desc </span><br><span class="line">    limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二个是更新私信状态,其中&lt;foreach&gt;标签用于遍历参数中的ids列表，然后用括号括起来，直接用逗号分隔。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStatus"</span>&gt;</span></span><br><span class="line">    update message set status = #&#123;status&#125;</span><br><span class="line">    where id in</span><br><span class="line">--         open="(" separator="," close=")"表示(id1,id2,id3……)</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="得到私信列表"><a href="#得到私信列表" class="headerlink" title="得到私信列表"></a>得到私信列表</h2><p>得到私信列表同得到帖子列表类似，我们也需要将一个私信封装到一个map里，map中需要存放会话、会话的私信数、未读私信数和会话目标，然后将这些map放入一个列表中，然后放入model中返回。在这里，我们还要查询得到所有会话的未读消息数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/letter/list"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLetterList</span><span class="params">(Model model, Page page)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    User user = hostHolder.getUser();</span><br><span class="line">    <span class="comment">// 分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">"/letter/list"</span>);</span><br><span class="line">    page.setRows(messageService.findConversationCount(user.getId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会话列表</span></span><br><span class="line">    List&lt;Message&gt; conversationList =</span><br><span class="line">            messageService.findConversations(user.getId(),page.getOffset(),page.getLimit());</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; conversations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (conversationList != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Message message : conversationList)&#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"conversation"</span>,message);</span><br><span class="line">            map.put(<span class="string">"letterCount"</span>,messageService.findLetterCount(message.getConversationId()));</span><br><span class="line">            map.put(<span class="string">"UnreadCount"</span>,messageService.findLetterUnreadCount(user.getId(),message.getConversationId()));</span><br><span class="line">            <span class="keyword">int</span> targetId = user.getId() == message.getFromId()? message.getToId() : message.getFromId();</span><br><span class="line">            map.put(<span class="string">"target"</span>,userService.findUserById(targetId));</span><br><span class="line"></span><br><span class="line">            conversations.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"conversations"</span>,conversations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询未读消息数量</span></span><br><span class="line">    <span class="keyword">int</span> letterUnreadCount = messageService.findLetterUnreadCount(user.getId(),<span class="keyword">null</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"letterUnreadCount"</span>,letterUnreadCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/site/letter"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看会话详情"><a href="#查看会话详情" class="headerlink" title="查看会话详情"></a>查看会话详情</h2><p>查看会话详情也是类似，我们需要根据conversation_id查到该会话的所有私信，然后每个私信是一个map，map中存放了from_user和私信内容，所有私信放入一个列表中，然后加入model中，除此之外，model中还要放入该会话的目标user。其实这些需求都是根据前端的页面进行具体实现的，知道了需求才知道要设计什么接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/letter/detail/&#123;conversationId&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLetterDetail</span><span class="params">(@PathVariable(<span class="string">"conversationId"</span>)</span> String conversationId,Page page, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">// 设置分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">"/letter/detail/"</span> + conversationId);</span><br><span class="line">    page.setRows(messageService.findLetterCount(conversationId));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私信列表</span></span><br><span class="line">    List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; letters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (letterList != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Message message : letterList)&#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"letter"</span>,message);</span><br><span class="line">            map.put(<span class="string">"fromUser"</span>,userService.findUserById(message.getFromId()));</span><br><span class="line"></span><br><span class="line">            letters.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"letters"</span>,letters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私信目标</span></span><br><span class="line">    model.addAttribute(<span class="string">"target"</span>,getLetterTarget(conversationId));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息列表里的未读消息改为已读</span></span><br><span class="line">    List&lt;Integer&gt; ids = getLetterIds(letterList);</span><br><span class="line">    <span class="keyword">if</span> (!ids.isEmpty())&#123;</span><br><span class="line">        messageService.readMessage(ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/site/letter-detail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后用户既然已经查看了该会话，那么该会话的所有私信就不应该是未读信息了，要将它们全部置为已读，因此需要得到置为已读私信的id，这些私信满足to_id是当前用户且status为0，当然肯定是该会话的私信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getLetterIds</span><span class="params">(List&lt;Message&gt; letterList)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (letterList != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Message message : letterList)&#123;</span><br><span class="line">            <span class="comment">// 如果这条消息是发送给你的且是未读状态，那么现在你已读了</span></span><br><span class="line">            <span class="keyword">if</span> (hostHolder.getUser().getId() == message.getToId() &amp;&amp; message.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">                ids.add(message.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送私信"><a href="#发送私信" class="headerlink" title="发送私信"></a>发送私信</h2><p>发送私信我们使用ajax的方式，在js中实现，只要声明好路径、数据和回调函数即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send_letter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	$(<span class="string">"#sendModal"</span>).modal(<span class="string">"hide"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> toName = $(<span class="string">"#recipient-name"</span>).val();</span><br><span class="line">	<span class="keyword">var</span> content = $(<span class="string">"#message-text"</span>).val();</span><br><span class="line">	$.post(</span><br><span class="line">		CONTEXT_PATH + <span class="string">"/letter/send"</span>,</span><br><span class="line">		&#123;<span class="string">"toName"</span>:toName,<span class="string">"content"</span>:content&#125;,</span><br><span class="line">		<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">			data = $.parseJSON(data);</span><br><span class="line">			<span class="keyword">if</span> (data.code == <span class="number">0</span>)&#123;</span><br><span class="line">				$(<span class="string">"#hintBody"</span>).text(<span class="string">"发送成功！"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				$(<span class="string">"#hintBody"</span>).text(data.msg);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			$(<span class="string">"#hintModal"</span>).modal(<span class="string">"show"</span>);</span><br><span class="line">			setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				$(<span class="string">"#hintModal"</span>).modal(<span class="string">"hide"</span>);</span><br><span class="line">				location.reload();</span><br><span class="line">			&#125;, <span class="number">2000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在controller层，由于是异步请求，我们需要用@ResponseBody注解声明，然后使用JSON工具返回结果。<br>主要就是检查目标是否存在，然后设置消息的发送方、接收方和会话id，内容和日期，然后调用service即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"letter/send"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sendLetter</span><span class="params">(String toName,String content)</span></span>&#123;</span><br><span class="line">    User target = userService.findUserByName(toName);</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">"目标用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.setFromId(hostHolder.getUser().getId());</span><br><span class="line">    message.setToId(target.getId());</span><br><span class="line">    <span class="keyword">if</span> (message.getFromId() &lt; message.getToId())&#123;</span><br><span class="line">        message.setConversationId(message.getFromId() + <span class="string">"_"</span> + message.getToId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.setConversationId(message.getToId() + <span class="string">"_"</span> + message.getFromId());</span><br><span class="line">    &#125;</span><br><span class="line">    message.setContent(content);</span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    messageService.addMessage(message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CommunityUtil.getJSONString(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常统一处理"><a href="#异常统一处理" class="headerlink" title="异常统一处理"></a>异常统一处理</h1><p>首先使用thymeleaf模板，我们只需要在templates文件夹下创建一个error文件夹，然后把404.html，500.html页面放入，这样发生404、500等错误就会自动显示这两个页面。</p>
<p>然后我们在homecontroller中创建一个/error请求，用于重定向到500页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/error"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getErrorPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/error/500"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们再创建一个异常处理类，统一处理controller发生的异常。</p>
<p>使用@ControllerAdvice注解，通过annotations参数声明只扫描带有Controller注解的Bean。然后用@ExceptionHandler({Exception.class})修饰handleException()方法，该注解表示该方法在Controller出现异常（全部异常）之后调用。通过获取request中的“x-requested-with”参数得到请求方式，如果是XML，则是异步请求，此时通过response的输出流输出JSON对象即可，如果不是异步请求，就重定向到/error请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只扫描带有controller注解的Bean</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(annotations = Controller<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ExceptionAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExceptionAdvice<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 用于修饰方法，该方法在Controller出现异常后被调用</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;Exception<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">HttpServletResponse</span> <span class="title">response</span>)</span>&#123;</span><br><span class="line">        logger.error(<span class="string">"服务器发生异常："</span>+e.getMessage());</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement element : e.getStackTrace())&#123;</span><br><span class="line">            logger.error(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String xRequestedWith =  request.getHeader(<span class="string">"x-requested-with"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"XMLHttpRequest"</span>.equals(xRequestedWith))&#123;</span><br><span class="line">            <span class="comment">// 这说明这是一个异步请求</span></span><br><span class="line">            <span class="comment">// 返回的是一个常规字符串</span></span><br><span class="line">            response.setContentType(<span class="string">"application/plain;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer = response.getWriter();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(CommunityUtil.getJSONString(<span class="number">1</span>,<span class="string">"服务器异常！"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.sendRedirect(request.getContextPath() + <span class="string">"/error"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统一记录日志"><a href="#统一记录日志" class="headerlink" title="统一记录日志"></a>统一记录日志</h2><p>在统一记录日志这里我们需要用到AOP的编程方式。<br>AOP是一种编程思想，即面向切面编程，是对OOP的补充，可以进一步提高编程的效率。<br>我们需要定义一个系统组件贯穿多个业务组件，声明Pointcut(切点)，Advice（解决的是具体织入的系统逻辑），将系统业务封装在Aspect中，将Aspect织入(Weaving)，Joinpoint表示目标对象织入的位置<br><img src="https://img-blog.csdnimg.cn/20191201202412725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="AOP模型"><br>AOP的实现<br><img src="https://img-blog.csdnimg.cn/2019120120244798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="AOP的实现"><br><img src="https://img-blog.csdnimg.cn/2019120120251991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="Spring AOP"></p>
<p>在SpringBoot中使用AOP很简单，我们需要声明一个组件，并用@Aspect注解修饰，首先我们需要定义切点，下面这个切点即service包下的所有java文件的所有方法，对参数也没有限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个*代表方法的返回值，可以为任意值</span></span><br><span class="line"><span class="comment">// com.nowcoder.community.service.*.* 表示service包下的所有类的所有方法</span></span><br><span class="line"><span class="comment">// (..)表示所有的参数</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.nowcoder.community.service.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在切点之前（@Before(“pointcut()”)）</p>
<p>切点之后（@After(“pointcut()”)）</p>
<p>有返回值之后（@AfterReturning(“pointcut()”)）</p>
<p>抛异常之后（@AfterThrowing(“pointcut()”)）</p>
<p>切点之前之后（@Around(“pointcut()”)）</p>
<p>声明并实现相关的方法。</p>
<p>而目前我们只要记录日志，因此只需要在切点之前即可。首先使用@Component@Aspect注解，然后创建一个Logger实例，声明好切点，然后在切点之前调用方法即可，该方法得到request，再用request得到ip，然后使用joinPoint得到类型名和方法名（也就说这些切点实际就是方法？），最后使用“用户xx,在xx时间,访问了xx方法”这样的格式记录日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceLogAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.nowcoder.community.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用户&#123;1.2.3.4&#125;，在&#123;xxx&#125;，访问了[com.nowcoder.community.service.xxx()].</span></span><br><span class="line">        <span class="comment">// 使用工具类得到request</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        String ip = request.getRemoteHost();</span><br><span class="line">        String now = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="comment">// 得到类型名和方法名</span></span><br><span class="line">        String target = joinPoint.getSignature().getDeclaringType() + <span class="string">"."</span> + joinPoint.getSignature().getName();</span><br><span class="line">        logger.info(String.format(<span class="string">"用户[%s],在[%s],访问了[%s]."</span>,ip,now,target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>私信</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-4-帖子</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-4-%E5%B8%96%E5%AD%90/</url>
    <content><![CDATA[<h1 id="过滤敏感词"><a href="#过滤敏感词" class="headerlink" title="过滤敏感词"></a>过滤敏感词</h1><p>过滤敏感词我们主要通过前缀树进行过滤，首先我们需要将所有敏感词全部加入到前缀树中，每一个结点我们需要定义是否是结束的标志和它之下的子节点</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    <span class="comment">// 是否是敏感词结束的标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isKeywordEnd = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 子节点(key是下级字符，value是下级节点)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeywordEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isKeywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeywordEnd</span><span class="params">(<span class="keyword">boolean</span> keywordEnd)</span> </span>&#123;</span><br><span class="line">        isKeywordEnd = keywordEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character c, TrieNode node)</span></span>&#123;</span><br><span class="line">        subNodes.put(c,node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取子节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">getSubNode</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要将每一个敏感词按照规则加入到前缀树中去，每一个敏感词加入到前缀树中我们都需要从根节点开始，然后遍历敏感词，如果当前字符已经在当前结点的子节点中，那么我们直接进行下一个结点，如果不在就把初始化该字符的结点，然后加入当前结点的子节点中，然后进入下一个结点。最后，如果已经是敏感词的结尾，那么我们就要把当前结点的结束标志位设为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addKeyword</span><span class="params">(String keyword)</span></span>&#123;</span><br><span class="line">    TrieNode tempNode = rootNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyword.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = keyword.charAt(i);</span><br><span class="line">        TrieNode subNode = tempNode.getSubNode(c);</span><br><span class="line">        <span class="keyword">if</span> (subNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 初始化子节点</span></span><br><span class="line">            subNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            tempNode.addSubNode(c,subNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指向子节点进入下一轮循环</span></span><br><span class="line">        tempNode = subNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置结束的标识</span></span><br><span class="line">        <span class="keyword">if</span> (i == keyword.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            tempNode.setKeywordEnd(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了添加敏感词方法之后，我们需要有一份敏感词文件，然后就可以进行初始化前缀树了。首先我们需要从classpath中读到sensitive-word文件，然后读入字节流，将字节流转换为缓冲流，最后调用addKeyword()方法将敏感词加入到前缀树中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根节点初始化</span></span><br><span class="line"><span class="keyword">private</span> TrieNode rootNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span>  <span class="comment">//这个注解表示这个方法是初始化方法，在Bean实例化时就会被调用，而Bean在服务启动时被初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 编译之后所有文件都被编译到class中</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 得到字节流</span></span><br><span class="line">            InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"sensitive-words.txt"</span>);</span><br><span class="line">            <span class="comment">// 得到字符流，再转换为缓冲流</span></span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">    )&#123;</span><br><span class="line">        String keyword;</span><br><span class="line">        <span class="keyword">while</span> ((keyword = reader.readLine())!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 添加到前缀树</span></span><br><span class="line">            <span class="keyword">this</span>.addKeyword(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        logger.error(<span class="string">"加载敏感词文件失败:"</span> +e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了初始化完成之后的前缀树之后我们就可以对输入的内容进行过滤了。首先，我们获得根节点，设置两个指针，一个指向敏感词开始的指针，另一个指针指向扫描位置的指针，当用于扫描的指针指向字符串的末尾时表示扫描结束。</p>
<p>在每一次遍历中，我们获得当前扫描位置的字符，如果当前字符是符号（如果当前字符是赌★博，那么我们需要跳过★，但如果是★赌★博★，我们只要跳过中间的那个符号即可），我们就直接跳过，判断下一个字符，position++，但是如果当前节点是根节点，那么该符号是合法的，我们直接判断以下一个字符为开始的字符，即begin++。</p>
<p>然后我们需要检查当前节点的子节点是否有当前字符，如果没有，那么这个begin-position的字符串不是敏感词，那么我们可以将begin加入到StringBuilder中，然后begin++,position=begin，再次从根节点开始；如果有，我们需要判断是否是敏感词的结尾，如果是，我们需要将begin-position的串替换为REPLACEMENT，然后begin从position的下一个开始，同时从根节点重新开始，如果不是，我们就继续检查下一个字符即可。<br>当position结束时，begin还没有结束，此时要将begin-position的字符串也加入到sb中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(text))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指向树的指针</span></span><br><span class="line">    TrieNode tempNode = rootNode;</span><br><span class="line">    <span class="comment">// 指向敏感词开始的指针</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 指向敏感词当前扫描位置的指针</span></span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 过滤之后的结果</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历过程是由begin来定位的，和node比较的是position指向的字符</span></span><br><span class="line">    <span class="keyword">while</span> (position&lt;text.length())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = text.charAt(position);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过符号</span></span><br><span class="line">        <span class="keyword">if</span> (isSymbol(c))&#123;</span><br><span class="line">            <span class="comment">// 若树上的指针指向根节点，将此符号记入结果，让敏感词开始指针前进</span></span><br><span class="line">            <span class="keyword">if</span> (tempNode == rootNode)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个指针是一定会前进的，因为要跳过符号</span></span><br><span class="line">            position++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查下级节点</span></span><br><span class="line">        tempNode = tempNode.getSubNode(c);</span><br><span class="line">        <span class="keyword">if</span> (tempNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果当前串不是敏感词串</span></span><br><span class="line">            sb.append(text.charAt(begin));</span><br><span class="line">            <span class="comment">// 进入下一个位置</span></span><br><span class="line">            position = ++begin;</span><br><span class="line">            <span class="comment">// 重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempNode.isKeywordEnd())&#123;</span><br><span class="line">            <span class="comment">// 如果当前串是敏感词串,则替换该字符串</span></span><br><span class="line">            sb.append(REPLACEMENT);</span><br><span class="line">            <span class="comment">// 进入下一个位置</span></span><br><span class="line">            begin = ++position;</span><br><span class="line">            <span class="comment">// 重新指向根节点</span></span><br><span class="line">            tempNode = rootNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 检查下一个字符</span></span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将最后的字符记入结果</span></span><br><span class="line">    sb.append(text.substring(begin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Component注解使得Springboot在启动时，将该类注册到容器中，并实例化，因此启动的时候就会将前缀树初始化。</p>
<h2 id="发布帖子"><a href="#发布帖子" class="headerlink" title="发布帖子"></a>发布帖子</h2><p>在发布帖子需要注意用户必须登录，然后过滤敏感词</p>
<h2 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h2><p>帖子详情我们需要的信息有帖子、作者和评论。帖子和用户的数据表我们已经给出过了，接下来给出评论的数据表<br><img src="https://img-blog.csdnimg.cn/20191201173916270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="评论数据表"><br>其中，user_id代表发表评论的用户id，entity_type表示评论的对象是什么类型，是回复帖子还是回复其他人的评论，entity_id表示评论的对象的id，target_id表示回复的用户的id，content表示内容，status为0表示正常。</p>
<p>具体的操作我们主要在controller中进行操作，service层主要做的就是调用dao得到数据。查看帖子详情，我们需要从url中得到帖子id，然后调用service得到帖子，再得到帖子的作者，将帖子和作者加入到model中，然后评论多的话我们需要分页，因此需要设置分页信息。</p>
<p>然后我们得到回复帖子的所有评论，然后遍历每一个评论创建一个评论VO（Value Object）列表，方便模板显示。</p>
<p>commentVoList是一个列表，每一项是一个Map，map里需要存放评论、作者和相关的回复，而评论的回复其实也是一个泛型为Comment的列表，因此我们需要通过findCommentsByEntity的方法得到该评论的所有回复，设置entity_type为评论，entity_target为该评论的id，得到所有该评论的回复之后再将所有的reply加入到一个list中，每个reply为一个map，有回复内容，回复作者和回复目标（null或者User），最后将reply列表加入到该条评论的map中即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/detail/&#123;discussPostId&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDiscussPost</span><span class="params">(@PathVariable(<span class="string">"discussPostId"</span>)</span> <span class="keyword">int</span> discussPostId, Model model, Page page)</span>&#123;</span><br><span class="line">    <span class="comment">// 帖子</span></span><br><span class="line">    DiscussPost post = discussPostService.findDiscussPostByid(discussPostId);</span><br><span class="line">    model.addAttribute(<span class="string">"post"</span>,post);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作者</span></span><br><span class="line">    User user = userService.findUserById(post.getUserId());</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 评论分页信息</span></span><br><span class="line">    page.setLimit(<span class="number">5</span>);</span><br><span class="line">    page.setPath(<span class="string">"/discuss/detail/"</span> + discussPostId);</span><br><span class="line">    page.setRows(post.getCommentCount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 评论：得到当前帖子的评论</span></span><br><span class="line">    <span class="comment">// 回复：对评论进行回复</span></span><br><span class="line">    <span class="comment">// 评论列表</span></span><br><span class="line">    List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(ENTITY_TYPE_POST, post.getId(),page.getOffset(),page.getLimit());</span><br><span class="line">    <span class="comment">// 评论VO列表（Value Object），也就是对评论列表进行处理，方便模板显示</span></span><br><span class="line">    List&lt;Map&lt;String,Object&gt;&gt; commentVoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(commentList != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Comment comment : commentList)&#123;</span><br><span class="line">            <span class="comment">// 评论VO</span></span><br><span class="line">            Map&lt;String, Object&gt; commentVo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 评论</span></span><br><span class="line">            commentVo.put(<span class="string">"comment"</span>,comment);</span><br><span class="line">            <span class="comment">// 作者</span></span><br><span class="line">            commentVo.put(<span class="string">"user"</span>,userService.findUserById(comment.getUserId()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复列表</span></span><br><span class="line">            List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(ENTITY_TYPE_COMMENT,comment.getId(),<span class="number">0</span>,Integer.MAX_VALUE);</span><br><span class="line">            <span class="comment">// 回复VO列表</span></span><br><span class="line">            List&lt;Map&lt;String,Object&gt;&gt; replyVoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (replyList != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (Comment reply : replyList)&#123;</span><br><span class="line">                    Map&lt;String,Object&gt; replyVo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 回复</span></span><br><span class="line">                    replyVo.put(<span class="string">"reply"</span>,reply);</span><br><span class="line">                    <span class="comment">// 作者</span></span><br><span class="line">                    replyVo.put(<span class="string">"user"</span>,userService.findUserById(reply.getUserId()));</span><br><span class="line">                    <span class="comment">// 回复目标</span></span><br><span class="line">                    User target = reply.getTargetId() == <span class="number">0</span> ? <span class="keyword">null</span> : userService.findUserById(reply.getTargetId());</span><br><span class="line">                    replyVo.put(<span class="string">"target"</span>,target);</span><br><span class="line"></span><br><span class="line">                    replyVoList.add(replyVo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            commentVo.put(<span class="string">"replys"</span>,replyVoList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该评论的回复数量</span></span><br><span class="line">            <span class="keyword">int</span> replyCount = commentService.findCommentsCount(ENTITY_TYPE_COMMENT,comment.getId());</span><br><span class="line">            commentVo.put(<span class="string">"replyCount"</span>,replyCount);</span><br><span class="line"></span><br><span class="line">            commentVoList.add(commentVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"comments"</span>,commentVoList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/site/discuss-detail"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再模板中我们只需要遍历传入的CommentVOList和每一个评论的回复ReplyVOList即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"media pb-3 pt-3 mb-3 border-bottom"</span> <span class="attr">th:each</span>=<span class="string">"cvo:$&#123;comments&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pb-3 pt-3 mb-3 border-bottom"</span> <span class="attr">th:each</span>=<span class="string">"rvo:$&#123;cvo.replys&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>在添加评论的地方，我们插入了事务的概念，所谓事务就是一系列操作要么全部执行，要么全部不执行。在SpringBoot中我们使用@Transactional注解来注明该方法是事务，isolation表示隔离方式，propagation表示传播机制，<br><img src="https://img-blog.csdnimg.cn/20191201190006336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="隔离方式"><br>而传播机制方面，业务方法A可能会调用业务方法B，此时以哪个业务机制为准<br>    // REQUIRED：支持当前事务（外部事物，即调用者），如果不存在则创建新事务<br>    // REQUIRES_NEW：创建一个新的事务，并且暂停当前事务（外部事物）<br>    // NESTED：如果当前存在事务（外部事务），则嵌套在该事务中执行（独立的提高和回滚），否则就会和REQUIRED一样<br>（还不是很懂）</p>
<p>在添加评论时我们需要对用户输入的内容进行格式化处理(标签等内容不会转义)和过滤敏感词。添加完评论之后，如果是直接对帖子的回复，那么我们需要更新帖子的评论数量，根据entity_type和entity_id来得到评论总数，之所以要两个参数，是因为回复帖子的entity_id是帖子的id，而回复评论的entity_id是评论的id，两者可能会重复因此需要两个参数来定位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addComment</span><span class="params">(Comment comment)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comment == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加评论</span></span><br><span class="line">    comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));</span><br><span class="line">    comment.setContent(sensitiveFilter.filter(comment.getContent()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = commentMapper.insertComment(comment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新帖子评论数量</span></span><br><span class="line">    <span class="keyword">if</span> (comment.getEntityType() == ENTITY_TYPE_POST)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = commentMapper.selectCountByEntity(comment.getEntityType(),comment.getEntityId());</span><br><span class="line">        discussPostService.updateCommentCount(comment.getEntityId(),count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entity_type和entity_id在html中设置了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"input-size"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">placeholder</span>=<span class="string">"请输入你的观点"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entityType"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"entityId"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;cvo.comment.id&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>帖子</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-3-登录</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-3-%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h1><a id="more"></a>

<p>我们使用kaptcha来生成验证码</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先我们需要配置验证码，使用@Configuration表示这是一个配置Bean，@Bean表示获取其他的bean，装配到容器中,bean的名字就是方法名，这样在Controller中就可以注入kaptchaProducer来使用。</p>
<p>Properties主要配置了验证码图片宽度、高度、字体大小、字体颜色和输出范围、输出长度以及实现，然后生成默认的kaptcha，然后封装properties到config中，然后设置kaptcha的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Producer <span class="title">kaptchaProducer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.image.width"</span>,<span class="string">"100"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.image.height"</span>,<span class="string">"40"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.textproducer.font.size"</span>,<span class="string">"32"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.textproducer.font.color"</span>,<span class="string">"0,0,0"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.textproducer.char.string"</span>,<span class="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.textproducer.char.length"</span>,<span class="string">"4"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"kaptcha.noise.impl"</span>,<span class="string">"com.google.code.kaptcha.impl.NoNoise"</span>);</span><br><span class="line"></span><br><span class="line">        DefaultKaptcha kaptcha = <span class="keyword">new</span> DefaultKaptcha();</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        kaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> kaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模板中使用th:src=”@{/kaptcha}来获得验证码，其中refresh_kaptcha()用于刷新验证码，其实就是访问/kaptcha获得验证码，然后放入&lt;img&gt;中即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/kaptcha&#125;"</span> <span class="attr">id</span>=<span class="string">"kaptcha"</span> <span class="attr">style</span>=<span class="string">"width:100px;height:40px;"</span> <span class="attr">class</span>=<span class="string">"mr-2"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:refresh_kaptcha();"</span> <span class="attr">class</span>=<span class="string">"font-size-12 align-bottom"</span>&gt;</span>刷新验证码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">refresh_kaptcha</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 随机数欺骗浏览器，防止连接不变浏览器不跳转</span></span><br><span class="line">		<span class="keyword">var</span> path = CONTEXT_PATH + <span class="string">"/kaptcha?p="</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">		$(<span class="string">"#kaptcha"</span>).attr(<span class="string">"src"</span>,path);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后再看controller中，注入之前声明了的kaptchaProducer，然后使用Produce提供的方法生成验证码和图片，然后将验证码写入session中（每个用户都有自己的session，服务器会将sessionId写入cookie中返回给用户，下次用户访问时带着cookie，服务器根据cookie中的sessionId得到session的内容）。然后将图片输出给浏览器，具体是得到response的输出流，然后使用ImageIO.write将image以png格式放到os中输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Producer kaptchaProducer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/kaptcha"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKaptcha</span><span class="params">(HttpServletResponse response, HttpSession session)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成验证码</span></span><br><span class="line">    String text = kaptchaProducer.createText();</span><br><span class="line">    BufferedImage image = kaptchaProducer.createImage(text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将验证码存入session</span></span><br><span class="line">    session.setAttribute(<span class="string">"kaptcha"</span>,text);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将图片输出给浏览器</span></span><br><span class="line">    response.setContentType(<span class="string">"image/png"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用response输出流输出</span></span><br><span class="line">        OutputStream os = response.getOutputStream();</span><br><span class="line">        ImageIO.write(image, <span class="string">"png"</span>, os);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"响应验证码失败："</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>login的模板和注册类似不再给出，需要注意的就是${param.username}相当于spring中的request.getParameter，用于登陆失败时用户输入的内容还在。</p>
<p>在Controller层用户需要给出账号密码、验证码、是否记住，同时需要用到session和response。</p>
<p>首先我们需要从session中获取验证码然后和用户输入的进行对比，如果出现错误就写入codeMsg并返回，然后我们需要根据rememberme得到登录凭证的过期时间，具体内容还是在CommunityConstant中设置了，没勾选的话是12小时，勾选的话是100天。然后调用service层进行账号密码验证，如果登录成功就将登录凭证存入浏览器的Cookie中，并设置内容、路径、过期时间，登录成功之后重定向到首页，如果登录失败就把提示信息装入model中，然后返回登录页。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/login"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username,String password,String code,<span class="keyword">boolean</span> rememberme,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Model model, HttpSession session, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    String kaptcha = (String) session.getAttribute(<span class="string">"kaptcha"</span>);</span><br><span class="line">    <span class="comment">// 验证验证码</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"codeMsg"</span>,<span class="string">"验证码不正确"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查账号密码</span></span><br><span class="line">    <span class="keyword">int</span> expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS:DEFAULT_EXPIRED_SECONDS;</span><br><span class="line">    Map&lt;String,Object&gt; map = userService.login(username,password,expiredSeconds);</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(<span class="string">"ticket"</span>))&#123;</span><br><span class="line">        <span class="comment">// 登录成功就将凭证存入到浏览器的cookie中</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"ticket"</span>,map.get(<span class="string">"ticket"</span>).toString());</span><br><span class="line">        cookie.setPath(contextPath);</span><br><span class="line">        cookie.setMaxAge(expiredSeconds);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">"usernameMsg"</span>,map.get(<span class="string">"usernameMsg"</span>));</span><br><span class="line">        model.addAttribute(<span class="string">"passwordMsg"</span>,map.get(<span class="string">"passwordMsg"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看service层，主要是对空值进行处理，然后调用userMapper验证账号，如果没有激活，那么不能登录，然后再验证密码，如果登录成功就生成登录凭证，最后把登录凭证的ticket放入map中返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">login</span><span class="params">(String username,String password,<span class="keyword">int</span> expiredSeconds)</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空值处理</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username))&#123;</span><br><span class="line">        map.put(<span class="string">"usernameMsg"</span>,<span class="string">"账号不能为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password))&#123;</span><br><span class="line">        map.put(<span class="string">"passwordMsg"</span>,<span class="string">"密码不能为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证账号</span></span><br><span class="line">    User user = userMapper.selectByName(username);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(<span class="string">"usernameMsg"</span>,<span class="string">"该账号不存在"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有激活</span></span><br><span class="line">    <span class="keyword">if</span> (user.getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">        map.put(<span class="string">"usernameMsg"</span>,<span class="string">"该账号未激活"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证密码</span></span><br><span class="line">    password = CommunityUtil.md5(password + user.getSalt());</span><br><span class="line">    <span class="keyword">if</span> ( !user.getPassword().equals(password))&#123;</span><br><span class="line">        map.put(<span class="string">"passwordMsg"</span>,<span class="string">"密码不正确"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成登录凭证</span></span><br><span class="line">    LoginTicket loginTicket = <span class="keyword">new</span> LoginTicket();</span><br><span class="line">    loginTicket.setUserId(user.getId());</span><br><span class="line">    loginTicket.setTicket(CommunityUtil.generateUUID());</span><br><span class="line">    loginTicket.setStatus(<span class="number">0</span>);</span><br><span class="line">    loginTicket.setExpired(<span class="keyword">new</span> Date(System.currentTimeMillis() + expiredSeconds*<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">    loginTicketMapper.insertLoginTicket(loginTicket);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">"ticket"</span>,loginTicket.getTicket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们看一下登录凭证的数据表结构<br><img src="https://img-blog.csdnimg.cn/20191130194508788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="登录凭证数据表"><br>其中id是主键，user_id表示用户id，ticket表示登录凭证，浏览器的cookie中带有这个时我们可以到数据库中查询，如果存在就直接让用户登录，status表示是否有效，expired表示过期时间。</p>
<p>在dao中我们只要声明3个方法，分别是新增、查询和更新</p>
<p>这里我们不在mapper中创建.xml文件，而是通过注解的方法实现具体的数据库操作。在@Insert注解中写明具体的sql语句，在@Options中声明主键和是否自增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginTicketMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(&#123;</span><br><span class="line">            <span class="string">"insert into login_ticket(user_id,ticket,status,expired) "</span>,</span><br><span class="line">            <span class="string">"values(#&#123;userId&#125;,#&#123;ticket&#125;,#&#123;status&#125;,#&#123;expired&#125;)"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>,keyProperty = <span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertLoginTicket</span><span class="params">(LoginTicket loginTicket)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(&#123;</span><br><span class="line">            <span class="string">"select id,user_id,ticket,status,expired "</span>,</span><br><span class="line">            <span class="string">"from login_ticket where ticket = #&#123;ticket&#125;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">LoginTicket <span class="title">selectByTicket</span><span class="params">(String ticket)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(&#123;</span><br><span class="line">            <span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">            <span class="string">"update login_ticket set status=#&#123;status&#125; where ticket = #&#123;ticket&#125;"</span>,</span><br><span class="line">            <span class="string">"&lt;if test=\"ticket!=null\"&gt;"</span>,</span><br><span class="line">            <span class="string">"and 1=1 "</span>,</span><br><span class="line">            <span class="string">"&lt;/if&gt;"</span>,</span><br><span class="line">            <span class="string">"&lt;/script&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateStatus</span><span class="params">(String ticket,<span class="keyword">int</span> status)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h1><p>登出很简单，只要在cookie中得到ticket凭证，然后在数据库中将该ticket的status改为1即可，其中@CookieValue用于获得cookie中名为”ticket”的属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/logout"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(@CookieValue(<span class="string">"ticket"</span>)</span> String ticket)</span>&#123;</span><br><span class="line">    userService.logout(ticket);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="显示登录信息"><a href="#显示登录信息" class="headerlink" title="显示登录信息"></a>显示登录信息</h1><p>我们需要将通过ticket登录的用户的用户信息存入内存中。因此我们需要实现两个功能，一个是能够将cookie中的内容读到，然后使用ticket进行登录，第二个是如何将当前登录的用户信息存入内存中。</p>
<p>首先我们实现如何将用户信息存入内存中，本来我们可以将用户信息存入session中，但是这会增大服务器压力。这里我们使用ThreadLocal来实现，这个类以线程为key，value为对象，也就是不同的用户是不同的线程，也就是不同的key，调用get()，会得到自己线程的user对象，set()会以当前线程的id为key存放user，clear()用于清除users</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持有用户的信息，用于代替session对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以线程为key取得map，存取值</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;User&gt; users = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        users.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        users.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后读取cookie中的内容，我们需要实现一个拦截器，这个拦截器可以在每次controller之前，调用controller之后以及模板引擎执行完之后执行相应的方法。</p>
<p>preHandle()方法主要用于在调用controller之前执行，也就是在这里我们使用cookie中的凭证去验证用户是否需要登录。在查询凭证是否有效时，我们需要查看是否有该凭证，该凭证的status和过期时间。如果有效就使用userService查询相关用户并加入hostHolder中的users中。</p>
<p>postHandle()主要将hostHolder中的user加入到模板中，这样就能在模板中直接获取登录用户的信息了。<br>afterCompletion()用于在完成模板渲染之后清除users。</p>
<p>（该方法的在每次请求controller都会调用该拦截器一次，代价是不是有点高？）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTicketInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从cookie中获取凭证</span></span><br><span class="line">        String ticket = CookieUtil.getValue(request,<span class="string">"ticket"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ticket != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 查询凭证</span></span><br><span class="line">            LoginTicket loginTicket = userService.findLoginTicket(ticket);</span><br><span class="line">            <span class="comment">// 判断凭证是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (loginTicket != <span class="keyword">null</span> &amp;&amp; loginTicket.getStatus() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    loginTicket.getExpired().after(<span class="keyword">new</span> Date()))&#123;</span><br><span class="line">                <span class="comment">// 根据凭证获得用户</span></span><br><span class="line">                User user = userService.findUserById(loginTicket.getUserId());</span><br><span class="line">                System.out.println(user.getUsername());</span><br><span class="line">                <span class="comment">// 在本次请求中持有用户（暂存到当前线程对应的map中）</span></span><br><span class="line">                hostHolder.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = hostHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; modelAndView != <span class="keyword">null</span>)&#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">"loginUser"</span>,user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        hostHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明好拦截器之后，我们还需要将该拦截器配置好。</p>
<p>在该配置类中需要实现WebMvcConfigurer接口，也就是addInterceptors()，也就是添加拦截器方法，需要注明添加的拦截器和不拦截的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTicketInterceptor loginTicketInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginRequiredInterceptor loginRequiredInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册接口，添加拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(loginTicketInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/**/*.css"</span>,<span class="string">"/**/*.js"</span>,<span class="string">"/**/*.png"</span>,  <span class="comment">// /**表示static下所有目录</span></span><br><span class="line">                        <span class="string">"/**/*.jpg"</span>,<span class="string">"/**/*.jpeg"</span>);                        <span class="comment">// 表示不拦截</span></span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(loginRequiredInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/**/*.css"</span>,<span class="string">"/**/*.js"</span>,<span class="string">"/**/*.png"</span>,  <span class="comment">// /**表示static下所有目录</span></span><br><span class="line">                        <span class="string">"/**/*.jpg"</span>,<span class="string">"/**/*.jpeg"</span>);                        <span class="comment">// 表示不拦截</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="更新头像"><a href="#更新头像" class="headerlink" title="更新头像"></a>更新头像</h1><p>在html中我们设置&lt;input&gt;的类型为file用于上传文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"custom-file"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">th:class</span>=<span class="string">"|custom-file-input $&#123;error!=null?'is-invalid':''&#125;|"</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">id</span>=<span class="string">"head-image"</span> <span class="attr">name</span>=<span class="string">"headerImage"</span> <span class="attr">lang</span>=<span class="string">"es"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"custom-file-label"</span> <span class="attr">for</span>=<span class="string">"head-image"</span> <span class="attr">data-browse</span>=<span class="string">"文件"</span>&gt;</span>选择一张图片<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"invalid-feedback"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;error&#125;"</span>&gt;</span></span><br><span class="line">		该账号不存在!</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在controller中我们使用MultipartFile接收file，获得图片的后缀名，然后生成随机的文件名，确定文件存放的位置，这里我们将用户头像存在服务器本地，在application.properties中设置了community.path.upload。然后使用MultipartFile的transferTo()方法保存图片。然后我们还需要更新用户的头像链接，使用hostHolder得到当前用户，然后更新为我们自定义的路径<a href="http://localhost:8080/community/user/header/xxx.png，最后重定向到首页。" target="_blank" rel="noopener">http://localhost:8080/community/user/header/xxx.png，最后重定向到首页。</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/upload"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headerImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"error"</span>,<span class="string">"您还没有选择图片"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/setting"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String fileName = headerImage.getOriginalFilename();</span><br><span class="line">    String suffix = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(suffix))&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"error"</span>,<span class="string">"文件格式不正确"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/site/setting"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机文件名</span></span><br><span class="line">    fileName = CommunityUtil.generateUUID() + suffix;</span><br><span class="line">    <span class="comment">// 确定文件存放的路径</span></span><br><span class="line">    File dest = <span class="keyword">new</span> File(uploadPath + <span class="string">"/"</span> + fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 存储文件</span></span><br><span class="line">        headerImage.transferTo(dest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"上传文件失败"</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"上传文件失败，服务器发生异常！"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前用户的头像路径(web访问路径)</span></span><br><span class="line">    <span class="comment">// http://localhost:8080/community/user/header/xxx.png</span></span><br><span class="line">    User user = hostHolder.getUser();</span><br><span class="line">    String headerUrl = domain + contextPath + <span class="string">"/user/header/"</span> + fileName;</span><br><span class="line">    userService.updateHeader(user.getId(),headerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户更新完头像，到首页之后，获取头像访问头像链接，此时我们需要从服务器本地将图像加载并显示。从url中得到文件名，从文件名中得到后缀名，然后使用response设置好文件类型。</p>
<p>从本地读入图片到输入流，得到response的输出流，然后声明一个byte数组，从文件输入流中读取数据到数组中，最后将数组中的内容写入输出流中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/header/&#123;fileName&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHeader</span><span class="params">(@PathVariable(<span class="string">"fileName"</span>)</span> String fileName, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">// 服务器存放图片的路径</span></span><br><span class="line">    fileName = uploadPath + <span class="string">"/"</span> + fileName;</span><br><span class="line">    String suffix = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">    <span class="comment">// 响应图片</span></span><br><span class="line">    response.setContentType(<span class="string">"image/"</span> + suffix);</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建文件输入流</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            OutputStream os = response.getOutputStream();</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"读取头像失败"</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="检查登录状态"><a href="#检查登录状态" class="headerlink" title="检查登录状态"></a>检查登录状态</h1><p>有些路径必须登录才能访问，因此我们需要对用户是否登录进行检查。</p>
<p>我们可以通过自定义一个注解，使用该注解的方法必须用户登录才能访问。</p>
<p>自定义注解我们只需要说明该注解的作用目标，注解起作用的时长，然后使用@interface声明即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义注解，方便在拦截器中进行处理</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)             <span class="comment">//表示注解是对方法起作用的</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)     <span class="comment">//表示注解起作用的时长</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们还需要声明一个拦截器用于检查用户是否登录。该拦截器主要在controller之前调用，如果拦截到的可以转换为方法的话，那么表示可能是我们自定义注解的方法，此时就检查该方法的注解是否有我们自定义的LoginRequired，如果有并且用户没有登录的话就重定向到登录页面，并且返回false不再执行controller方法，没有的话就返回true，执行controller方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequiredInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HostHolder hostHolder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="comment">// 如果拦截到的可以转换为方法的话</span></span><br><span class="line">            HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">            <span class="comment">// 得到拦截到的内容的方法</span></span><br><span class="line">            Method method = handlerMethod.getMethod();</span><br><span class="line">            <span class="comment">// 从方法中得到注解</span></span><br><span class="line">            LoginRequired loginRequired = method.getAnnotation(LoginRequired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 如果有loginRequired注解且没有登录的话就进行重定向</span></span><br><span class="line">            <span class="keyword">if</span> (loginRequired != <span class="keyword">null</span> &amp;&amp; hostHolder.getUser() == <span class="keyword">null</span>)&#123;</span><br><span class="line">                response.sendRedirect(request.getContextPath() + <span class="string">"/login"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中设置、上传头像等功能都需要登录才能使用，因此需要该注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/setting"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSettingPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LoginRequired</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/upload"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadHeader</span><span class="params">(MultipartFile headerImage, Model model)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志有debug、info、warn、error四种级别，不同的级别我们需要进行不同的处理，因此我们需要进行配置，其具体格式如下，其中&lt;property name=”LOG_PATH” value=”D:/work/data”/&gt;配置了日志存储路径，&lt;property name=”APPDIR” value=”community”/&gt;配置了应用的名字。其中error,warn,info我们都存入文件中，debug我们在console中打印。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_PATH"</span> <span class="attr">value</span>=<span class="string">"D:/work/data"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"APPDIR"</span> <span class="attr">value</span>=<span class="string">"community"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- error file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE_ERROR"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        当日志超过5M就要新建一个，路径和命名方式如fileNamePattern规定所示--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            最长存放时间--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        以追加方式存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        日志格式 日期 级别 线程 日志所在的类 文件行数 提示消息 换行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        过滤器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- warn file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE_WARN"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_warn.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/warn/log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- info file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE_INFO"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/info/log-info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- console --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.nowcoder.community"</span> <span class="attr">level</span>=<span class="string">"debug"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE_ERROR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE_WARN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE_INFO"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在java类中，我们可以这么使用，其中getLogger()的参数是该类的.class实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(UserController<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>登录</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-2-注册功能</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-2-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><a id="more"></a>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>首先需要在邮箱开启POP3/SMTP服务</p>
<p>然后在application.properites中进行相关配置，host和端口号一般固定，QQ邮箱用户名一般为邮箱账号，但是密码不是账号密码，需要在QQ邮箱生成授权码，并把auth设置为true，后两个表示安全的smtp协议和ssl安全连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MailProperties</span><br><span class="line">spring.mail.host&#x3D;smtp.qq.com</span><br><span class="line">spring.mail.port&#x3D;465</span><br><span class="line">spring.mail.username&#x3D;...</span><br><span class="line">spring.mail.password&#x3D;fkkyftihflsmjjhe</span><br><span class="line">spring.mail.properties.mail.smtp.auth&#x3D;true</span><br><span class="line"># 使用的是安全的smtp协议</span><br><span class="line">spng.mail.protocol&#x3D;smtps</span><br><span class="line"># 采用ssl安全连接</span><br><span class="line">spring.mail.properties.mail.smtp.ssl.enable&#x3D;true</span><br></pre></td></tr></table></figure>
<h1 id="使用Springboot发送邮件"><a href="#使用Springboot发送邮件" class="headerlink" title="使用Springboot发送邮件"></a>使用Springboot发送邮件</h1><p>首先我们需要制作一个发送邮件的工具类,@Component注解表示该类是一个通用的Bean，日志相关内容会在登录模块之后进行解释</p>
<p>使用JavaMailSender类发送邮件，得到发送方，然后在sendMail方法中设置MineMessage（邮件主体），使JavaMailSender创建一个主体，再使用MimeMessageHelper对邮件主体进行封装，设置发送方和收件方，设置主题，设置内容，然后再使用邮件主体发送邮件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通用的Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MailClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于发生邮件</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将发送人注入到bean中</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.mail.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to,String subject,String content)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建MimeMessage，即邮件主体</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            MimeMessage message = mailSender.createMimeMessage();</span><br><span class="line">            MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message);</span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            <span class="comment">// 设置主题</span></span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            <span class="comment">// 设置内容</span></span><br><span class="line">            helper.setText(content,<span class="keyword">true</span>);</span><br><span class="line">            mailSender.send(helper.getMimeMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"发送邮件失败："</span>+ e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过@Value获得在application.properties中配置的community.path.domain并赋值给domain，contextPath也同理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;community.path.domain&#125;"</span>)</span><br><span class="line"> <span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Value</span>(<span class="string">"$&#123;server.servlet.context-path&#125;"</span>)</span><br><span class="line"> <span class="keyword">private</span> String contextPath;</span><br></pre></td></tr></table></figure>

<p>在service中发送邮件,使用thymeleaf提供的context，设置email属性，并将发送方的邮件赋给该属性，接下来我们需要定义一个激活邮件的连接，用户点击该连接对其邮箱进行激活。格式如<a href="http://localhost:8080/community/activation/101/code，其中101表示用户id（创建之后自动生成），code表示激活码，然后将该链接赋值到context的url属性中，然后使用context对模板中的内容进行替换，替换之后的html赋值给content，然后使用mailClient工具类进行发送" target="_blank" rel="noopener">http://localhost:8080/community/activation/101/code，其中101表示用户id（创建之后自动生成），code表示激活码，然后将该链接赋值到context的url属性中，然后使用context对模板中的内容进行替换，替换之后的html赋值给content，然后使用mailClient工具类进行发送</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活邮件</span></span><br><span class="line">Context context = <span class="keyword">new</span> Context();</span><br><span class="line">context.setVariable(<span class="string">"email"</span>,user.getEmail());</span><br><span class="line"><span class="comment">// http://localhost:8080/community/activation/101/code</span></span><br><span class="line">String url = domain + contextPath + <span class="string">"/activation/"</span> + user.getId() + <span class="string">"/"</span> + user.getActivationCode();</span><br><span class="line">context.setVariable(<span class="string">"url"</span>,url);</span><br><span class="line"><span class="comment">// 替换模板中的内容</span></span><br><span class="line">String content = templateEngine.process(<span class="string">"/mail/activation"</span>,context);</span><br><span class="line">System.out.println(content);</span><br><span class="line"></span><br><span class="line">mailClient.sendMail(user.getEmail(),<span class="string">"激活账号"</span>,content);</span><br></pre></td></tr></table></figure>
<p>如下就是邮件模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">"$&#123;email&#125;"</span>&gt;</span>xxx@xxx.com<span class="tag">&lt;/<span class="name">b</span>&gt;</span>, 您好!</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">			您正在注册牛客网, 这是一封激活邮件, 请点击 </span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"$&#123;url&#125;"</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line">			激活您的牛客账号!</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>首先我们给出用户的数据表内容，entity、mapper将不再给出，只给出dao中的接口</p>
<p>id是主键，salt表示盐，用于对password进行md5加密，type表示用户类型，status表示用户状态，activation表示激活码，header_url表示用户头像链接，create_time表示创建时间<br><img src="https://img-blog.csdnimg.cn/20191130161907298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="用户数据表"></p>
<p>接下来，给出dao的用户接口方法，分别是根据id,name,email查询用户，增加用户，更新头像，更新密码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectByName</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">selectByEmail</span><span class="params">(String email)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateStatus</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateHeader</span><span class="params">(<span class="keyword">int</span> id, String headerUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updatePassword</span><span class="params">(<span class="keyword">int</span> id, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在service层中，我们需要对用户传入的数据进行检查，对各种错误信息封装到map中，主要对空值和重复值进行验证。注册用户其实就是实例化一个user，然后调用mapper的insert方法加入数据库，其中salt和激活码都是使用CommunityUtil.generateUUID()生成的，在CommunityUtil中封装了md5方法和生成UUID的方法，头像链接使用的是牛客提供的网址”<a href="http://images.nowcoder.com/head/%dt.png，其中%d需要替换成0-1000之间的整数" target="_blank" rel="noopener">http://images.nowcoder.com/head/%dt.png，其中%d需要替换成0-1000之间的整数</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">register</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对空值处理</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getUsername()))&#123;</span><br><span class="line">            map.put(<span class="string">"usernameMsg"</span>,<span class="string">"账号不能为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getPassword()))&#123;</span><br><span class="line">            map.put(<span class="string">"passwordMsg"</span>,<span class="string">"密码不能为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getEmail()))&#123;</span><br><span class="line">            map.put(<span class="string">"emailMsg"</span>,<span class="string">"邮箱不能为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证账号</span></span><br><span class="line">        User u = userMapper.selectByName(user.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(<span class="string">"usernameMsg"</span>,<span class="string">"该账号已存在!"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证邮箱</span></span><br><span class="line">        u = userMapper.selectByEmail(user.getEmail());</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(<span class="string">"emailMsg"</span>,<span class="string">"该邮箱已被注册!"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册用户</span></span><br><span class="line">        user.setSalt(CommunityUtil.generateUUID().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">        user.setPassword(CommunityUtil.md5(user.getPassword()+user.getSalt()));</span><br><span class="line">        user.setType(<span class="number">0</span>);</span><br><span class="line">        user.setStatus(<span class="number">0</span>);</span><br><span class="line">        user.setActivationCode(CommunityUtil.generateUUID());</span><br><span class="line">        user.setHeaderUrl(String.format(<span class="string">"http://images.nowcoder.com/head/%dt.png"</span>,<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>)));</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        userMapper.insertUser(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 激活邮件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在controller层中，我们需要使用POST方法进行注册，如果map为空这说明service层没有发送错误，那就提示用户去激活，和设置跳转页；如果有错误那就将Msg封装进model中，在模板中渲染</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/register"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(Model model, User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 会自动将User传入Model</span></span><br><span class="line">        Map&lt;String,Object&gt; map = userService.register(user);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span> || map.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 如果注册成功,跳转到首页</span></span><br><span class="line">            model.addAttribute(<span class="string">"msg"</span>,<span class="string">"注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活!"</span>);</span><br><span class="line">            model.addAttribute(<span class="string">"target"</span>,<span class="string">"/index"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/site/operate-result"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"usernameMsg"</span>,map.get(<span class="string">"usernameMsg"</span>));</span><br><span class="line">            model.addAttribute(<span class="string">"passwordMsg"</span>,map.get(<span class="string">"passwordMsg"</span>));</span><br><span class="line">            model.addAttribute(<span class="string">"emailMsg"</span>,map.get(<span class="string">"emailMsg"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/site/register"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后来看register模板和operate-result模板</p>
<p>头部使用th:replace=”index::header”进行覆盖</p>
<p>&lt;input&gt;中的name与User类中的username对应，class中如果usernameMsg不为空说明用户名有错，那么is-invalid会存在，此时&lt;div class=“invalid-feedback”&gt;就会出现，value中如果user不为空的话那就设置为user.username，主要是为了注册失败返回原页面用户输入的内容还在(user是SpringBoot传入model中)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"bg-dark sticky-top"</span> <span class="attr">th:replace</span>=<span class="string">"index::header"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-10"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--							name和Controller中的对象属性名相对应--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--							只有当存在usernameMsg时input才有is-invalid样式，有该样式提示信息才会出现--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">th:class</span>=<span class="string">"|form-control $&#123;usernameMsg != null?'is-invalid':''&#125;|"</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">th:value</span>=<span class="string">"$&#123;user!=null?user.username:''&#125;"</span></span></span><br><span class="line"><span class="tag">		   <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"请输入您的账号!"</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"invalid-feedback"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;usernameMsg&#125;"</span>&gt;</span></span><br><span class="line">		该账号已存在!</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container mt-5"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jumbotron"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"lead"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span>&gt;</span>您的账号已经激活成功,可以正常使用了!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"my-4"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">				系统会在 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"seconds"</span> <span class="attr">class</span>=<span class="string">"text-danger"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 秒后自动跳转,</span><br><span class="line">				您也可以点此 <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"target"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;target&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"text-primary"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>, 手动跳转!</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="激活账号"><a href="#激活账号" class="headerlink" title="激活账号"></a>激活账号</h2><p>// <a href="http://localhost:8080/community/activation/101/code" target="_blank" rel="noopener">http://localhost:8080/community/activation/101/code</a></p>
<p>在sercive层中通过传入的user_id得到用户，如果用户状态码已经是1了那么返回激活重复提示信息（在CommunityConstant中声明），如果该链接的code和用户的激活code相同，那么我们只要将用户的状态设置为1即可，返回激活成功激活码，其他情况都返回激活失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">activation</span><span class="params">(<span class="keyword">int</span> userId,String code)</span></span>&#123;</span><br><span class="line">     User user = userMapper.selectById(userId);</span><br><span class="line">     <span class="keyword">if</span> (user.getStatus() == <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> ACTIVATION_REPEAT;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user.getActivationCode().equals(code))&#123;</span><br><span class="line">         userMapper.updateStatus(userId,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">return</span> ACTIVATION_SUCCESS;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> ACTIVATION_FAIL;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在controller层中，我们使用@PathVariable注解得到url中的userId和code，然后调用service即可，根据返回的状态码设置操作结果模板并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(path = <span class="string">"/activation/&#123;userId&#125;/&#123;code&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">activation</span><span class="params">(Model model, @PathVariable(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId,</span></span><br><span class="line"><span class="function">                          @<span class="title">PathVariable</span><span class="params">(<span class="string">"code"</span>)</span> String code)</span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = userService.activation(userId,code);</span><br><span class="line">     <span class="keyword">if</span> (result == ACTIVATION_SUCCESS)&#123;</span><br><span class="line">         model.addAttribute(<span class="string">"msg"</span>,<span class="string">"激活成功，您的账号可以正常使用了"</span>);</span><br><span class="line">         model.addAttribute(<span class="string">"target"</span>,<span class="string">"/login"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == ACTIVATION_REPEAT)&#123;</span><br><span class="line">         model.addAttribute(<span class="string">"msg"</span>,<span class="string">"无效的操作，该账号已经激活过"</span>);</span><br><span class="line">         model.addAttribute(<span class="string">"target"</span>,<span class="string">"/index"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         model.addAttribute(<span class="string">"msg"</span>,<span class="string">"激活失败，您提供的激活码不正确"</span>);</span><br><span class="line">         model.addAttribute(<span class="string">"target"</span>,<span class="string">"/index"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"/site/operate-result"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在CommunityUtil实用类中封装了md5加密和生成UUID的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateUUID</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MD5加密</span></span><br><span class="line"><span class="comment">// password + salt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在CommunityConstant中声明了各种状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommunityConstant</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ACTIVATION_SUCCESS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重复激活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ACTIVATION_REPEAT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 激活失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ACTIVATION_FAIL = <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>注册</tag>
      </tags>
  </entry>
  <entry>
    <title>总结-1-首页内容</title>
    <url>/2020/01/30/%E6%80%BB%E7%BB%93-1-%E9%A6%96%E9%A1%B5%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>  首页的功能主要是展现帖子，需要做到能分页展示和导航栏根据用户是否登录给出不同的显示</p>
<a id="more"></a>

<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.thymeleaf.cache=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>表示关闭thymeleaf的缓存，开发过程中要关闭，上线之后可以开启</p>
<h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>在<html>标签中使用xmlns申明启用thymeleaf模板引擎</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用模板申明静态资源<br>默认情况下，Spring Boot从classpath下一个叫/static的文件夹下查找</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/css/global.css&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/global.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/js/index.js&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以通过 th:if 确定该标签是否要显示，下面表示如果loginUser为空的话才显示标签内容，loginUser在哪里引入会在登录注册模块解释</p>
<p>th:href=”@{/register}”表示会导向127.0.0.1:8080/community/register链接，其中community在application.properties中配置了表示项目的context路径，类似前缀</p>
<p>thymeleaf中用$表示引用变量，用@表示链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item ml-3 btn-group-vertical"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;loginUser==null&#125;"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/register&#125;"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在头部标签通过设置th:fragment设置名字，方便其他模板复用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"bg-dark sticky-top"</span> <span class="attr">th:fragment</span>=<span class="string">"header"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>我们需要定义一个Page实体类，需要当前页码current，每页最多几个条目limit，数据的总数rows和查询路径path（用于复用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 显示上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 数据的总数（用于计算总的页数）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="comment">// 查询路径（用于复用分页链接）</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前页的起始行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOffset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (current-<span class="number">1</span>)*limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总的页数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rows % limit == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rows/limit;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rows/limit + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取起始页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> from = current - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> from &lt; <span class="number">1</span> ? <span class="number">1</span> : from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> to = current+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> total = getTotal();</span><br><span class="line">        <span class="keyword">return</span> to &gt; total ? total : to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在controller中，我们需要传入一个Page类型的变量page和一个Model，SpringMVC会自动实例化Model和Page，并将page注入model中。</p>
<p>每次使用分页我们都要设置总数和路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIndexPage</span><span class="params">(Model model, Page page)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法调用之前SpringMVC会自动实例化Model和Page，并将Page注入Model</span></span><br><span class="line">        <span class="comment">// 所以在thymeleaf中可以直接访问Page对象中的数据</span></span><br><span class="line">        page.setRows(discussPostService.findDiscussPostRows(<span class="number">0</span>));</span><br><span class="line">        page.setPath(<span class="string">"/index"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/index"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在模板引擎中，同样需要通过总数判断是否需要分页，通过th:fragment设置名字方便复用。分页主要有五个成分，分别是首页、上一页按钮、具体页码下一页和末页。</p>
<p>页码的跳转主要通过th:href=”@{${page.path}(current=${page.current-1})}”实现，其中path设置了当前路径，(current=…)表示向url路径里传入?current=…的参数,SpringBoot会自动将page的current属性设置为目标值。首页设为1，末页设为最后一页，上一页-1，后一页+1</p>
<p>th:class=”|page-item ${page.current==1?’disabled’:’’}|”中的| |表示既有静态参数，也有动态参数，这句话就是根据当前页是否为1来设置disabled属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"mt-5"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;page.rows&gt;0&#125;"</span> <span class="attr">th:fragment</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination justify-content-center"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"page-item"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--							(current=1)表示参数为current=1,即...?current=1--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"page-link"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;page.path&#125;(current=1)&#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--						| |表示其中有静态值也有动态值--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">"|page-item $&#123;page.current==1?'disabled':''&#125;|"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"page-link"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--					$&#123;&#125;内部的变量不用再用$引用--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">"|page-item $&#123;i==page.current?'active':''&#125;|"</span> <span class="attr">th:each</span>=<span class="string">"i:$&#123;#numbers.sequence(page.from,page.to)&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"page-link"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;i&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">"|page-item $&#123;page.current==page.total?'disabled':''&#125;|"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"page-link"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;"</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"page-item"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"page-link"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;"</span>&gt;</span>末页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>首先需要和数据库进行连接，使用jdbc进行连接，设置好连接url，用户名，密码，数据源种类、最大连接池、超时时间等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DataSourceProperties</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;community?characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;Hongkong</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;root</span><br><span class="line">spring.datasource.type&#x3D;com.zaxxer.hikari.HikariDataSource</span><br><span class="line">spring.datasource.hikari.maximum-pool-size&#x3D;15</span><br><span class="line">spring.datasource.hikari.minimum-idle&#x3D;5</span><br><span class="line">spring.datasource.hikari.idle-timeout&#x3D;30000</span><br></pre></td></tr></table></figure>
<p>然后要配置Mybatis相关内容，文件存放位置为classpath:mapper文件夹下所有.xml文件，即resource/mapper之下</p>
<p>设置com.nowcoder.community.entity为实体类位置<br>当mapUnderscoreToCamelCase设置为 true 时，表示如果插入的表以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键返回</p>
<p>最后使下划线命名和驼峰命名相匹配</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MybatisProperties</span></span><br><span class="line"><span class="comment"># 映射文件的存放位置</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="comment"># 实体类的位置</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.nowcoder.community.entity</span></span><br><span class="line"><span class="meta">mybatis.configuration.useGeneratedKeys</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 是下划线命名和驼峰命名相匹配</span></span><br><span class="line"><span class="meta">mybatis.configuration.mapUnderscoreToCamelCase</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h1 id="帖子"><a href="#帖子" class="headerlink" title="帖子"></a>帖子</h1><p><b>我们按照数据库-&gt;entity-&gt;dao-&gt;mapper-&gt;service-&gt;controller-&gt;html的方法开发</b></p>
<p>首先需要设计数据库，在这里我们对一个帖子字段设计为id,userId(作者),title,content,type(0表示普通，1表示置顶),status(0表示正常，1表示精华，2表示拉黑，一般不删除数据),create_time,comment_count(表示评论总数，在之后会用到)，score<br><img src="https://img-blog.csdnimg.cn/20191130151814963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE2ODEx,size_16,color_FFFFFF,t_70" alt="数据库图片"></p>
<p>在项目中我们需要定义相关的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscussPost</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> commentCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">	<span class="comment">//get set...</span></span><br><span class="line">	<span class="comment">// toString()...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要在dao中申明相关接口，其中@Mapper注解表示该接口是一个Mapper，分别申明了查询帖子的方法（userId为0时表示获得所有帖子，在mapper中会解释），查询帖子数量的方法（@Param表示取别名），添加帖子方法，根据帖子id查询帖子，更新帖子。这些方法都是在之后是有需求才产生的，不应该是直接产生的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.entity.DiscussPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscussPostMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;DiscussPost&gt; <span class="title">selectDiscussPosts</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> offset, <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line">    <span class="comment">// 方法只有一个参数并且在&lt;if&gt;里使用就必须要取别名</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">selectDiscussPostRows</span><span class="params">(@Param(<span class="string">"userId"</span>)</span> <span class="keyword">int</span> userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertDiscussPost</span><span class="params">(DiscussPost discussPost)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">DiscussPost <span class="title">selectDiscussPostById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateCommentCount</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> commentCount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要在.xml文件中具体实现这些方法，在namespace中对应相应的dao中的接口。&lt;sql&gt;中的内容是对字段的封装，必须注明id，在后面中通过&lt;include refild=””&gt;的方式引用。&lt;select&gt;表示查询，通过id和接口中的具体方法对应,&lt;if&gt;表示只有条件满足才拼接该条件，limit表示查询到的结果数目，offset表示第一个与全部数据开始的偏移。</p>
<p>通过#{..}来引用方法中的参数，resultType表示返回类型，可以直接引用实体类，parameterType表示参数类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line">        <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">                <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">                <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.nowcoder.ceterommunity.dao.DiscussPostMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"selectFields"</span>&gt;</span></span><br><span class="line">        id, user_id, title, content, type, status, create_time, comment_count,score</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"insertFields"</span>&gt;</span></span><br><span class="line">        user_id, title, content, type, status, create_time, comment_count,score</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDiscussPosts"</span> <span class="attr">resultType</span>=<span class="string">"DiscussPost"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectFields"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from discuss_post</span><br><span class="line">    where status != 2</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userId!=0"</span>&gt;</span></span><br><span class="line">        and user_id = #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    order by type desc, create_time desc</span><br><span class="line">    limit #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDiscussPostRows"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    select count(id)</span><br><span class="line">    from discuss_post</span><br><span class="line">    where status != 2</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userId!=0"</span>&gt;</span></span><br><span class="line">        and user_id = #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertDiscussPost"</span> <span class="attr">parameterType</span>=<span class="string">"DiscussPost"</span>&gt;</span></span><br><span class="line">    insert into discuss_post(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"insertFields"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">    values(#&#123;userId&#125;,#&#123;title&#125;,#&#123;content&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;createTime&#125;,#&#123;commentCount&#125;,#&#123;score&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectDiscussPostById"</span> <span class="attr">resultType</span>=<span class="string">"DiscussPost"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectFields"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from discuss_post</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateCommentCount"</span>&gt;</span></span><br><span class="line">        update discuss_post set comment_count = #&#123;commentCount&#125; where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们要在service中实现具体的业务逻辑代码，首先我们需要用@Service注解来表示该类是service<br>这里很简单，就是通过@Autowired自动注入DiscussPostMapper，再调用即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.dao.DiscussPostMapper;</span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.entity.DiscussPost;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.HtmlUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscussPostService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//userId是外键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title">findDiscussPosts</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> offset,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId,offset,limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDiscussPostRows</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiscussPost <span class="title">findDiscussPostByid</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateCommentCount</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> commentCount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.updateCommentCount(id,commentCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是Controller，在这里我们查询所有帖子(设置userId=0)，然后遍历每一个帖子，将帖子实体和用户实体分别加入一个map中，然后将map加入到一个list中，最后将该list加入到model中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nowcoder.community.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.entity.DiscussPost;</span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.entity.Page;</span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.service.DiscussPostService;</span><br><span class="line"><span class="keyword">import</span> com.nowcoder.community.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.EAN;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">// /templates不用写</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/index"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndexPage</span><span class="params">(Model model, Page page)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 方法调用之前SpringMVC会自动实例化Model和Page，并将Page注入Model</span></span><br><span class="line">        <span class="comment">// 所以在thymeleaf中可以直接访问Page对象中的数据</span></span><br><span class="line">        page.setRows(discussPostService.findDiscussPostRows(<span class="number">0</span>));</span><br><span class="line">        page.setPath(<span class="string">"/index"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>,page.getOffset(),page.getLimit());</span><br><span class="line">        <span class="comment">// 将帖子和用户一起放入一个map里</span></span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; discussPosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (DiscussPost post:list)&#123;</span><br><span class="line">                Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">"post"</span>,post);</span><br><span class="line">                User user = userService.findUserById(post.getUserId());</span><br><span class="line">                map.put(<span class="string">"user"</span>,user);</span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">"discussPosts"</span>,discussPosts);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们在模板中设置好这些数据。使用th:each对discussPosts列表进行遍历，同时会在显示的时候重复n次，每一个元素命名为map，map.user其实是map.get(“user”)，通过th:utext来覆盖内容，utext和text的区别在于utext不会对标签进行转换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list-unstyled"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"media pb-3 pt-3 mb-3 border-bottom"</span> <span class="attr">th:each</span>=<span class="string">"map:$&#123;discussPosts&#125;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"site/profile.html"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--							map.user其实是map.get("user"),headerUrl同理--&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">"$&#123;map.user.headerUrl&#125;"</span> <span class="attr">class</span>=<span class="string">"mr-4 rounded-circle"</span> <span class="attr">alt</span>=<span class="string">"用户头像"</span> <span class="attr">style</span>=<span class="string">"width:50px;height:50px;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"media-body"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h6</span> <span class="attr">class</span>=<span class="string">"mt-0 mb-3"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;|/discuss/detail/$&#123;map.post.id&#125;|&#125;"</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;map.post.title&#125;"</span>&gt;</span>备战春招，面试刷题跟他复习，一个月全搞定！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-secondary bg-primary"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;map.post.type==1&#125;"</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-secondary bg-danger"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;map.post.status==1&#125;"</span>&gt;</span>精华<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-muted font-size-12"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--								#表示引用工具，$表示变量--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">u</span> <span class="attr">class</span>=<span class="string">"mr-3"</span> <span class="attr">th:utext</span>=<span class="string">"$&#123;map.user.username&#125;"</span>&gt;</span>寒江雪<span class="tag">&lt;/<span class="name">u</span>&gt;</span> 发布于 <span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(map.post.createTime,'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span>2019-04-15 15:32:18<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"d-inline float-right"</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"d-inline ml-2"</span>&gt;</span>赞 11<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"d-inline ml-2"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"d-inline ml-2"</span>&gt;</span>回帖 <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;map.post.commentCount&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>						</span><br><span class="line">	<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>牛客社区项目总结</category>
      </categories>
      <tags>
        <tag>首页</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/01/30/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="Java线程池初步理解"><a href="#Java线程池初步理解" class="headerlink" title="Java线程池初步理解"></a>Java线程池初步理解</h2><a id="more"></a>

<h3 id="利用Executors创建不同的线程池满足不同场景的需求"><a href="#利用Executors创建不同的线程池满足不同场景的需求" class="headerlink" title="利用Executors创建不同的线程池满足不同场景的需求"></a>利用Executors创建不同的线程池满足不同场景的需求</h3><ol>
<li><p>newFixedThreadPool(int nThread)，指定工作线程数量的线程池</p>
</li>
<li><p>newCachedThreadPool()，处理大量短时间工作任务的线程池</p>
<p>（1）试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作现场；</p>
<p>（2）如果线程闲置的时间超过阈值，则会被终止并移出缓存；</p>
<p>（3）系统长时间闲置的时候，不会消耗什么资源</p>
</li>
<li><p>newSingleThreadExecutor()，创建唯一的工作者线程来执行任务，如果线程异常结束，会有另一个线程取代它。</p>
</li>
<li><p>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)定时或者周期性的工作调度，两者的区别在于单一工作线程还是多个线程。</p>
</li>
<li><p>newWorkStealingPool()内部会构建ForkJoinPool，利用working-stealing算法，并行地处理任务，不保证处理顺序</p>
<p><strong>Fork/Join框架</strong>：把大任务分割成若干个小任务并行执行，最终汇总每个小任务结果后得到大任务结果的框架</p>
<p><strong>Work-Stealing算法</strong>：某个线程从其他队列里窃取任务来执行</p>
</li>
</ol>
<h3 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h3><p>降低资源消耗</p>
<p>提高线程的可管理性</p>
<h3 id="J-U-C的三个Executor接口"><a href="#J-U-C的三个Executor接口" class="headerlink" title="J.U.C的三个Executor接口"></a>J.U.C的三个Executor接口</h3><p>Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦</p>
<p>ExecutorService：具备管理执行器和任务生命周期的方法，提交任务机制更完善</p>
<p>ScheduledExecutorService：支持Future和定期执行任务</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="线程池示意图"></p>
<p><strong>构造函数</strong>：</p>
<ul>
<li>corePoolSize：核心线程数量</li>
<li>maximumPoolSize：线程不够用时能够创建的最大线程数</li>
<li>workQueue：任务等待队列</li>
<li>keepAliveTime：抢占的顺序不一样，看运气</li>
<li>threadFactory：创建新线程，Executors.defaultThreadFactory()</li>
<li>handler：线程池的饱和策略</li>
</ul>
<h3 id="新任务提交execute执行后的判断"><a href="#新任务提交execute执行后的判断" class="headerlink" title="新任务提交execute执行后的判断"></a>新任务提交execute执行后的判断</h3><ul>
<li>如果运行的线程少于corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程时空闲的；</li>
<li>如果线程池中的线程数量大于等于corePoolSize且小于maximumPoolSize，则只有当workQueue满时才创建新的线程取处理任务；</li>
<li>如果设置的corePoolSize和maximumPoolSize相同，则创建的线程池的大小是固定的，这是如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去workQueue中取任务并处理；</li>
<li>如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务。</li>
</ul>
<h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><ul>
<li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务</li>
<li>SHUTDOWN：不再接受新提交的任务，但可以处理存量任务</li>
<li>STOP：不再接受新提交的任务，也不处理存量任务</li>
<li>TIDYING：所有的任务都已终止</li>
<li>TERMINATED：terminated()方法执行完后进入该状态</li>
</ul>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p><img src="/images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="线程池状态转换图"></p>
<h3 id="线程池的大小如何选定"><a href="#线程池的大小如何选定" class="headerlink" title="线程池的大小如何选定"></a>线程池的大小如何选定</h3><p>CPU密集型：线程数 = 按照核数或者核数+1设定</p>
<p>I/O密集型：线程数 = CPU核数 * （1 + 平均等待时间/平均工作时间）</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS简单介绍</title>
    <url>/2020/01/30/CAS%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><a id="more"></a>

<h3 id="一种高效实现线程安全性的方法"><a href="#一种高效实现线程安全性的方法" class="headerlink" title="一种高效实现线程安全性的方法"></a>一种高效实现线程安全性的方法</h3><p>支持原子更新操作，适用于计数器，序列发生器等场景</p>
<p>属于乐观锁机制，号称lock-free</p>
<p>CAS操作失败时由开发者决定是否继续尝试，还是执行别的操作</p>
<h3 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h3><p>包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）</p>
<p>执行CAS操作时将内存位置的值与预期原值进行比较，如果相匹配就将内存位置的值更新为新值，否则不做任何操作。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>若循环时间长，则开销很大</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
</li>
<li><p>ABA问题：如果内存位置V的值初次读取为A，在准备赋值的时候仍然为A，但有可能存在在这期间A被改成了B，而B又被改成了A，CAS操作却并不知道；解决：引入版本控制，J.U.C的AtomicStampedReference</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>jmm的内存可见性</title>
    <url>/2020/01/30/jmm%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    <content><![CDATA[<h2 id="JMM的内存可见性"><a href="#JMM的内存可见性" class="headerlink" title="JMM的内存可见性"></a>JMM的内存可见性</h2><a id="more"></a>

<h3 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h3><p>Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
<h4 id="JMM中的主内存"><a href="#JMM中的主内存" class="headerlink" title="JMM中的主内存"></a>JMM中的主内存</h4><p>存储Java实例对象</p>
<p>包括成员变量、类信息、常量、静态变量等</p>
<p>属于数据共享的区域，多线程并发操作时会引发线程安全问题</p>
<h4 id="JMM中的工作内存"><a href="#JMM中的工作内存" class="headerlink" title="JMM中的工作内存"></a>JMM中的工作内存</h4><p>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</p>
<p>字节码行号指示器、Native方法信息</p>
<p>属于线程私有数据区域，不存在线程安全问题</p>
<h4 id="JMM与Java内存区域的划分时不同的概念层次"><a href="#JMM与Java内存区域的划分时不同的概念层次" class="headerlink" title="JMM与Java内存区域的划分时不同的概念层次"></a>JMM与Java内存区域的划分时不同的概念层次</h4><p>JMM描述的是一组规则，围绕原子性、有序性、可见性展开</p>
<p>相似点：存在共享区域和私有区域，从某些方面来看，主内存对应的是堆和方法区，而工作内存对应的是虚拟机栈、PC 寄存器和本地方法栈</p>
<h4 id="主内存与工作内存的数据存储类型以及操作方式归纳"><a href="#主内存与工作内存的数据存储类型以及操作方式归纳" class="headerlink" title="主内存与工作内存的数据存储类型以及操作方式归纳"></a>主内存与工作内存的数据存储类型以及操作方式归纳</h4><p>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</p>
<p>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</p>
<p>成员变量、static变量、类信息均会被存储在主内存中</p>
<p>主内存共享的方式是线程个拷贝一份数据到工作内存，操作完成后刷新回主内存</p>
<h3 id="JMM如何解决可见性问题"><a href="#JMM如何解决可见性问题" class="headerlink" title="JMM如何解决可见性问题"></a>JMM如何解决可见性问题</h3><h4 id="指令重排序需要满足的条件"><a href="#指令重排序需要满足的条件" class="headerlink" title="指令重排序需要满足的条件"></a>指令重排序需要满足的条件</h4><p>在单线程环境下不能改变程序运行的结果</p>
<p>存在数据依赖关系的不允许重排序</p>
<p><strong>无法通过happens-before原则推导出来的，才能进行指令的重排序</strong></p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>A操作的结果需要对B操作可见，则A与B存在happens-before关系</p>
<p><strong>happens-before的八大原则</strong>：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ol>
<p>如果两个操作不需要满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序；</p>
<p>如果操作A happens-before 操作B，那么操作A在内存上所作的操作对操作B都是可见的。</p>
<h3 id="volatile：JVM提供的轻量级同步机制"><a href="#volatile：JVM提供的轻量级同步机制" class="headerlink" title="volatile：JVM提供的轻量级同步机制"></a>volatile：JVM提供的轻量级同步机制</h3><p>保证被volatile修饰的共享变量对所有线程总是可见的</p>
<p>禁止指令的重排序优化</p>
<h4 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h4><p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中；当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效。</p>
<p><strong>volatile如何禁止重排优化</strong>：</p>
<p>内存屏障（Memory Barrier）：1.保证特定操作的执行顺序；2.保证某些变量的内存可见性</p>
<p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化</p>
<p>强制刷出各种CPU的缓冲数据，因此任何CPU上的线程都能够读取到这些数据的最新版本。</p>
<h4 id="单例的双重检测实现"><a href="#单例的双重检测实现" class="headerlink" title="单例的双重检测实现"></a>单例的双重检测实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 禁止指令重排优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检测</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 多线程环境下可能会出现问题的地方，即new指令会发生重排序，会将配分内存地址重排到初始化之前，所以要用volatile修饰</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h4><ol>
<li>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主内存中读取；synchronized则是锁定当前变量，只有正确线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。</li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量操作的可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>jmm</tag>
        <tag>可见性</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-虚拟机类加载机制</title>
    <url>/2020/01/29/jvm-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>深入理解Java虚拟机第七章记录</strong></p>
<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>
<p>对于初始化阶段，《Java虚拟机规范》严格规定了有且只有六种情况必须立即对类进行“初始化”：</p>
<p>（1）需要new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<ul>
<li>使用new关键字实例化对象</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）</li>
<li>调用一个类型的静态方法</li>
</ul>
<p>（2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>（3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>（4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>（5）当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStaic、REF_putStaic、REF_invokeStaic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>（6）当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口就要在其之前被初始化。</p>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>通过这个字节流所代表的静态存储结构转化为方法区运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的，但数组类的元素类型最终还是要靠类加载器来完成加载的。</p>
<p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的类型数据的外部接口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证阶段大致上会完成四个阶段的检测动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能够被当前版本的虚拟机处理。该验证阶段的主要目的是保证输入的字节流能够正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息地要求。这个阶段地验证是基于二进制字节流进行的，只有通过了这个阶段之后，这段字节流才被运行进入Java虚拟机内存的方法区中进行存储。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三个阶段的主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验。其主要目的是确保解析行为能正常执行。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。一般情况下类变量的初始值为0或者null，但如果被final修饰，就会在准备阶段赋值为其被设置的值。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ol>
<li>符号引用：符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()是Javac编译器的自动生成物。</p>
<ul>
<li><p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;	<span class="comment">// 赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i); 	<span class="comment">// 编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;clinit&gt;()方法与类的构造函数不同，它不需要显示地调用父类构造器，Java虚拟机会保证在子类的&lt;clinit&gt;()方法被执行前，父类的&lt;clinit&gt;()方法已经执行完毕。</p>
</li>
<li><p>&lt;clinit&gt;()方法对于类或者接口来说并不是必需的</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样有&lt;clinit&gt;()方法，但是执行接口的&lt;clinit&gt;()方法不用先执行父接口的&lt;clinit&gt;()方法，且接口实现类的初始化也不会执行接口的&lt;clinit&gt;()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去，执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞。</p>
</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器是虚拟机自身的一部分，C++编写；另一部分就是其他所有的类加载器，独立存在于虚拟机外部，并且全部继承自java.lang.ClassLoader.</p>
<p>站在Java开发人员的角度来看，可以分为启动类加载器（Bootstrap）、扩展类加载器（Extension）和应用程序类加载器（Application）。</p>
<p><img src="/images/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="双亲委派机制"></p>
<p>上图展示的就是类加载器的“双亲委派模型”（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。但父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载器请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p>
<h2 id="Java模块化"><a href="#Java模块化" class="headerlink" title="Java模块化"></a>Java模块化</h2><h3 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h3><p>模块化下的类加载器发生了一些变化。</p>
<p>首先是扩展类加载器被平台类加载器（Platform Class Loader）取代。</p>
<p>其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，现在启动类加载器、平台类加载器和应用程序加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</p>
<p><img src="/images/%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8B%E7%9A%84%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="模块化下的委派机制"></p>
<p>当平台及应用程序加载器收到类加载请求，在委派给父加载器之前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-换钱的最少货币数</title>
    <url>/2020/01/29/%E7%AE%97%E6%B3%95-%E6%8D%A2%E9%92%B1%E7%9A%84%E6%9C%80%E5%B0%91%E8%B4%A7%E5%B8%81%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求组成aim的最少货币数。</p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>arr = [5,2,3], aim = 20</p>
<p>4张5元可以组成20元，其他的找钱方案都要使用更多张的货币，所以返回4.</p>
<p>arr = [5, 2, 3], aim = 0</p>
<p>不用使用任何货币就可以组成0元，返回0.</p>
<p>arr = [3, 5], aim = 2</p>
<p>根本无法组成2元，钱不能找开的情况下默认返回-1.</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>典型的完全背包问题，我们可以通过比较dp[j]和dp[j-arr[i]]来进行比较，其动态方程为<br>$$<br>dp[j] = min{dp[j],dp[j-arr[i]+1}<br>$$<br>当然要对-1进行特别处理，如果是-1就忽略直接取不为-1的值，如果都是-1则也置为-1</p>
<p>接下来给出一个[5,2], aim = 12的例子</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>0</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>2</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>-1</td>
<td>1</td>
<td>-1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>-1</td>
<td>3</td>
</tr>
</tbody></table>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] rc = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(rc[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> aim = Integer.parseInt(rc[<span class="number">1</span>]);</span><br><span class="line">        String[] data = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            arr[i] = Integer.parseInt(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[aim+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++)&#123;</span><br><span class="line">            dp[j] = (j % arr[<span class="number">0</span>] == <span class="number">0</span>) ? j/arr[<span class="number">0</span>] : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dp[aim];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= aim; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= arr[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j] == -<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[j] = dp[j-arr[i]] != -<span class="number">1</span> ? dp[j-arr[i]] + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[j-arr[i]] != -<span class="number">1</span>)&#123;</span><br><span class="line">                            dp[j] = Math.min(dp[j],dp[j-arr[i]] + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[aim] != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res == -<span class="number">1</span>)&#123;</span><br><span class="line">                    res = dp[aim];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = Math.min(res,dp[aim]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-矩阵的最小路径和</title>
    <url>/2020/01/29/%E7%AE%97%E6%B3%95-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。</p>
<a id="more"></a>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>1    3    5    9</p>
<p>8    1    3    4</p>
<p>5    0    6    1</p>
<p>8    8    4    0</p>
<p>路径1，3，1，0，6，1，0是所有路径中路径和最小的，所以返回12.</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>经典动态啊规划方法。</p>
<p>动态方程为dp[i][j] = min{dp[i-1][j],dp[i][j-1]} + m[i][j]，其中dp[i][j]表示走到位置(i, j)的最小路径和。</p>
<p>因此我们只需要首先初始化第一行（只能往右）和第一列（只能往下），然后用动态方程填表即可，最后dp[m][n]的值就是答案。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = m.length;</span><br><span class="line">    <span class="keyword">int</span> col = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)&#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]) + m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>原方法的时间复杂度为O(M*N)，空间复杂度为O(M*N)，我们可以通过空间压缩的方式将额外空间复杂度将为O(min{M,N})，也就是用一维的dp数组通过不断滚动来代替二维的dp数组。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="keyword">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="keyword">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> more = Math.max(m.length,m[<span class="number">0</span>].length);</span><br><span class="line">    <span class="keyword">int</span> less = Math.min(m.length,m[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">// 行数是否大于列数</span></span><br><span class="line">    <span class="keyword">boolean</span> rowmore = more == m.length;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[less];</span><br><span class="line">    arr[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; less; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果行数大于列数，那就按列进行滚动</span></span><br><span class="line">        arr[i] = arr[i-<span class="number">1</span>] + (rowmore ? m[<span class="number">0</span>][i] : m[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; more; i++)&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">0</span>] + (rowmore ? m[i][<span class="number">0</span>] : m[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; less; j++)&#123;</span><br><span class="line">            <span class="comment">// Math.min中的arr[j]也就是旧值</span></span><br><span class="line">            arr[j] = Math.min(arr[j-<span class="number">1</span>], arr[j]) + (rowmore ? m[i][j] : m[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[less-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-synchronized的底层原理</title>
    <url>/2020/01/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Synchronized底层实现原理"><a href="#Synchronized底层实现原理" class="headerlink" title="Synchronized底层实现原理"></a>Synchronized底层实现原理</h2><a id="more"></a>

<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><table>
<thead>
<tr>
<th>虚拟机位数</th>
<th>对象头结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64 bit</td>
<td>Mark Word</td>
<td>默认存储对象的hashCode，分代年龄，锁类型，锁标志位等信息</td>
</tr>
<tr>
<td>32/64 bit</td>
<td>Class Metadata Address</td>
<td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据</td>
</tr>
</tbody></table>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>每个Java对象天生自带了一把看不见的锁。</p>
<p>查看源码，_owner是持有objectMonitor对象的线程。当多个线程同时访问同步代码时会首先进入_EntryList,当线程获取到对象的monitor之后就会进入到_object区域，并把当前_onwer设置成当前线程，然后_count+1；如果当前线程执行wait()方法，_owner就会置为空，_count-1，线程进入_WaitSet区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize the monitor, exception the semaphore, all other fields</span></span><br><span class="line">  <span class="comment">// are simple integers or pointers</span></span><br><span class="line">  ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>重入</strong>：从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入。</p>
<p><strong>同步代码块字节码</strong></p>
<p>synchronized(this)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">monitorenter</span><br><span class="line">    </span><br><span class="line">    .... <span class="comment">// 方法具体实现</span></span><br><span class="line">    </span><br><span class="line">monitorexit</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">monitorexit <span class="comment">// 用于方法块发生异常时也能释放锁</span></span><br></pre></td></tr></table></figure>

<p><strong>同步方法字节码</strong></p>
<p>synchronized method()</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">flags:</span> ... , ACC_SYNCHRONIZED	<span class="comment">// 执行线程会持有monitor</span></span><br></pre></td></tr></table></figure>

<h3 id="自旋锁与自适应自旋锁"><a href="#自旋锁与自适应自旋锁" class="headerlink" title="自旋锁与自适应自旋锁"></a>自旋锁与自适应自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得</p>
<p>通过让线程执行忙循环等待锁的释放，不让出CPU</p>
<p>缺点：若锁被其他线程长时间占有，会带来许多性能上的开销</p>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋的次数不再固定</p>
<p>由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁</p>
<p>如下面的例子，由于sb是局部变量且没有发布出去，所以是不会存在多线程共享问题的，但是StringBuffer的append方法是synchronized的，此时JIT编译器就会将锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果存在一系列操作都对同一个对象反复加锁解锁，甚至出现在循环体中，此时JIT编译器通过扩大加锁的范围，避免反复加锁和解锁。</p>
<p>如下，在while循环中都是对sb对象加锁，此时JIT编译器就会进行优化，改为对整个代码块进行加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyString</span><span class="params">(String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">100</span>)&#123;</span><br><span class="line">        sb.append(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized的四种状态"><a href="#synchronized的四种状态" class="headerlink" title="synchronized的四种状态"></a>synchronized的四种状态</h3><p>分为无锁、偏向锁、轻量级锁、重量级锁</p>
<p>锁膨胀的方向：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<h4 id="偏向锁：减少同一线程获取锁的代价"><a href="#偏向锁：减少同一线程获取锁的代价" class="headerlink" title="偏向锁：减少同一线程获取锁的代价"></a>偏向锁：减少同一线程获取锁的代价</h4><p>大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得</p>
<p><strong>核心思想</strong>：如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变成偏向锁结构，当该线程再次请求该锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程Id等于Mark Word的ThreadID即可，这样就省去了大量有关锁申请的操作。</p>
<p>不适用于锁竞争比较激烈的多线程场合。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。</p>
<p>适应场景：线程交替执行同步块</p>
<p>若存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p>
<p><strong>轻量级锁的加锁过程</strong>：</p>
<p>（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝。</p>
<p>（2）拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向object mark word。</p>
<p>（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图所示。</p>
<p><img src="/images/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%8E%B7%E5%BE%97%E9%94%81.png" alt="轻量级锁获得锁"></p>
<p>（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行了。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为”10“，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁。</p>
<p><strong>轻量级锁的解锁过程</strong>：</p>
<p>（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</p>
<p>（2）如果替换成功，整个同步过程就完成了。（参考下面的锁的内存语义）</p>
<p>（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p><strong>锁的内存语义</strong>：当线程释放锁时，Java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存中；而当线程获取锁时，Java内存模型会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>
<p><img src="/images/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.png" alt="线程之间通信的底层原理"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>只有一个线程访问同步块或者同步方法的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了响应速度</td>
<td>若线程长时间抢不到锁，自旋会消耗CPU性能</td>
<td>线程交替执行同步块或者同步方法的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢，在多线程下，频繁地获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块或者同步方法执行时间较长的场景</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二叉树的序列化与反序列化</title>
    <url>/2020/01/28/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>二叉树被记录成文件的过程叫做二叉树的序列化，通过文件内容重建原来二叉树的过程叫做二叉树的反序列化。给定一颗二叉树的头节点head，已知二叉树节点值的类型为32位整型。请设计一种二叉树序列化与反序列化的方案，并用代码实现。</p>
<a id="more"></a>

<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span></span>&#123;</span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(value.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res += head.left.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res += head.right.value + <span class="string">"!"</span>;</span><br><span class="line">            queue.offer(head.right;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += <span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span></span>&#123;</span><br><span class="line">    String[] values = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Node head = generateNodeByString(values[index++]);</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.offer(head);</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        node.left = generateNodeByString(values[index++]);</span><br><span class="line">        node.right = generateNodeByString(values[index++]);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">generateNodeByString</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val.equals(<span class="string">"#!"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(Integer.valueOf(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二叉树的最小深度</title>
    <url>/2020/01/28/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一颗二叉树的头节点head，求这棵二叉树的最小深度。</p>
<a id="more"></a>

<h2 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h2><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>遍历整棵树，得到每个叶节点的深度，然后给出深度最小的叶节点深度即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(head, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(Node cur,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 叶节点</span></span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = Math.min(process(cur.left, level + <span class="number">1</span>), ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ans = Math.min(process(cur.right, level + <span class="number">1</span>), ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>请将解法优化到时间复杂度O(N)，额外空间复杂度O(1).</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>这里我们需要用到morris遍历。</p>
<ol>
<li>如果cur为null，则过程停止，否则继续下面的过程。</li>
<li>如果cur没有左子树，则让cur向右移动，即令cur=cur.right，此时level+1</li>
<li>如果cur有左子树，则找到cur左子树上最有的节点，记为mostRight。<ol>
<li>如果mostRight的right指针指向null，则令mostRight.right = cur,也就是让mostRight的right指针指向当前节点，然后让cur向左移动，即令cur = cur.left。此时level+1.</li>
<li>如果mostRight的right指针指向cur，则令mostRight.right = null,也就是让mostRight的right指针指向null，然后让cur向右移动，即令cur = cur.right。此时level减去cur左子树的右边界节点数</li>
</ol>
</li>
</ol>
<p>这样我们就解决了节点的深度问题，但是我们还需要解决如何在遍历中发现每一个叶子节点。我们把发现叶子节点的时机放在可以到达两次的节点第二次到达自己的时候，比如第二次回到根节点，我们就查看它的前一个节点是否是叶子节点。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据morris遍历改写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minHeight = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// cur左子树右边界的节点数</span></span><br><span class="line">            <span class="keyword">int</span> leftTreeRightSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                leftTreeRightSize++;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 第一次到达</span></span><br><span class="line">                curLevel++;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第二次到达</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 如果前一个节点是叶子节点就记录答案</span></span><br><span class="line">                    minHeight = Math.min(minHeight,curLevel);</span><br><span class="line">                &#125;</span><br><span class="line">                curLevel -= leftTreeRightSize;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有左子树</span></span><br><span class="line">            curLevel++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对整棵树的最右节点进行处理</span></span><br><span class="line">    <span class="keyword">int</span> finalRight = <span class="number">1</span>;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        finalRight++;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        minHeight = Math.min(minHeight,finalRight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-遍历二叉树的神级办法</title>
    <url>/2020/01/27/%E7%AE%97%E6%B3%95-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A5%9E%E7%BA%A7%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一颗二叉树的头节点，完成二叉树的先序、中序和后序遍历。如果二叉树的节点树为N，则要求时间复杂度为O(N)，额外空间复杂度为O(1)。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>Morris遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过让底层节点指向null的空闲指针指回上层的某个节点，从而完成下层到上层的移动。</p>
<p>先不管先序、中序、后序的概念，先看看Morris遍历的过程。</p>
<p>假设当前节点为cur，初始时cur就是整棵树的头节点，根据以下标准让cur移动：</p>
<ol>
<li>如果cur为null，则过程停止，否则继续下面的过程。</li>
<li>如果cur没有左子树，则让cur向右移动，即令cur=cur.right</li>
<li>如果cur有左子树，则找到cur左子树上最有的节点，记为mostRight。<ol>
<li>如果mostRight的right指针指向null，则令mostRight.right = cur,也就是让mostRight的right指针指向当前节点，然后让cur向左移动，即令cur = cur.left。</li>
<li>如果mostRight的right指针指向cur，则令mostRight.right = null,也就是让mostRight的right指针指向null，然后让cur向右移动，即令cur = cur.right。</li>
</ol>
</li>
</ol>
<p>可以看出，在一颗二叉树中，对于有左子树的节点都可以到达两次，对于没有左子树的节点都只会到达一次。对于任何一个只能到达一次的节点X，接下来cur要么跑到X的右子树上，要么就返回上级。而对于任何一个能够到达两次的节点Y，在第一次到达Y只会，cur都会先去Y的左子树转一圈，然后会第二次来到Y，接下来cur要么跑到Y的右子树上，要么就返回上级。</p>
<p>如果Y的左子树上的最右节点的指针（mostRight.right）是指向null的，说明是第一次到达Y，如果mostRight.right是指向Y的，说明是第二次到达Y。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirris</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 找到左子树上最右的节点</span></span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 第一次到达Y节点</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第二次到达Y节点</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>根据morris遍历，加工出先序遍历。</p>
<ol>
<li>对于cur只能到达一次的节点（无左子树的节点），cur到达时直接打印。</li>
<li>对于cur可以到达两次的节点（有左子树的节点），cur第一次到达时打印，第二次到达时不打印。</li>
</ol>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>根据morris遍历，加工出中序遍历。</p>
<ol>
<li>对于cur只能到达一次的节点（无左子树的节点），cur到达时直接打印。</li>
<li>对于cur可以到达两次的节点（有左子树的节点），cur第一次到达时不打印，第二次到达时打印。</li>
</ol>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>根据morris遍历，加工出后序遍历。</p>
<ol>
<li>对于cur只能到达一次的节点（无左子树的节点），直接跳过，没有打印行为。</li>
<li>对于cur可以到达两次的任何一个节点（有左子树的节点）X，cur第一次到达X时没有打印行为；当第二次到达X时，逆序打印X的左子树的右边界。</li>
<li>cur遍历完成后，逆序打印整棵树的右边界。</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这里只给出较为复杂的后序遍历的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span>(mostRight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur)&#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mostRight.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printEdge(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    printEdge(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node tail = reverseEdge(head);</span><br><span class="line">    Node cur = tail;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseEdge</span><span class="params">(Node from)</span></span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(from != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>Morris遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-用非递归的方式实现二叉树的先序、中序和后序遍历</title>
    <url>/2020/01/27/%E7%AE%97%E6%B3%95-%E7%94%A8%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用非递归的方式分别按照二叉树先序、中序和后序打印所有节点。</p>
<a id="more"></a>

<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><ol>
<li>申请一个新的栈，记为stack，然后将头节点head压入stack中。</li>
<li>从stack中弹出栈顶节点，记为cur，然后打印cur节点的值，再将节点cur的右孩子节点先压入stack中，最后将cur的左孩子节点压入stack中。</li>
<li>不断重复步骤2，直到stack为空，全部过程结束。</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span>(!head.empty())&#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><ol>
<li>申请一个新栈，记为stack。初始时，令变量cur=head。</li>
<li>先把cur节点压入栈中，对以cur节点为头节点的整棵子树来说，依次把左边界压入栈中，即不停地令cur=cur.left，然后重复步骤2.</li>
<li>不断重复步骤2，直到发现cur为空，此时从stack中弹出一个节点，记为node，node为树的最左节点。打印node的值，并且让cur=node.right，然后继续重复步骤2.</li>
<li>当stack为空且cur为空时，整个过程停止。</li>
</ol>
<p>PS:相比于先序遍历，还需要加上cur != null的条件，因为对于像[1, 2, 3]这样的满二叉树，最后一个右节点时栈为空。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h4><ol>
<li>申请一个栈，记为s1，然后将头节点head压入s1中。</li>
<li>从s1中弹出的节点记为cur，然后依次将cur的左孩子和右孩子压入s1中。</li>
<li>在整个过程中，每一个从s1中弹出的节点都放进s2中。</li>
<li>不断重复步骤2和步骤3，直到s1为空，过程停止。</li>
<li>从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序。</li>
</ol>
<p>PS：后序遍历的顺序是左右中，而先序遍历的顺序是中左右，我们把先序遍历的左右孩子入栈顺序改变以下，即可实现中右左，然后倒过来就是左右中，即后序遍历。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pos-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">            Node cur = s1.pop();</span><br><span class="line">            s2.push(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s1.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s2.empty())&#123;</span><br><span class="line">            System.out.print(s2.pop().val + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>非递归</tag>
      </tags>
  </entry>
  <entry>
    <title>GC-弱引用初认识</title>
    <url>/2020/01/27/GC-%E5%BC%B1%E5%BC%95%E7%94%A8%E5%88%9D%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h3 id="GC-弱引用的初次使用"><a href="#GC-弱引用的初次使用" class="headerlink" title="GC-弱引用的初次使用"></a>GC-弱引用的初次使用</h3><p>在GC中引用有强引用、软引用、弱引用和虚引用。</p>
<a id="more"></a>

<p>下面的实例中，我们会使用弱引用来对弱引用和弱引用队列进行一些实验。</p>
<p>首先我们创建一个普通的Java类。我们需要重写该类的finalize()方法用于提示是否回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalObject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing obj "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要编写一个对该类实例的弱引用的类，我们需要用到ReferenceQueue，该队列会在实例对象被回收之后将其弱引用对象加入到该队列中。其内部实现可以查看其源码。我们只要调用WeakReference类的带ReferenceQueue参数的构造方法即可。同时我们也改写finalize()方法，对其回收做一个提示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.jvm.gc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalObjectWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">NormalObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalObjectWeakReference</span><span class="params">(NormalObject referent, ReferenceQueue&lt;? <span class="keyword">super</span> NormalObject&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在对象被回收之后才会被加入到ReferenceQueue中</span></span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">        <span class="keyword">this</span>.name = referent.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Finalizing NormalObjectWeakReference "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们来编写一个测试类。</p>
<p>我们在类中申请一个ReferenceQueue实例用作成员变量，然后编写一个ckeckQueue()方法来查看弱引用队列里的值和对应的弱引用的实际引用对象。在main()方法中，我们加入往一个列表中加入三个弱引用，然后手动触发垃圾回收，<strong>弱引用所引用的对象会在这次垃圾回收中被回收，而这些弱引用则会被加入到引用队列rq中去</strong>。我们通过垃圾回收前后调用checkQueue()来验证。注意我们常说的对象可以在finalize()方法中拯救自己不被回收，是需要有别的对象来“拯救”的，也就是有别的对象来引用这些要被回收的对象才能不被回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;NormalObject&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Reference&lt;NormalObject&gt; ref = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((ref = (Reference&lt;NormalObject&gt;)rq.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 引用对象</span></span><br><span class="line">                System.out.println(<span class="string">"In queue: "</span> + ((NormalObjectWeakReference)ref).name);</span><br><span class="line">                <span class="comment">// 真正的对象实例</span></span><br><span class="line">                System.out.println(<span class="string">"reference object: "</span> + ref.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;WeakReference&lt;NormalObject&gt;&gt; weakList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// 使用WeakReferenceQueue来完成对实例对象的弱引用</span></span><br><span class="line">            weakList.add(<span class="keyword">new</span> NormalObjectWeakReference(<span class="keyword">new</span> NormalObject(<span class="string">"weak"</span> + i),rq));</span><br><span class="line">            System.out.println(<span class="string">"Created weak:"</span> + weakList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"first time"</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">        System.out.println(<span class="string">"first time"</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"second time"</span>);</span><br><span class="line">        checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<pre><code>Created weak:com.interview.javabasic.jvm.gc.NormalObjectWeakReference@1b6d3586
Created weak:com.interview.javabasic.jvm.gc.NormalObjectWeakReference@4554617c
Created weak:com.interview.javabasic.jvm.gc.NormalObjectWeakReference@74a14482
first time
Finalizing obj weak2
Finalizing obj weak1
Finalizing obj weak0
second time
In queue: weak0
reference object: null
In queue: weak2
reference object: null
In queue: weak1
reference object: null

Process finished with exit code 0</code></pre>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>弱引用</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-删除链表的a/b处的节点</title>
    <url>/2020/01/25/%E7%AE%97%E6%B3%95-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84a-b%E5%A4%84%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定链表的头节点head、整数a和b，实现删除位于a/b处节点的函数。</p>
<a id="more"></a>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>对于一般的题目通常是删除链表的中间节点，只需要一对快慢指针即可实现。而对于删除a/b处节点的函数我们不能使用快慢指针了，而是要找到a/b处节点的前一个节点然后跳过a/b处的节点即可。</p>
<p>因此我们需要两趟遍历（快慢指针只需一趟），第一趟得到链表长度n，第二次指向a/b处前一个位置。</p>
<p>注意我们要向上取整，因此a/b处的节点为ceil(a*n/b)。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeByRatio</span><span class="params">(Node head, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">1</span> || a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n = (<span class="keyword">int</span>) Math.ceil((<span class="keyword">double</span>) (a * n)/(<span class="keyword">double</span>) b);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(--n != <span class="number">1</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略（2）</title>
    <url>/2020/01/25/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p><strong>深入理解Java虚拟机第三章内容记录之二</strong></p>
<a id="more"></a>

<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。其中Serial收集器采用复制算法暂停所有用户进程，Serial Old采取标记-整理算法暂停所有用户线程。</p>
<p>迄今为止，Serial收集器仍然是HotSpot虚拟机运行在客户端模式下默认的新生代收集器，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单处理器或者处理器核心较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的多线程并行版本。</p>
<p>由于CMS最为老年代垃圾收集器，而Parallel Scavenge无法与CMS配合工作，因此新生代只能选择Serial或者ParNew。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge也是一款新生代收集器，同样是基于标记-复制算法实现的收集器，同样能够并行。但是该收集器注重的是吞吐量（Throughput）。<br>$$<br>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)<br>$$<br>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>该收集器是Serial收集器的老年代版本，同样是单线程，使用标记-整理算法。主要意义是供客户端模式下的HotSpot虚拟机使用。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS（Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，是基于标记-清除算法实现的，它的运行过程可分为四个步骤，包括初始标记，并发标记，重新标记和并发清除。其中初始标记和重新标记仍然需要“Stop The World”。</p>
<p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>
<p>CMS有以下三个明显的缺点：</p>
<p>首先CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）/4.</p>
<p>然后，由于CMS收集器无法处理“浮动垃圾”，有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。要是CMS运行期间预留的内存无法满足程序分配新对象的需要就会发生一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备方案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就太长了。</p>
<p>最后就是空间碎片的问题，如果老年代无法找到足够大的连续空间来分配当前对象，就又会触发Full GC。</p>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><p>G1是一款主要面向服务端应用的垃圾收集器，它可以面向堆内存任何部分来组成回收集（Collection Set）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。</p>
<p>G1收集器的新生代和老年代不再是固定的，它们都是一系列区域的动态集合。G1收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region。</p>
<p>G1收集器的运作过程大致可以划分为以下四个步骤：</p>
<ol>
<li>初始标记（Initial Marking）:仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值（Top at Mark Start，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址必须要在这两个指针位置之上），让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。</li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的STAB记录。 </li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，在清理掉整个旧Region的全部空间。这里的操作设计到存活对象的移动，是必须暂停用户线程的，由多条收集器线程并行完成的。</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>java</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略（1）</title>
    <url>/2020/01/25/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p><strong>深入理解Java虚拟机第三章内容记录之一</strong></p>
<a id="more"></a>

<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>在对象中添加一个引用计数器，每有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须配合大量额外处理才能保证正确地工作。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在Java技术体系里，固定可以作为GC Roots的对象包括：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>在Java虚拟机内部的引用，如基本数据类型对于的Class对象，一些常驻的异常对象等，还有系统类加载器。</li>
<li>所有被同步锁（Synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓冲等。</li>
</ul>
<p>除了这些固定的GC Roots集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入。</p>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>引用分为强引用、软引用、弱引用和虚引用。</p>
<ul>
<li>强引用（Strongly Reference）是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用（Soft Reference）是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会将这些对象列进回收范围之中的第二次回收。JDK1.2之后提供SoftReference类来实现软引用。</li>
<li>弱引用（Weak Reference）的强度比软引用更弱一些，这些对象只能生存到下一次垃圾收集发生为止。JDK1.2之后提供WeakReference类来实现弱引用。</li>
<li>虚引用（Phantom Reference）是最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。其存在只是为了在对象被收集器回收时收到一个系统通知。JDK1.2之后提供PhantomReference类来实现虚引用。</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>一个对象死亡至少要经历两次标记过程：如果对象在进行可达性分析之后发现没有GC Roots相连接的引用链，那么它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假设对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况视为”没有必要执行“。finalize()方法执行会让对象不被回收。</p>
<p>注意finalize()方法已被声明为不推荐使用的语法。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<p>判断一个类型是否属于”不再被使用的类“需要满足三个条件：</p>
<ul>
<li>该类的所有实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。这个条件很难达成。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为”引用计数式垃圾收集“和”追踪式垃圾收集“两大类，之后的算法均属于追踪式垃圾收集。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就难以消亡。</li>
</ol>
<p>垃圾收集器的一致设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中。</p>
<p>设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>为了解决跨代引用问题，我们还需要添加第三条经验法则：</p>
<ol start="3">
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>此时，我们需要在新生代上建立一个全局的数据结构，该结构称为记忆集，这个结构把老年代划分为若干小块，标识出老一代的哪一块内存会存在跨代引用。</p>
<blockquote>
<p>垃圾收集可以分为：</p>
<ol>
<li>部分收集（Partial GC）<ul>
<li>新生代收集（Minor GC/Young GC）</li>
<li>老年代收集（Major GC/Old GC）</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ol>
</blockquote>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<p>它主要有两个缺点，一是执行效率不稳定，二是内存的碎片化问题。</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>该算法是为了解决执行效率问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。</p>
<p>缺陷是将可用内存变成了一半，空间浪费太多。</p>
<p>可以将新生代分为一块较大的Eden和两块较小的Survivor。当完成一次垃圾收集之后就将Eden存活的对象移到一块未使用的Survivor上，然后将Eden和之前使用过的Survivor清理掉。</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>针对老年代对象的死亡特征，标记-整理算法的标记过程与标记-清除一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都往内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>移动存活对象并更新所有引用这些对象的地方对于老年代而言是一种极为负重的操作，而且这种移动对象必须全程暂停用户应用程序才能进行。</p>
<h2 id="HotSpot的算法细节实现"><a href="#HotSpot的算法细节实现" class="headerlink" title="HotSpot的算法细节实现"></a>HotSpot的算法细节实现</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>根节点枚举始终必须在一个能保障一致性的快照中才得以进行——这里的“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况。</p>
<p>当用户线程停顿下来之后，Java虚拟机并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot并没有因为会让OopMap内容发生变化的指令非常多，就为每一条指令都生成对应的OopMap，而是只在“特定的位置”记录了这些信息，这些位置也被称为安全点（Safepoint）。</p>
<p>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。安全点的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，例如方法调用、循环跳转、异常跳转等。</p>
<p>对于如何在垃圾收集时让所有的线程都跑到最近的安全点，然后停顿下来，一般有抢先式中断和主动式中断。抢先式中断是指系统首先把全部用户线程中断，对于没有到达安全点的线程，让其恢复跑到安全点，现在几乎没有用抢先式中断来暂停线程响应GC事件了；主动式中断是通过设置一个标志位，各个线程执行过程中会不断地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。<strong>轮询标志的地方</strong>和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够的内存分配新对象。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点，但是对于处于Sleep状态或者Blocked状态这样程序无法走到安全点的情况，我们就需要引入安全区域（Safe Region）来解决。</p>
<p>安全区域是指能够确保在某一段代码之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举，如果完成了，那么线程就继续执行，否则就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。如老年代指向新生代。</p>
<p>由于收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针即可，因此并不需要了解这些跨代指针的全部细节。有以下一些可供选择的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长，该字包括跨代指针</li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>其中第三种精度就是用一种称为“卡表”（Card Table）的方式去实现记忆集。</p>
<p>卡表的最简单形式可以是一个字节数组，数组中的每一个元素都对应着其标识的内存区域中的一块特定大小的内存块，称之为“卡页”（Card Page）。</p>
<p><img src="/images/%E5%9B%BE3-5.png" alt="图3-5"></p>
<p>​                                                       图 3-5 卡表与卡页对应示意图</p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称这个元素变脏（Dirty），没有就标识为0.</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在HotSpot虚拟机里是通过写屏障技术维护卡表状态的。这里的写屏障和解决并发乱序执行问题的内存屏障是不一样的。</p>
<p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作。</p>
<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，每次只要对引用进行更新都会产生额外的开销。</p>
<p>同时卡表在高并发场景下还面临着“伪共享”问题。为了避免伪共享问题，可以先检查卡表标记，只有当该卡表元素为未被标记过时才将其标记变为脏。</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><p>在并发的可达性分析中，如果把原本存活的对象错误标记为已消亡，就会发生对象消失问题。为了解决对象消失问题，我们可以采用增量更新（Incremental Update）和原始快照（Snapshot At The Beginning）。</p>
<p>增量更新是在当黑色对象（已被扫描过的且安全存活的对象）插入新的指向白色对象（尚未被垃圾收集器访问过的对象）的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
<p>原始快照是当灰色对象（已访问过，但未完全扫描的对象）要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>java</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础-反射和ClassLoader初认识</title>
    <url>/2020/01/25/java%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E5%88%9D%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<a id="more"></a>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们创建一个带有属性、私有方法和共有方法的类，然后在主类中通过反射的方式调用该类的方法和属性。</p>
<p>类Robot代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(String helloSentence)</span></span>&#123;</span><br><span class="line">        System.out.println(helloSentence + <span class="string">" "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">throwHello</span><span class="params">(String tag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类ReflectSample代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class rc = Class.forName(<span class="string">"com.interview.javabasic.reflect.Robot"</span>);</span><br><span class="line">        Robot r = (Robot) rc.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"Class name is "</span> + rc.getName());</span><br><span class="line">        <span class="comment">// 调用Robot类的方法</span></span><br><span class="line">        Method getHello = rc.getDeclaredMethod(<span class="string">"throwHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        getHello.setAccessible(<span class="keyword">true</span>);       <span class="comment">// 使私有方法可以使用</span></span><br><span class="line">        Object str = getHello.invoke(r, <span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"getHello result is "</span> + str);</span><br><span class="line">        <span class="comment">// 另一种方法获取方法,getMethod可以得到所有方法，包括继承的</span></span><br><span class="line">        Method sayHi = rc.getMethod(<span class="string">"sayHi"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHi.invoke(r,<span class="string">"Welcome"</span>);</span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        Field name = rc.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(r, <span class="string">"Alice"</span>);</span><br><span class="line">        sayHi.invoke(r, <span class="string">"Welcome"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>ClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流。它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。</p>
<p>ClassLoader的种类有四种，分别是加载核心库java.*的BootStrapClassLoader、加载扩展库javax.*的ExtClassLoader、加载程序所在目录的AppClassLoader和自定义的ClassLoader</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>我们接下来主要是自定义一个ClassLoader，实现自定义主要是实现两个函数，一个是查找.class文件的findClass函数，还有一个就是将.class文件里的字节码转化成类对象的defineClass函数。我们只需要重写第一个findClass函数即可，而defineClass函数我们使用原生的。</p>
<p>类MyClassLoader代码，主要是得到.class文件的字节码然后交给defineClass函数处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> String classLoadName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path, String classLoadName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.classLoadName = classLoadName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于寻找类文件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于加载类文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name)&#123;</span><br><span class="line">        name = path + name + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                InputStream in = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(name));</span><br><span class="line">                ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                )&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类ClassLoaderChecker代码，主要是测试自定义类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.interview.javabasic.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderChecker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        MyClassLoader m = <span class="keyword">new</span> MyClassLoader(<span class="string">"C:\\Users\\11913\\Desktop\\"</span>,<span class="string">"myClassLoader"</span>);</span><br><span class="line">        Class c = m.loadClass(<span class="string">"Wali"</span>);</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-用一个栈来实现另一个栈的排序</title>
    <url>/2020/01/24/%E7%AE%97%E6%B3%95-%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个栈中的元素类型为整形，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个辅助栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。</p>
<a id="more"></a>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>输入描述</p>
<blockquote>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">第一行输入一个<span class="built_in">N</span>，表示栈中元素的个数</span><br><span class="line">第二行输入<span class="built_in">N</span>个整数a_iai表示栈顶到栈底的各个元素</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出描述</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出一行表示排序后的栈中栈顶到栈底的各个元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>输入</p>
<blockquote>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出</p>
<blockquote>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">8 </span><span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>要让一个栈（stack）从栈顶到栈底从大到小排序，我们就需要让辅助栈从栈顶到栈底从小到大排序，然后将辅助栈（help）的元素全部倒入原栈即可。</p>
<p>具体实现如下，我们从stack中弹出一个元素cur，如果help的栈顶元素比cur大，直接将cur压入help中即可，如果help的栈顶元素比cur小，那么我们弹出这个元素压入stack中，重复此动作，直到help的栈顶元素比cur大或者help为空。如此我们便可以将stack中的全部元素压入help中，然后我们将help中的元素倒入stack即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String ss = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(ss);</span><br><span class="line">        String[] data = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            stack.push(Integer.parseInt(data[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        stackSort();</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            System.out.print(stack.pop()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stackSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> data = stack.pop();</span><br><span class="line">            <span class="keyword">while</span>(!help.empty() &amp;&amp; help.peek() &lt; data)&#123;</span><br><span class="line">                stack.push(help.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            help.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!help.empty())&#123;</span><br><span class="line">            stack.push(help.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-逆序一个栈</title>
    <url>/2020/01/24/%E7%AE%97%E6%B3%95-%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个栈依次压入1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1。将这个栈转置后，从栈顶到栈底为1、2、3、4、5，也就是实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。</p>
<a id="more"></a>

<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>输入</p>
<blockquote>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>输出 </p>
<blockquote>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>对于12345这个例子，我们可以首先将栈底元素1取出，此时栈变成2345，然后我们递归调用逆序函数即可，此时栈变成5432，然后我们把原先的栈底元素1压入栈即可。</p>
<p>因此我们我们需要实现一个用递归形式将栈底的元素取出的函数。具体就是我们从栈里弹出一个元素，如果此时栈为空，那么我们直接返回这个元素即可；如果此时栈不为空，以123为例，我们取出3，此时栈为12，我们继续调用该函数即可，同时我们需要把取出来的3压回去。</p>
<p>这么说起来有点绕口，具体还是看代码比较好理解。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String ss = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(ss);</span><br><span class="line">        String[] arr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            stack.push(Integer.parseInt(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> last = getAndRemoveLastElement(stack);</span><br><span class="line">            stack.push(data);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> data = getAndRemoveLastElement(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2020/01/24/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p><strong>深入理解Java虚拟机第二章内容记录</strong></p>
<a id="more"></a>

<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示。</p>
<p>其中灰色表示由所有线程共享的数据区，白色表示线程隔离的数据区</p>
<p><img src="/images/%E5%9B%BE2-1.png" alt="图2-1"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中才入栈到出栈的过程。。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里的“几乎”所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域。</p>
<p>从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。</p>
<p>Java堆可以处于物理上不连续的内存空间内，但在逻辑上它应该被视为连续的。但对于大对象，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常。</p>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类的加载过程。</p>
<p>在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。根据Java堆是否规整可分为指针碰撞（Bump The Pointer）和空闲列表（Free List）两种分配方式，而Java堆是否规整又由垃圾收集器是否带有空间压缩整理（Compact）的能力决定。</p>
<p>为了保障并发情况下分配内存的线程安全，可以采用两种方式：一是对分配内存空间的动作进行同步处理——实际上是虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之后进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p>
<p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</p>
<p>接下来设置对象头。</p>
<p>此时从虚拟机的角度来看，一个新的对象已经产生，但是从Java程序的视角来看，对象创建才刚刚开始，之后要执行构造函数。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>HotSpot虚拟机对象的对象头包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为“Mark Word”。为了虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，根据对象的状态复用自己的存储空间。</p>
<p>对象头的另外一个部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。如果对象是一个Java数组，那在对象头里还必须有一块用于记录数组长度的数据。</p>
<p>接下来的实例数据部分是对象真正存储的有效信息。这部分的存储顺序会收到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts、chars、bytes/booleans、oops(Ordinary Object Pointers,OOPs)。</p>
<p>对象的第三部分是对齐填充，起到占位符的作用。因为HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，即任何对象的大小都必须是8字节的整数倍。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。</p>
<p>主流的访问方式主要有使用句柄访问和直接指针两种。</p>
<p><img src="/images/%E5%9B%BE2-2.png" alt="图2-2"></p>
<p>​                                                    图 2-2 通过句柄访问对象</p>
<p><img src="/images/%E5%9B%BE2-3.png" alt="图2-3"></p>
<p>​                                                    图 2-3 通过直接指针访问对象</p>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据，而reference本身不需要被修改；使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java内存区域</tag>
        <tag>溢出异常</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-由两个栈组成的队列</title>
    <url>/2020/01/24/%E7%AE%97%E6%B3%95-%E7%94%B1%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90%E7%9A%84%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编写一个类，用两个栈来实现队列，支持队列的基本操作(add、poll、peek)。</p>
<a id="more"></a>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>输入</p>
<blockquote>
<p>6</p>
<p>add 1</p>
<p>add 2</p>
<p>add 3</p>
<p>peek</p>
<p>poll</p>
<p>peek</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>1</p>
<p>2</p>
</blockquote>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>具体实现是一个栈作为压入栈，记为pushStack，另一个栈作为弹出栈，记为popStack。压入数据时只往pushStack中压入，弹出数据时只从popStack中弹出。</p>
<p>我们把pushStack中的数据压入popStack时，数据的弹出顺序就会相反，也就和队列一致了。</p>
<p>但我们要注意pushStack往popStack倒数据的时机，需要满足两个条件，第一，倒的时候要一次性全部倒入popStack，第二popStack不为空的时候不能倒数据。</p>
<p>我们可以在每次add、poll、peek执行完毕只会都尝试倒一次数据，如果满足上述两个条件就倒。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; pushStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; popStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] ss = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(ss[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            String[] arr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"add"</span>))&#123;</span><br><span class="line">                add(Integer.parseInt(arr[<span class="number">1</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"peek"</span>))&#123;</span><br><span class="line">                peek();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pushToPop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(popStack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pushStack.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> data = pushStack.pop();</span><br><span class="line">                popStack.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        pushStack.push(num);</span><br><span class="line">        pushToPop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushStack.empty() &amp;&amp; popStack.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        System.out.println(popStack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushStack.empty() &amp;&amp; popStack.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        popStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
</search>
