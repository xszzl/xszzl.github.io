<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="XiaoShanUzi" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="XiaoShanUzi">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XiaoShanUzi">
<meta property="article:author" content="XiaoShanUzi">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>XiaoShanUzi</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
	
	<a href="https://github.com/xszzl/" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">XiaoShanUzi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">to be a coder</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/Java%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/26/Java%E4%BB%A3%E7%90%86/" itemprop="url">Java代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-26T14:48:21+08:00">
                2020-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/26/Java%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/26/Java%E4%BB%A3%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/26/Java%E4%BB%A3%E7%90%86/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/KMP/" itemprop="url">KMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T14:48:21+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/25/KMP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/25/KMP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>对于一个字符串ABCDABE，如果我们已经匹配到了E才发生不匹配，此时我们不用从头开始匹配，可以直接从C开始匹配，因为E之前的字符串的前缀和后缀有AB是相同的。</p>
<p>直接上代码</p>
<p>next数组就是前后缀最大长度，比如ABAA</p>
<p>A [0]</p>
<p>AB 前缀为[A]，后缀为[B]， [0]</p>
<p>ABA 前缀为[A, AB] 后缀为[A, BA] [1]</p>
<p>ABAA 前缀为[A, AB, ABA] 后缀为[A, AA, BAA] [1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeNext</span><span class="params">(<span class="keyword">char</span>[] P,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;	<span class="comment">// i为下标，k为最大前后缀长度</span></span><br><span class="line">    <span class="keyword">int</span> m = P.length;</span><br><span class="line">    <span class="comment">// 第一个字符的前缀和后缀相同的长度为0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="comment">// 精髓所在</span></span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; P[i] != p[k])</span><br><span class="line">            k = next[k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(P[i] == P[k])&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个while循环的条件是i和k失配了，那么我们就要换一个k来和i配对，那么换多少呢，就是根据next[k-1]，因为next[k-1]代表的就是以k-1结尾的串的前后缀长度。如下图所示</p>
<p><img src="https://images0.cnblogs.com/blog/432480/201307/30163843-2fd01a5b306b4fbb8183b0a7c145d79c.png" alt="img">)<img src="https://images0.cnblogs.com/blog/432480/201307/30171002-e67282f4d1d84cb59e0152826b58e6ac.png" alt="img"></p>
<p>举个例子就是</p>
<p>ABCABDAB<strong>C</strong></p>
<p>​       ABCAB<strong>D</strong>ABC</p>
<p>​               AB<strong>C</strong>ABDABC</p>
<p>KMP模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] T,<span class="keyword">char</span>[] P,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = T.length, m = P.length;</span><br><span class="line">    <span class="keyword">int</span> i,q;	<span class="comment">// q表示P的指针</span></span><br><span class="line">    makeNext(P, next);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, q = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q &gt; <span class="number">0</span> &amp;&amp; P[q] != T[i])</span><br><span class="line">            q = next[q-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(P[q] == T[i])</span><br><span class="line">            q++;</span><br><span class="line">        <span class="keyword">if</span>(q == m)</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/AQS/" itemprop="url">AQS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T14:48:21+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/25/AQS/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/25/AQS/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>&lt;!-more–&gt;</p>
<p><img src="https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png" alt="img"></p>
<h3 id="节点状态waitStatus"><a href="#节点状态waitStatus" class="headerlink" title="节点状态waitStatus"></a>节点状态waitStatus</h3><ul>
<li><strong>CANCELLED</strong>(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><h4 id="acquire（int）"><a href="#acquire（int）" class="headerlink" title="acquire（int）"></a>acquire（int）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h4><p>尝试获取资源。如果获取成功，返回true，否则返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h4><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 根据给定节点模式构造节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试快速方式直接到队尾</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span>(pred != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 失败就通过enq入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span></span>&#123;</span><br><span class="line">	<span class="comment">// CAS自旋</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="keyword">null</span>)&#123;	<span class="comment">// 队列为空，就创建一个头节点，tail也指向它</span></span><br><span class="line">            <span class="keyword">if</span>(compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetTail(t, node))&#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h4><p>在等待队列中排队，直到被唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;	<span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;	<span class="comment">// 标记等待过程中是否被中断过</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();	<span class="comment">// 前驱节点</span></span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，则当前节点可以去尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span>(p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);	<span class="comment">// 拿到资源后将head指向该节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;	<span class="comment">// 在setHead中已经将node.prev设置为null，此处将p.next设为null，GC就会回收p</span></span><br><span class="line">                failed = <span class="keyword">false</span>;	<span class="comment">// 成功获取资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;	<span class="comment">// 返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果要等待，则通过park()进入waiting状态，直到被unpark().如果期间被中断，就会从park()中醒过来，发现拿不到资源继续进入park()等待</span></span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">              parkAndCheckInterrupt())&#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果等待过程中没有成功获取到资源，如timeout，或者可中断情况下被中断了</span></span><br><span class="line">            <span class="keyword">if</span>(failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h4><p>检查状态，判断是否需要进入waiting状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 表示后继节点在等待自己唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(ws &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果前驱放弃了，那么一直往前</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span>(pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果前驱正常就把前驱的状态设置为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><p>此方法就是让线程去休息，真正进入等待状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);	<span class="comment">// 调用park()进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();	<span class="comment">// 如果被唤醒查看自己是不是被中断的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><h4 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a>release(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);	<span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h4><p>此方法尝试去释放定量的资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnSupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h4><p>此方法用于唤醒等待队列中的下一个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span>(ws &lt; <span class="number">0</span>)	<span class="comment">// 置零当前线程所在的结点状态，允许失败</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>)&#123;	<span class="comment">// 如果后继节点为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从后向前找到有效的节点</span></span><br><span class="line">        <span class="keyword">for</span>(Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);	<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h3><h4 id="acquireShared-int-1"><a href="#acquireShared-int-1" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h4><p>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span>(p == head)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 将head指向自己，如果还有剩余的资源可以再唤醒之后的线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                   	p.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">              parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setHeadAndPropagate-Node-int"><a href="#setHeadAndPropagate-Node-int" class="headerlink" title="setHeadAndPropagate(Node, int)"></a>setHeadAndPropagate(Node, int)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span></span>&#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span>(propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><h4 id="releaseShared-1"><a href="#releaseShared-1" class="headerlink" title="releaseShared()"></a>releaseShared()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tryReleaseShared(arg))&#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h4><p>此方法主要用于唤醒后继节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span>(h != <span class="keyword">null</span> &amp;&amp; h != tail)&#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span>(ws == Node.SIGNAL)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h == head)	<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义同步器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="title">entends</span> <span class="title">AbstarctQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// return getState() == 1;</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetStatus(<span class="number">0</span>, <span class="number">1</span>))&#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试释放资源</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span></span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(getStatus() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setStatus(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> ture;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.accquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="url">自我介绍及面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-24T20:53:24+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/24/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/24/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Redis用来做什么了"><a href="#Redis用来做什么了" class="headerlink" title="Redis用来做什么了"></a>Redis用来做什么了</h4><p>在项目中redis我用来做存储和缓存，具体来说就是用redis代替session来存储验证码，然后用redis存储id到用户和登录凭证的映射，减少数据库的访问，然后对于频率比较高的操作比如点赞也用redis存储，还使用redis来存储了UV和活跃用户来做统计，其他一些数据库不太好存储的比如关注，粉丝这些适合非关系型数据库存储的内容也用redis存储</p>
<h4 id="有没有遇到过缓存和数据库不一致"><a href="#有没有遇到过缓存和数据库不一致" class="headerlink" title="有没有遇到过缓存和数据库不一致"></a>有没有遇到过缓存和数据库不一致</h4><p>有，在项目中如果用户更新了个人信息，那么redis中的内容就会和数据库里的不一致。一般可以采用先清空缓存，然后更新数据，或者将变化的key记录下来，之后再去删除缓存。我采用的是直接删除缓存</p>
<h4 id="Redis支持事务吗"><a href="#Redis支持事务吗" class="headerlink" title="Redis支持事务吗"></a>Redis支持事务吗</h4><p>支持。redis是单线程的，因此它只要保证一个事务的执行不会被打断即可，事务可以运行直到执行完所有事务队列中的命令为止。</p>
<p>我在项目中对redis事务的运用是在，对用户关注的时候，要将该用户的关注列表和对方的粉丝列表的更新放在事务中。</p>
<h4 id="Redis支持的数据结构知道-用过哪些"><a href="#Redis支持的数据结构知道-用过哪些" class="headerlink" title="Redis支持的数据结构知道/用过哪些"></a>Redis支持的数据结构知道/用过哪些</h4><p>最基本的有string/list/set/sorted set/hash，然后还有HyperLoglog，bitmap。</p>
<p>在项目中用过string，set，zset，HyperLogLog，bitmap。其中HyperLogLog的优点在于数据量非常非常大的时候计算基数所需的空间也总是固定且很小的，但是存在0.81%的标准差。</p>
<h4 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h4><ol>
<li>基于内存实现，内存计算</li>
<li>单线程操作，没有线程上下文切换</li>
<li>多路I/O复用的线程模型，实现了一个线程监控多个IO流</li>
<li>对外部依赖比较少，属于轻量级内存数据库</li>
</ol>
<h4 id="Redis为什么用跳表而不是B-树"><a href="#Redis为什么用跳表而不是B-树" class="headerlink" title="Redis为什么用跳表而不是B+树"></a>Redis为什么用跳表而不是B+树</h4><p>Redis中跳表用于实现sorted set中根据分数来查询数据。跳表的指针要少于B+树，因此占用的内存要小；然后sorted set常常会有范围查询，比如zrange，zrevrange，在这方面跳表的效率明显要高于在叶节点只有一个指针的B+树；最后就是跳表相对于B+树更容易实现和调试。</p>
<h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><p>Redis持久化有RDB快照方式和AOF增量方式。</p>
<p>其中RDB是全量持久化，就是将当前内存中的数据集快照全部写入磁盘，可以自动触发也可以手动触发，触发之后进程会fork一个子进程来负责快照，在fork子进程的时候会阻塞。</p>
<p>AOF是通过记录redis服务器执行的写命令来保存状态的。然后AOF如果过大可以进行AOF重写，也就是用根据Redis当前的状态用一条命令来代替前面的多条命令。AOF重写也是交给子进程完成，然后有一个重写缓冲区来记录重写期间的写操作。</p>
<p>一般来说AOF跟安全，但是文件尺寸更大，恢复也较慢，RDB安全性差一点，但是文件尺寸小，恢复快。</p>
<h4 id="做过Redis分布式锁，需要注意什么"><a href="#做过Redis分布式锁，需要注意什么" class="headerlink" title="做过Redis分布式锁，需要注意什么"></a>做过Redis分布式锁，需要注意什么</h4><p>没做过。以下内容是往上查阅得到的。</p>
<p>首先是要保证原子性，确保获取锁和设置超时时间是原子操作；需要注意超时时间，要避免有长时间执行的代码任务；如果获取锁失败应该怎么做，是轮询还是业务失败；是否需要支持可重入性；如果获取到锁之后redis挂了怎么办；redis服务器时间发生跳跃导致两个客户端同时获取到锁</p>
<h4 id="kafka用来做什么"><a href="#kafka用来做什么" class="headerlink" title="kafka用来做什么"></a>kafka用来做什么</h4><p>kafka主要是用来做系统通知和事件异步处理。</p>
<p>系统通知就是，比如某个用户给一个帖子点赞之后就会触发一个点赞事件，然后消费者消费这个事件，将事件的内容取出，封装成一条系统消息保存到数据库中，让用户可以看到通知。</p>
<p>事件异步处理逻辑是一样的，也是消息队列的使用，比如帖子的分数更新之后就会触发帖子同步事件，然后监听器会消费这个事件，更新es中的帖子数据。</p>
<h4 id="为什么用kafka，而不用其他MQ"><a href="#为什么用kafka，而不用其他MQ" class="headerlink" title="为什么用kafka，而不用其他MQ"></a>为什么用kafka，而不用其他MQ</h4><p>一个是因为kafka比较有名把，另一个就是因为kafka的性能比较好。它是顺序读写磁盘的，顺序读写磁盘的效率好像比内存读写还快，然后有页缓存，可以将磁盘中的数据缓存到内存中。同时由于生产者和消费者的消息格式是一样的，kafka还可以通过零拷贝技术，也就是不经过应用程序直接到网卡来提高速度</p>
<h4 id="kafka基本架构"><a href="#kafka基本架构" class="headerlink" title="kafka基本架构"></a>kafka基本架构</h4><p>kafka中有几个核心概念，分别是生产者；消费者，然后多个消费者可以构成一个消费者组；Topic，Topic就是消息队列，然后每个Topic可以被划分为多个分区；Broker，就是一个kafka服务器，在服务器上数据有副本，副本可以分为Leader副本和follower副本，然后多个Broker又组成一个Cluster集群，每个Cluster集群有一个Broker作为Controller。</p>
<p>然后kafka是运行在zookeeper之上的。</p>
<h4 id="消息是怎么存储的，怎么消费的"><a href="#消息是怎么存储的，怎么消费的" class="headerlink" title="消息是怎么存储的，怎么消费的"></a>消息是怎么存储的，怎么消费的</h4><p>kafka是以partition为存储单元的，每个parition都是一个有序的，不变的消息队列，而Parition又是由多个Segment组成的，每个segment有自己的offset，当一个segment被写满，则一个新的segment会被创建，成为新的active segment。具体在磁盘上，一个segment就是一个目录，目录下有一个index文件和log文件，其中index是到log的索引，而log就是被存储的信息。其中索引是内存映射的，所谓内存映射就是将文件和物理内存映射，使得可以像读写磁盘一样读写内存，同时减少一次磁盘到内核态的拷贝</p>
<p>消费者会定期去服务器拉取数据来消费，服务器会记录每个消费者在在partition下消费的offset，之后消费必须从上次的offset开始。每个消费者组能只能消费partition下不同的消息，不同的消费者组可以消费相同的消息</p>
<h4 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h4><p>kafka的broker中有副本存在，分为leader副本和follower副本，leader副本负责接收生产者消息，消费者也是从leader这里拉取，follower副本之和leader副本进行通信，同时follower副本也分为可用副本集合和不属于的副本。可用副本集合中的副本是和leader副本的数据一致的，当leader副本宕机时优先从可用副本集合中选取来代替leader。因此假如没有可用副本，此时leader宕机了，那么必然会发生消息丢失。我们可以通过参数来配置可用副本集合的最少副本个数。</p>
<p>同时生产者生产消息也有三种模式，一种是需要leader确认即可，一种是需要所有follower副本集合都同步才可以，最后一种是无需等待服务器确认。因此如果是最后一种，那么消息也会发生丢失</p>
<h4 id="kafka是怎么保证其水平扩展性的"><a href="#kafka是怎么保证其水平扩展性的" class="headerlink" title="kafka是怎么保证其水平扩展性的"></a>kafka是怎么保证其水平扩展性的</h4><p>首先是为新的broker分配一个唯一id，然后将新的服务器设置为要迁移的partition的follower，让它进行replica完成数据的同步</p>
<h4 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h4><p>Netty通过Reactor模型基于多路复用接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池用于处理请求的accept事件，而work线程池用于负责请求的read和write事件。根据线程池个数和线程个数可以分为单线程模型，多线程模型和主从多线程模型。</p>
<h4 id="Netty为什么性能高"><a href="#Netty为什么性能高" class="headerlink" title="Netty为什么性能高"></a>Netty为什么性能高</h4><p>首先Netty使用的是NIO模型，是非阻塞的，避免了大量IO读写阻塞的开销，同时Netty采用异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作。</p>
<p>其次是因为Netty用到了零拷贝，它缓冲区使用的不是堆内存，而是直接内存，减少了堆内存到直接内存的拷贝，同时提供了组合buffer对象，避免了传统的内存拷贝方式合并buffer，然后Netty的文件传输使用的是transferTo()方法，直接将数据从缓冲区发送到channel中，而不需要拷贝。</p>
<p>同时对于堆外缓冲区的使用是循环使用的，减少了内存回收的开销。</p>
<p>最后就是Netty支持很多高效的序列化方式，比如Protobuf</p>
<h4 id="什么是NIO-BIO-AIO"><a href="#什么是NIO-BIO-AIO" class="headerlink" title="什么是NIO/BIO/AIO"></a>什么是NIO/BIO/AIO</h4><p>BIO就是同步且阻塞的模式，服务器实现模式为一个连接一个线程</p>
<p>NIO就是同步非阻塞模式，服务器模式为一个请求一个线程</p>
<p>AIO就是异步非阻塞模式，服务器模式为一个有效请求一个线程，客户端的IO请求都是由操作系统完成了再通知服务器应用去启动线程进行处理的。</p>
<h4 id="Netty源码看过哪些"><a href="#Netty源码看过哪些" class="headerlink" title="Netty源码看过哪些"></a>Netty源码看过哪些</h4><p>只看过EventLoop的部分源码，主要是IO部分。</p>
<p>在EventLoop.execute第一次调用时就会启动EventLoop所对应的线程，该线程的run方法可以说是Netty NIO的核心。</p>
<p>它首先检查任务队列是否为空，不为空的话就返回就绪的IO事件个数，如果为空的话就阻塞当前线程一段时间等待任务。</p>
<p>接下来就是处理IO事件。这里有一个ioRatio参数表示IO操作占线程运行的时间比，如果是100，就直接查询就绪的IO事件，然后执行任务队列里的任务。如果不为100就需要计算执行task需要的事件然后作为参数传入。这个查询IO就绪事件其实就对应了NIO的Selector的那一套处理流程，OP_READ,OP_WRITE,OP_CONNECT。OP_READ的操作就是分配ByteBuf，从SocketChannel中读取数据，最后发送一个inbound事件交给handler去处理</p>
<h4 id="Netty为什么要自己实现ThreadLocal"><a href="#Netty为什么要自己实现ThreadLocal" class="headerlink" title="Netty为什么要自己实现ThreadLocal"></a>Netty为什么要自己实现ThreadLocal</h4><p>JDK中ThreadLocalMap.Entry数组来存储ThreadLocal对象和线程特有对象，用key计算索引位置发送冲突的时候使用的是下一个索引，效率不是太高，同时还存在内存泄漏的问题。</p>
<p>Netty的FastThreadLocal的索引下标是确定的，并存放在索引表中，同时方便在removeAll时清理对象，防止内存泄漏，同时FastThreadLocal的数组要比JDK的大很多，避免了反复的resize过程</p>
<h4 id="介绍一下Netty的整体架构"><a href="#介绍一下Netty的整体架构" class="headerlink" title="介绍一下Netty的整体架构"></a>介绍一下Netty的整体架构</h4><p>Netty的整体架构可以分为传输服务、容器集成、协议支持、安全支持和Core核心。</p>
<h4 id="介绍一下EventLoop和channel"><a href="#介绍一下EventLoop和channel" class="headerlink" title="介绍一下EventLoop和channel"></a>介绍一下EventLoop和channel</h4><p>NioEventLoop是EventLoop的实现类，其维护了一个线程和任务队列，支持异步提交任务，线程启动时会调用NioEventLoop的run方法，执行IO任务和非IO任务，IO任务即accept、read、write、connect等，由processSelectKeys方法触发，而非IO任务，添加到taskQueue中的任务，如register0，bind0等，由runAllTasks方法触发，两种任务时间比由idRatio控制。</p>
<p>channel用于执行网络I/O操作，不同的协议、不同的阻塞类型的连接有不同的Channel类型对应。每个Channel有一个channelpipeline，channelpipeline中有channelhandler用于处理业务。</p>
<h4 id="SpringBoot的优势是什么"><a href="#SpringBoot的优势是什么" class="headerlink" title="SpringBoot的优势是什么"></a>SpringBoot的优势是什么</h4><p>主要就是简化了开发</p>
<ol>
<li>创建独立的Spring应用程序</li>
<li>嵌入的Tomcat，无需部署WAR文件</li>
<li>简化Maven配置</li>
<li>自动配置Spring</li>
</ol>
<h4 id="SpringBoot自动配置-依赖的原理是什么"><a href="#SpringBoot自动配置-依赖的原理是什么" class="headerlink" title="SpringBoot自动配置/依赖的原理是什么"></a>SpringBoot自动配置/依赖的原理是什么</h4><p>在SpringBoot项目启动类上有一个@SpringBootApplication注解，该注解是一个复合注解，里面有一个@EnableAutoConfiguration注解，该注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/23/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%89/" itemprop="url">Java面经整理之三</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-23T17:35:22+08:00">
                2020-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/23/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/23/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%89/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="问题1-JVM垃圾处理方法"><a href="#问题1-JVM垃圾处理方法" class="headerlink" title="问题1 JVM垃圾处理方法"></a>问题1 JVM垃圾处理方法</h3><ul>
<li>标记-清理。从根节点开始标记，未被标记的是垃圾对象，清除所有未被标记的对象</li>
<li>复制算法。将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象移动到未使用的内存块中，然后清理正在使用的内存块</li>
<li>标记-整理。标记阶段同标记-清理算法相同，在整理阶段将所有标记了的对象压缩到内存的一段，之后清理边界所有的空间</li>
</ul>
<h3 id="问题2-哪些对象可以作为GC-Roots对象"><a href="#问题2-哪些对象可以作为GC-Roots对象" class="headerlink" title="问题2 哪些对象可以作为GC Roots对象"></a>问题2 哪些对象可以作为GC Roots对象</h3><ul>
<li>Java虚拟机栈中的对象</li>
<li>方法区中的静态成员</li>
<li>方法区中的常量引用对象</li>
<li>本地方法区中的JNI引用对象</li>
</ul>
<h3 id="问题3-什么时候进行MinorGC，FullGC"><a href="#问题3-什么时候进行MinorGC，FullGC" class="headerlink" title="问题3 什么时候进行MinorGC，FullGC"></a>问题3 什么时候进行MinorGC，FullGC</h3><ul>
<li>MinorGC，新生代GC，复制算法，大对象可以直接进入老年代。当Eden中没有足够空间时发生一次。</li>
<li>FullGC，老年代GC，标记-清除/整理算法。当老年代没有足够空间时发生一次，一般FullGC都附带MinorGC</li>
</ul>
<h3 id="问题4-简单说说JVM中的垃圾收集器"><a href="#问题4-简单说说JVM中的垃圾收集器" class="headerlink" title="问题4 简单说说JVM中的垃圾收集器"></a>问题4 简单说说JVM中的垃圾收集器</h3><ul>
<li>Serial收集器，单线程，需要STW，新生代使用复制算法，老年代使用标记-整理算法</li>
<li>ParNew收集器，多线程版的Serial</li>
<li>Parallel Scavenge收集器，并行，注重吞吐量，所以停顿时间较长</li>
</ul>
<h3 id="问题5-介绍下CMS收集器"><a href="#问题5-介绍下CMS收集器" class="headerlink" title="问题5 介绍下CMS收集器"></a>问题5 介绍下CMS收集器</h3><ul>
<li>初始标记，STW，仅仅标记GC Roots能直接关联到的对象，很快</li>
<li>并发标记，和用户线程并行，主要的标记过程</li>
<li>重新标记，STW，修正并发标记期间标记发生变动的那一部分记录，也很快</li>
<li>并发清除，并发，标记清除</li>
</ul>
<p><strong>缺点</strong>：对处理器资源敏感；会产生浮动垃圾，有可能出现Concurrent Mode Failure，这会导致使用备用的Serial Old收集器；会产生空间碎片</p>
<h3 id="问题6-介绍下G1收集器"><a href="#问题6-介绍下G1收集器" class="headerlink" title="问题6 介绍下G1收集器"></a>问题6 介绍下G1收集器</h3><p>G1收集器将新生代和老年代分区取消，而是将堆划分出若干个区域（region），每一个Region可以扮演新生代的Eden、Survivor或者老年代，还有一个特殊存放大对象的Region区域。G1不需要全区域的垃圾收集，而是跟踪各个region垃圾堆积的价值，在后台维护一个优先队列，根据回收时间来优先回收价值最大的region。老年代使用标记-整理算法</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收，根据停顿时间来决定回收个数，需要STW</li>
</ul>
<h3 id="问题7-Java虚拟机内存划分"><a href="#问题7-Java虚拟机内存划分" class="headerlink" title="问题7 Java虚拟机内存划分"></a>问题7 Java虚拟机内存划分</h3><ul>
<li>程序计数器，线程私有，为当前线程字节码的位置指示器</li>
<li>虚拟机栈，线程私有，保存局部变量、基本数据类型以及堆内存中某个对象的引用变量。如果线程请求的栈深度超过虚拟机允许的深度就会出现StackOverFlowError。-Xss规定了栈的最大空间。如果虚拟机栈可以动态扩展，扩展到无法申请足够的内存，就会出现OOM</li>
<li>本地方法栈，线程私有，为Native方法服务</li>
<li>堆，被所有线程共享，用于存储创建的对象实例，GC的主要区域，可动态扩展，无法扩展会出现OutOfMemoryError，通过-Xms，-Xmx控制大小</li>
<li>方法区，共享，用于存储被虚拟机加载的类信息、常量、静态变量。JDK8之前的实现是永久代，JDK8之后是元空间。</li>
<li>运行时常量池，收到方法区的限制。运行时常量池在JDK7之后从方法区移到了堆中。</li>
</ul>
<h3 id="问题8-什么是双亲委派机制"><a href="#问题8-什么是双亲委派机制" class="headerlink" title="问题8 什么是双亲委派机制"></a>问题8 什么是双亲委派机制</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器无法完成该加载器请求时，子加载器才会尝试自己去加载。</p>
<h3 id="问题9-介绍下加载器"><a href="#问题9-介绍下加载器" class="headerlink" title="问题9 介绍下加载器"></a>问题9 介绍下加载器</h3><ul>
<li>启动类加载器Bootstrap，Java Runtime Home/lib</li>
<li>标准扩展类加载器，Java Runtime Home/lib/ext</li>
<li>系统类加载器，负责将系统的CLASSPATH中的类加载到内存中</li>
<li>自定义类加载器</li>
</ul>
<h3 id="问题10-java如何进行对象实例化的"><a href="#问题10-java如何进行对象实例化的" class="headerlink" title="问题10 java如何进行对象实例化的"></a>问题10 java如何进行对象实例化的</h3><p>当虚拟机遇到一个new指令时会去检查这个指令的参数能否在常量池中定位到某个类的符号引用，并且检查这个符号引用代表的类是否已经被加载。如果没有就执行类的加载，验证，准备，解析和初始化，这时候会为该对象进行内存分配，也就是把一块确定大小的内存从Java堆中划分出来，在分配的内存上完成对象的创建，对象内存分配有指针碰撞和空闲列表两种。</p>
<h3 id="问题11-内存分配如何保证线程安全"><a href="#问题11-内存分配如何保证线程安全" class="headerlink" title="问题11 内存分配如何保证线程安全"></a>问题11 内存分配如何保证线程安全</h3><ul>
<li>CAS+失败重试</li>
<li>给每一个线程都预先分配一小段内存，称为本地线程分配缓存，只有当本地线程分配缓存用完时才需要进行同步锁定。</li>
</ul>
<h3 id="问题12-对象被访问的时候是怎么被找到的"><a href="#问题12-对象被访问的时候是怎么被找到的" class="headerlink" title="问题12 对象被访问的时候是怎么被找到的"></a>问题12 对象被访问的时候是怎么被找到的</h3><ul>
<li>句柄访问。引用变量中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。对象移动之后，只要更改句柄中的地址即可，引用变量地址不用改变</li>
<li>直接指针访问。引用变量中存储的就是对象的直接地址，通过指针直接访问对象。</li>
</ul>
<h3 id="问题13-S-s-new-S-在内存中做了哪些事情"><a href="#问题13-S-s-new-S-在内存中做了哪些事情" class="headerlink" title="问题13 S s = new S();在内存中做了哪些事情"></a>问题13 S s = new S();在内存中做了哪些事情</h3><ol>
<li>加载S.class文件进内存</li>
<li>在栈内存为s开辟空间</li>
<li>在堆内存为S对象开辟空间</li>
<li>对对象的成员变量进行默认初始化</li>
<li>对对象的成员变量进行显式初始化</li>
<li>通过构造方法对对象的成员变量赋值</li>
<li>对象初始化完毕，将对象地址赋值给s变量</li>
</ol>
<h3 id="问题14-JConsole能够监视什么"><a href="#问题14-JConsole能够监视什么" class="headerlink" title="问题14 JConsole能够监视什么"></a>问题14 JConsole能够监视什么</h3><p>JConsole能够监视JVM内存的使用情况、线程堆栈跟踪、已装入的类和VM信息以及CE MBean</p>
<h3 id="问题15-JVM调优"><a href="#问题15-JVM调优" class="headerlink" title="问题15 JVM调优"></a>问题15 JVM调优</h3><ul>
<li>jps，一般用来查看进程的状态信息</li>
<li>jinfo，用来观察进程运行环境参数等信息</li>
<li>jstack，用来查看某个Java进程的堆栈信息。jstack pid</li>
<li>jmap，用来查看堆内存的使用情况。jmap -heap pid</li>
<li>jstat，进行实时命令监控，包括堆信息以及实时GC信息等</li>
</ul>
<h3 id="问题16-说一下引用"><a href="#问题16-说一下引用" class="headerlink" title="问题16 说一下引用"></a>问题16 说一下引用</h3><ul>
<li>强引用</li>
<li>软引用，内存不足时会被回收</li>
<li>弱引用，下一次GC会被回收</li>
<li>虚引用，只是为了在被回收时能收到一个系统通知</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="问题1-Spring-IOC理解以及实现原理"><a href="#问题1-Spring-IOC理解以及实现原理" class="headerlink" title="问题1 Spring IOC理解以及实现原理"></a>问题1 Spring IOC理解以及实现原理</h3><p>IOC也叫控制反转,DI叫依赖注入，是对IOC更简单的诠释。</p>
<p>控制反转也就是把传统上的由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。DI即组件之间的依赖关系由容器在运行期决定，由容器动态地将某种依赖关系注入到组件之中。</p>
<p><strong>实现原理</strong>是通过反射创建实例；获取需要注入的接口实现类并将其赋值给该接口</p>
<h3 id="问题2-Spring-AOP理解以及实现原理"><a href="#问题2-Spring-AOP理解以及实现原理" class="headerlink" title="问题2 Spring AOP理解以及实现原理"></a>问题2 Spring AOP理解以及实现原理</h3><p>AOP即面向切面编程，是指当需要在某一个方法之前或者之后做一些额外的操作，可以利用AOP将功能代码从业务逻辑中分离出来。</p>
<p>有几个重要的概念</p>
<ul>
<li>Joinpoint连接点，类里面可以被增强的方法</li>
<li>Pointcut切入点，即需要被拦截的连接点</li>
<li>Advice通知/增强，切入点要做的事情</li>
<li>Aspect切面：切入点+增强</li>
<li>Target目标：代理的目标对象，要增强的类</li>
<li>Weaving织入：把advice应用到target的过程</li>
<li>Proxy代理：一个类被AOP织入后，就产生一个结果代理类</li>
</ul>
<p><strong>实现原理</strong>：</p>
<p>动态代理，包括JDK动态代理和cglib动态代理</p>
<p>其中JDK代理只能代理实现了接口的类，原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。具体过程是实现一个接口InvocationHandler的类，然后通过构造函数传入要被代理的对象，重写该类的invoke方法，在主函数中只要获得被代理类的类加载器，然后调用Proxy.newProxyInstance方法就可以产生一个代理类。</p>
<p>cglib只要针对类实现代理，对是否实现接口没有要求。原理是对被代理的类生成一个子类，覆盖其中的方法。具体过程是定义一个实现了MethodInterceptor接口的类，实现其intercept()方法，在其中调用proxy.invokeSuper()。</p>
<h3 id="问题3-IoC容器的加载过程"><a href="#问题3-IoC容器的加载过程" class="headerlink" title="问题3 IoC容器的加载过程"></a>问题3 IoC容器的加载过程</h3><ul>
<li>Resource资源定位</li>
<li>创建一个BeanFactory</li>
<li>把读取配置信息的BeanDefinitionReader配置给BeanFactory</li>
<li>通过BeanDefinitionReader来解析Resource定位的资源，把用户定义好的Bean表示成IOC容器的内部数据BeanDefinition</li>
<li>将BeanDefinition保存到Map中完成注册</li>
</ul>
<h3 id="问题4-JDK动态代理与CGlib实现的区别"><a href="#问题4-JDK动态代理与CGlib实现的区别" class="headerlink" title="问题4 JDK动态代理与CGlib实现的区别"></a>问题4 JDK动态代理与CGlib实现的区别</h3><ul>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承所以父类不要声明为final</li>
<li>JDK代理不需要第三方库,CGlib必须依赖于CGLib的类库</li>
</ul>
<h3 id="问题5-Spring-MVC的原理"><a href="#问题5-Spring-MVC的原理" class="headerlink" title="问题5 Spring MVC的原理"></a>问题5 Spring MVC的原理</h3><ol>
<li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。</li>
<li>通过HandlerMapping找到映射</li>
<li>使用对应的Adapter进行业务逻辑处理</li>
<li>返回一个ModelAndView给DispatcherServlet</li>
<li>DispatchServlet将ModelAndView交给ViewResolver处理</li>
<li>ViewResolver生成一个View视图</li>
<li>DispatcherServlet要用View对Model进行渲染</li>
<li>客户端得到响应结果</li>
</ol>
<h3 id="问题6-BeanFactory和FactoryBean的区别"><a href="#问题6-BeanFactory和FactoryBean的区别" class="headerlink" title="问题6 BeanFactory和FactoryBean的区别"></a>问题6 BeanFactory和FactoryBean的区别</h3><p>BeanFactory是Bean工厂，是Spring IOC容器的最顶层接口，它的作用是管理Bean，即实例化、定位、配置应用程序中的对象以及建立这些对象间的依赖。</p>
<p>FactoryBean是一个Bean，作用是产生其他Bean实例，需要提供一个方法，该方法用来返回其他Bean实例。</p>
<h3 id="问题7-BeanFactory和ApplicationContext的区别"><a href="#问题7-BeanFactory和ApplicationContext的区别" class="headerlink" title="问题7 BeanFactory和ApplicationContext的区别"></a>问题7 BeanFactory和ApplicationContext的区别</h3><p>BeanFactory是Spring最顶层的接口，ApplicationContext接口是BeanFactory的派生，丰富了BeanFactory接口的功能。</p>
<p>其次，BeanFactory采用的是延迟加载形式来注入Bean，而ApplicationContext则是在容器启动的时候一次性创建了所有的Bean。因此BeanFactory启动的时候占用资源少，但是在启动时无法检查配置问题，而ApplicationContext则启动较慢，占用内存大，但是可以发现配置中的问题，同时应用程序运行较快。</p>
<h3 id="问题8-Spring中Bean的作用域有哪几种"><a href="#问题8-Spring中Bean的作用域有哪几种" class="headerlink" title="问题8 Spring中Bean的作用域有哪几种"></a>问题8 Spring中Bean的作用域有哪几种</h3><ul>
<li>singleton：Bean在每个Spring IOC容器中只有一个实例，默认作用域</li>
<li>prototype：每个Bean可以有多个实例</li>
<li>request：每次http请求都会创建一个Bean</li>
<li>session：在一个HTTP Session中，一个Bean对应一个实例</li>
<li>global-session：在一个全局的HTTP Session中，一个Bean对应一个实例。</li>
</ul>
<p><strong>一般只有无状态的Bean才能在多个线程环境下共享</strong></p>
<h3 id="问题9-Spring的事务"><a href="#问题9-Spring的事务" class="headerlink" title="问题9 Spring的事务"></a>问题9 Spring的事务</h3><ul>
<li>编程式事务：通过TransactionTemplate实现</li>
<li>声明式事务：建立在AOP之上。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编制到拦截的方法中</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/21/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/21/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%BA%8C/" itemprop="url">Java面经整理之二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-21T14:48:21+08:00">
                2020-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/21/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%BA%8C/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/21/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%BA%8C/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="问题1-Java的四个基本特性"><a href="#问题1-Java的四个基本特性" class="headerlink" title="问题1 Java的四个基本特性"></a>问题1 Java的四个基本特性</h3><ul>
<li>抽象，包括数据抽象和行为抽象</li>
<li>继承，从已有类得到继承信息创建新类的过程</li>
<li>封装，把事务封装成一个类，减少耦合，隐藏细节</li>
<li>多态，允许不同子类型的对象对同一消息做出不同的响应</li>
</ul>
<h3 id="问题2-如何理解多态"><a href="#问题2-如何理解多态" class="headerlink" title="问题2 如何理解多态"></a>问题2 如何理解多态</h3><ul>
<li>方法重载，实现的是编译时的多态性，指的是一个类存在多个同名的不同方法，这些方法的参数个数、顺序以及类型不同</li>
<li>方法重写，实现的是运行时的多态，子类与父类的方法返回值类型、方法名、参数个数以及类型完全相同，但是实现不同。</li>
<li>用父类型引用来引用子类型对象</li>
</ul>
<h3 id="问题3-面向对象的六个基本原则"><a href="#问题3-面向对象的六个基本原则" class="headerlink" title="问题3 面向对象的六个基本原则"></a>问题3 面向对象的六个基本原则</h3><ul>
<li>单一职责，一个类应该只有一个发生变化的原因</li>
<li>里氏替换原则，任何时候都可以用子类替换父类</li>
<li>依赖倒置，面向接口编程</li>
<li>接口隔离，接口要小而专，绝不能大而全</li>
<li>迪米特法则，又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li>
<li>开闭原则，对扩展开放，对修改关闭。需要做到两点：抽象，封装可变性，即将系统中的各种可变因素封装到一个继承结构中。</li>
</ul>
<h3 id="问题4-static和final的区别和用途"><a href="#问题4-static和final的区别和用途" class="headerlink" title="问题4 static和final的区别和用途"></a>问题4 static和final的区别和用途</h3><p><strong>static</strong></p>
<ul>
<li>修饰变量：静态变量随着类加载时被完成初始化，内存中只有一个，所有类共享静态变量</li>
<li>修饰方法：在类加载的时候就存在，不依赖任何实例；static方法必须实现，不能用abstract修饰</li>
<li>修饰代码块：在类加载完之后就会执行</li>
<li>父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</li>
</ul>
<p><strong>final</strong></p>
<ul>
<li>修饰变量<ol>
<li>编译时常量，基本类型，类加载过程完成初始化，编译后带入任何计算式中</li>
<li>运行时常量，基本类型或者引用数据类型，引用不可变，但引用对象内容可变</li>
</ol>
</li>
<li>修饰方法：不能被继承，不能被子类修改</li>
<li>修饰类：不能被继承</li>
<li>修饰形参：final形参不可变</li>
</ul>
<p>对于变量，在类加载过程中，static int a = 3; a会被初始化为int的初始值即0，但是final int a = 3; a会被初始化为3.</p>
<h3 id="问题5-HasthMap和Hashtable的区别"><a href="#问题5-HasthMap和Hashtable的区别" class="headerlink" title="问题5 HasthMap和Hashtable的区别"></a>问题5 HasthMap和Hashtable的区别</h3><ul>
<li>Hashtable的方法是同步的，HashMap未经同步</li>
<li>Hashtable不允许null值，而HashMap允许null值</li>
<li>Hashtable使用Enumeration来遍历，HashMap使用Iterator来遍历</li>
<li>Hashtable直接使用对象的hashCode，而HashMap重新计算hash值，并且用于代替求模</li>
<li>Hashtable中hash数组默认大小为11，增加方式是old*2+1，而HashMap数组的默认大小为16，而且一定是2的指数</li>
<li>Hashtable继承自Dictionary类，HashMap继承自AbstractMap类</li>
</ul>
<h3 id="问题6-HashMap和ConcurrentHashMap的区别"><a href="#问题6-HashMap和ConcurrentHashMap的区别" class="headerlink" title="问题6 HashMap和ConcurrentHashMap的区别"></a>问题6 HashMap和ConcurrentHashMap的区别</h3><ul>
<li>HashMap是非线程安全的，ConcurrentHashMap是线程安全的</li>
<li>ConcurrentHashMap将整个Hash桶进行了分段segment，而且每个segment上面都有锁存在，插入元素的时候就需要先获取锁</li>
</ul>
<h3 id="问题7-ConcurrentHashMap如何保证线程安全"><a href="#问题7-ConcurrentHashMap如何保证线程安全" class="headerlink" title="问题7 ConcurrentHashMap如何保证线程安全"></a>问题7 ConcurrentHashMap如何保证线程安全</h3><ul>
<li>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，同时将需要用到的共享变量用volatile修饰，保证其可见性</li>
<li>put方法首先定位到segment，然后在segment里进行插入操作。第一步判断是否需要对segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里</li>
</ul>
<h3 id="问题8-如何处理构造相同hashcode字符串攻击"><a href="#问题8-如何处理构造相同hashcode字符串攻击" class="headerlink" title="问题8 如何处理构造相同hashcode字符串攻击"></a>问题8 如何处理构造相同hashcode字符串攻击</h3><p>可以限制post和get参数的个数，在JDK7中是会在链表长度超过一定的阈值，Hashmap会动态使用一个专门的treemap来替换这些string</p>
<h3 id="问题9-介绍JDK8之后HashMap和ConcurrentHashMap"><a href="#问题9-介绍JDK8之后HashMap和ConcurrentHashMap" class="headerlink" title="问题9 介绍JDK8之后HashMap和ConcurrentHashMap"></a>问题9 介绍JDK8之后HashMap和ConcurrentHashMap</h3><p><strong>HashMap</strong></p>
<ul>
<li>JDK8之后HashMap的底层从数组+链表实现变成了数组+链表+红黑树实现。</li>
<li>hash方法变为了(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)，避免了高位不同低位相同而导致的碰撞</li>
<li>在JDK7中resize过程会将元素改变的排列顺序，因此可能会导致多线程扩容时出现环线链表而导致死锁，而在JDK8中，由于扩容是增加一个高位，高位可以是0或1，因此我们只需将原来的链表分成两个链表，一个还是在原来的index下，另一个为index+扩容大小的下标，这样就可以保证链表的元素还是和原来的顺序一致，避免了形成环导致的死锁问题，当然HashMap还是不是线程安全的</li>
</ul>
<p><strong>ConcurrentHashMap</strong></p>
<ul>
<li>ConcurrentHashMap将segment锁改为了cas+synchronized</li>
</ul>
<h3 id="问题10-简述JDK8下HashMap和ConcurrentHashMap的put过程"><a href="#问题10-简述JDK8下HashMap和ConcurrentHashMap的put过程" class="headerlink" title="问题10 简述JDK8下HashMap和ConcurrentHashMap的put过程"></a>问题10 简述JDK8下HashMap和ConcurrentHashMap的put过程</h3><p><strong>HashMap</strong></p>
<ol>
<li>如果HashMap未被初始化，则初始化</li>
<li>对key求hash，然后与操作求下标</li>
<li>判断Node节点是否初始化，没有则初始化</li>
<li>如果没有碰撞，直接放入桶中，节点已经存在就替换旧值</li>
<li>如果发生了碰撞，以链表的方式链接到后面。如果链表长度超过了阈值，就转成红黑树</li>
<li>如果桶超过容量*负载因子的大小就需要resize扩容</li>
</ol>
<p><strong>ConcurrentHashMap</strong></p>
<ol>
<li>判断Node[]数组是否初始化，没有则初始化</li>
<li>对key求hash，然后与操作求下标</li>
<li>判断是否有Node节点，如果没有则使用CAS添加头节点，添加失败则进入下次循环</li>
<li>如果有头节点，则尝试获取锁，使用synchronized锁住头节点，然后进行添加操作。如果链表长度达到临界值就转成红黑树</li>
<li>如果桶超过容量*负载因子的大小就需要resize扩容，同时如果其他线程检查到内部正在进行扩容，则帮助它一起扩容</li>
</ol>
<h3 id="问题11-String、StringBuffer、StringBuilder"><a href="#问题11-String、StringBuffer、StringBuilder" class="headerlink" title="问题11 String、StringBuffer、StringBuilder"></a>问题11 String、StringBuffer、StringBuilder</h3><ul>
<li><p>都是final类，不允许被继承</p>
</li>
<li><p>String是不可变的，而StringBuffer和StringBuilder是可变的</p>
</li>
<li><p>StringBuffer是StringBuilder方法加上synchronized，因此StringBuffer是线程安全的，但是StringBuilder的性能更好</p>
</li>
<li><p>如果一个String类型的字符串在编译时可以确定是一个字符串常量，那么编译完成后，字符串会自动拼接成一个常量，此时String的速度比StringBuilder还要好，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"1"</span> + <span class="string">"2"</span> + <span class="string">"3"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>).append(<span class="string">"2"</span>).append(<span class="string">"3"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="问题12-如何理解String的不变性"><a href="#问题12-如何理解String的不变性" class="headerlink" title="问题12 如何理解String的不变性"></a>问题12 如何理解String的不变性</h3><ul>
<li>String类是被final修饰的，不能被继承</li>
<li>在用“+”连接字符串的时候会自动创建新的字符串</li>
<li>String s = new String(“Hello”);如果字符串常量池中没有Hello，则会在字符串常量池中创建，并且堆上创建s对象，如果字符串常量池中有则只需要在堆上创建即可。</li>
<li>在Java中，通过使用”+“来串联字符串的时候，底层会转成通过StringBuilder实例的append()方法来实现</li>
</ul>
<h3 id="问题13-hashCode和equals"><a href="#问题13-hashCode和equals" class="headerlink" title="问题13 hashCode和equals"></a>问题13 hashCode和equals</h3><p>String类重写了Object的hashCode方法和toString方法。</p>
<p>两个相等的对象一般都要有相同的hashcode，如果重写了equals，比如String只要值相等，其equals即返回true，但是如果没有重写hashcode方法，就会发生混淆，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>如果没有重写hashcode方法，那么在set中就会有两个值为abc的对象</p>
<h3 id="问题14-Java如何实现序列化和反序列化"><a href="#问题14-Java如何实现序列化和反序列化" class="headerlink" title="问题14 Java如何实现序列化和反序列化"></a>问题14 Java如何实现序列化和反序列化</h3><p>Java序列化是指那些实现了Serializable接口的对象转换为一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，序列化可以弥补不同操作系统之间的差异</p>
<p><strong>序列化/反序列化</strong></p>
<ul>
<li>实现Serializable接口，readObject和writeObject方法用于实现序列化机制，为了保证安全可以对不想实现序列化的字段用transient关键字修饰</li>
<li>实现ExternalSerializable方法，自己对要序列化的内容进行控制，控制哪些属性能被序列化，哪些不能被序列化</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li>被static修饰的属性不会被序列化</li>
<li>对象的类名、属性都会被序列化，方法不会</li>
<li>要保证序列化对象所在的类的属性也是可以被序列化的</li>
<li>当通过网络、文件进行序列化时，必须按照写入的顺序读取对象</li>
<li>反序列化时必须有序列化对象时的class文件</li>
</ul>
<h3 id="问题15-常见的序列化协议"><a href="#问题15-常见的序列化协议" class="headerlink" title="问题15 常见的序列化协议"></a>问题15 常见的序列化协议</h3><ul>
<li>XML&amp;SOAP</li>
<li>JSON</li>
<li>Protobuf</li>
<li>Avro</li>
</ul>
<h3 id="问题16-Java如何实现多线程"><a href="#问题16-Java如何实现多线程" class="headerlink" title="问题16 Java如何实现多线程"></a>问题16 Java如何实现多线程</h3><ul>
<li>继承Thread类，重写run函数</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ul>
<p>实现Runnable接口可以避免Java单继承特性带来的局限，同时代码可以被多个线程共享，代码和数据是独立的；适合多个相同程序代码的线程区处理同一资源。</p>
<p>继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中。</p>
<p>实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。</p>
<h3 id="问题17-如何保证线程安全"><a href="#问题17-如何保证线程安全" class="headerlink" title="问题17 如何保证线程安全"></a>问题17 如何保证线程安全</h3><ul>
<li>对变量使用volatile</li>
<li>对程序段进行加锁（synchronzied、lock）</li>
</ul>
<h3 id="问题18-多进程如何进行信息交互"><a href="#问题18-多进程如何进行信息交互" class="headerlink" title="问题18 多进程如何进行信息交互"></a>问题18 多进程如何进行信息交互</h3><p>Object中的方法，wait()/notify()/notifyAll()</p>
<h3 id="问题19-介绍下ThreadLocal"><a href="#问题19-介绍下ThreadLocal" class="headerlink" title="问题19 介绍下ThreadLocal"></a>问题19 介绍下ThreadLocal</h3><p>每个Thread都会有一个threadlocals变量，而threadlocals变量内部有一个ThreadLocalMap，该map的有多个Entry，每个Entry的key就是ThreadLocal变量，而value就是线程特有对象。</p>
<p>由于对key，即ThreadLocal对象是弱引用，而对线程特有对象是强引用，因此如果是线程池，比如SpringBoot时，Thread结束后没有被回收，此时Thread有个强引用指向ThreadLocalMap，ThreadLocalMap也有强引用指向value，这样就会导致value一直无法被回收。如果不是线程池，那就会在key为null之后到线程被销毁这段时间value造成伪内存泄漏</p>
<p>Java为了避免内存泄漏会在ThreadLocal的get，set方法时清理线程Map中key为null的value，但是如果是线程池之后没有使用ThreadLocal就无法清理了，因此我们在用完之后一定要使用remove方法手动清理</p>
<h3 id="问题20-什么是线程池"><a href="#问题20-什么是线程池" class="headerlink" title="问题20 什么是线程池"></a>问题20 什么是线程池</h3><p>线程池就是事先创建若干个可执行的线程放一个容器中，需要的时候从池中获取线程不用自动创建，使用完毕不用销毁放回池中即可。</p>
<p>一个线程池包括以下四个基本部分</p>
<ul>
<li>线程管理器，用于创建并管理线程池</li>
<li>工作线程</li>
<li>任务接口</li>
<li>任务队列</li>
</ul>
<h3 id="问题21-看过Java线程池源码吗"><a href="#问题21-看过Java线程池源码吗" class="headerlink" title="问题21 看过Java线程池源码吗"></a>问题21 看过Java线程池源码吗</h3><p>看过Executors的源码，其核心部分包括execute方法、addWorker方法、Worker类、runWorker方法和getTask方法</p>
<p>execute方法具体过程是如果当前活动线程数少于核心线程数，那么就会创建一个新的线程到线程池中，并把任务交给该线程；如果当前线程大于等于核心线程数，那么会放入缓存队列中等待，如果缓存满了，那么会创建一个新的线程放入线程池，并把任务添加到该线程中，如果活动线程数大于最大线程数那么就会拒绝。</p>
<p>addWorker方法具体过程是首先判断是否需要创建线程，不需要直接返回false，如果需要就新建一个Worker类，然后用该Worker对象的Thread对象来启动任务</p>
<p>Worker类有state、firstTask和thread三个成员变量，其中firstTask用于标记第一个任务</p>
<p>runWorker方法传入Worker对象，然后根据firstTask是否为null来判断是否要从队列中取。最后执行任务</p>
<p>getTask方法首先判断是否要进行超时控制，如果发生超时就从线程池里销毁这个线程，具体是通过返回null，然后GC；如果没有超时就从队列中取一个任务出来返回</p>
<p>具体代码可以查看<a href="https://xszzl.github.io/2020/02/20/Java线程池源码/" target="_blank" rel="noopener">https://xszzl.github.io/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/</a></p>
<h3 id="问题22-Java是否有内存泄漏和内存溢出"><a href="#问题22-Java是否有内存泄漏和内存溢出" class="headerlink" title="问题22 Java是否有内存泄漏和内存溢出"></a>问题22 Java是否有内存泄漏和内存溢出</h3><ul>
<li>静态集合类，比如Set集合中的元素已经为null了，但是被set引用着，无法被GC回收，从而造成了内存泄漏</li>
<li>监听器，往往在释放的时候没有删除这些监听器，也会造成内存泄漏</li>
<li>物理连接，比如数据库连接和网络连接，没有显示关闭连接是不会被GC回收的</li>
<li>内部类和外部模块等的引用</li>
<li>单例模式，如果单例持有一个外部对象的引用，那么该外部对象就不能被回收。</li>
</ul>
<h3 id="问题23-volatile关键字的作用"><a href="#问题23-volatile关键字的作用" class="headerlink" title="问题23 volatile关键字的作用"></a>问题23 volatile关键字的作用</h3><ul>
<li>保证内存的可见性</li>
<li>防止指令重排序，保证有序性</li>
<li>仅能保证long/double类型变量的原子性</li>
</ul>
<h3 id="问题24-volatile如何保证可见性和有序性"><a href="#问题24-volatile如何保证可见性和有序性" class="headerlink" title="问题24 volatile如何保证可见性和有序性"></a>问题24 volatile如何保证可见性和有序性</h3><ul>
<li><strong>有序性</strong>：Java虚拟机在volatile变量写操作之前插入的释放屏障使得该屏障之前的任何读写操作都会在写操作之前被提交；volatile读操作之后插入获取屏障，使得volatile读操作的提交先于之后的任何读写操作</li>
<li><strong>可见性</strong>：volatile保证可见性的原理是每次访问变量时都会进行一次刷新，访问主内存中的最新值。其底层原理是对于写操作，会在之后插入一个存储屏障，其作用是清空其处理器的写缓冲器，使得写缓冲器的内存更新到高速缓存中；对于读操作，会在其之前插入一个加载屏障，其作用是清空无效化队列，使得读操作能读取到其他处理器的共享变量所作的更新。高速缓存到主内存时MESI协议，当缓存条目为I，即无效时才会访问主内存</li>
</ul>
<h3 id="问题25-volatile在什么情况下可以代替锁"><a href="#问题25-volatile在什么情况下可以代替锁" class="headerlink" title="问题25 volatile在什么情况下可以代替锁"></a>问题25 volatile在什么情况下可以代替锁</h3><p>在多个线程共享一组状态变量时，可以将一组状态变量合并成一个对象，用一个volatile变量来引用该对象。</p>
<h3 id="问题26-sleep和wait的区别"><a href="#问题26-sleep和wait的区别" class="headerlink" title="问题26 sleep和wait的区别"></a>问题26 sleep和wait的区别</h3><ul>
<li>sleep是Thread类的方法，而wait是Object类的方法</li>
<li>sleep方法的作用是当前线程让出CPU资源，但是对象的锁依旧保持；而wait方法会让当前线程放弃对象的锁，进入对象的等待池，当调用对象的notify方法时该线程才有机会进入等锁池，如果获得锁就可以进入就绪状态了</li>
</ul>
<h3 id="问题27-synchronized和lock的区别"><a href="#问题27-synchronized和lock的区别" class="headerlink" title="问题27 synchronized和lock的区别"></a>问题27 synchronized和lock的区别</h3><ul>
<li>synchronized是隐式锁，而lock是显示锁</li>
<li>在性能方面，在JDK1.6之前synchronized是重量级锁，性能不如lock，但是在JDK1.6之后对synchronized有了很多优化，导致synchronized的性能不比lock差</li>
<li>synchronized使用的是CPU悲观锁机制，即独占锁，其他线程会被阻塞，而lock用的是乐观锁，即CAS操作</li>
</ul>
<h3 id="问题28-synchronized的底层实现"><a href="#问题28-synchronized的底层实现" class="headerlink" title="问题28 synchronized的底层实现"></a>问题28 synchronized的底层实现</h3><p>每个对象都有对象头，对象头里有一个Mark Word，存放了对象的hashCode、分代年龄、锁类型、锁标志位等信息。同时每个对象都自带了一把看不见的锁，monitor。</p>
<p>查看源码，发现有_owner字段，即持有monitor对象的线程，_EntryList字段表示对象的等待池，_WaitSet字段表示对象的等锁池</p>
<p>通过反编译我们可以看到，如果是同步代码块，其字节码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">monitorenter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">monitorexit</span><br><span class="line"></span><br><span class="line">monitorexit		<span class="comment">// 用于方法块发生异常时也能释放锁</span></span><br></pre></td></tr></table></figure>

<p>如果是同步方法，其字节码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags:... , ACC_SYNCHRONIZED	<span class="comment">// 执行线程会持有monitor</span></span><br></pre></td></tr></table></figure>

<h3 id="问题29-synchronized关键字的优化"><a href="#问题29-synchronized关键字的优化" class="headerlink" title="问题29 synchronized关键字的优化"></a>问题29 synchronized关键字的优化</h3><ul>
<li><strong>自旋锁</strong>：共享数据的锁定状态持续时间很短，不用切换线程，让当前线程忙等即可</li>
<li><strong>自适应自旋锁</strong>：自旋次数动态决定</li>
<li><strong>锁消除</strong>：去除不可能存在的竞争，比如局部变量StringBuffer的append方法</li>
<li><strong>锁粗化</strong>：加大加锁范围，避免反复加锁和解锁，比如循环中调用StringBuffer的append方法</li>
</ul>
<h3 id="问题30-synchronized锁的膨胀过程"><a href="#问题30-synchronized锁的膨胀过程" class="headerlink" title="问题30 synchronized锁的膨胀过程"></a>问题30 synchronized锁的膨胀过程</h3><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p>偏向锁即第一个线程获得锁，轻量级锁即出现第二个线程竞争锁，如果出现多个线程竞争锁就会变成重量级锁。其中偏向锁没有额外的性能消耗，轻量级锁则需要自旋，而重量级锁就会发生阻塞</p>
<h3 id="问题31-说一下Java中的异常"><a href="#问题31-说一下Java中的异常" class="headerlink" title="问题31 说一下Java中的异常"></a>问题31 说一下Java中的异常</h3><p>Throwable是java语言中所有错误和异常的超类，它有两个子类：Error和Exception。其中Error是程序无法处理的，要交由JVM处理，Exception是程序可以处理的异常，可以分为CheckedException和UncheckedException，即受检异常和非受检异常。受检异常是在编译期可以发现的，而非受检异常则是在运行期才会发生的</p>
<h3 id="问题32-Java中的NIO，BIO，AIO分别是什么"><a href="#问题32-Java中的NIO，BIO，AIO分别是什么" class="headerlink" title="问题32 Java中的NIO，BIO，AIO分别是什么"></a>问题32 Java中的NIO，BIO，AIO分别是什么</h3><ul>
<li><strong>BIO</strong>：同步并阻塞，服务器实现模式为一个连接一个线程</li>
<li><strong>NIO</strong>：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理</li>
<li><strong>AIO</strong>：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理</li>
</ul>
<h3 id="问题33-简单介绍下Java的NIO模型"><a href="#问题33-简单介绍下Java的NIO模型" class="headerlink" title="问题33 简单介绍下Java的NIO模型"></a>问题33 简单介绍下Java的NIO模型</h3><ul>
<li><strong>Selector</strong>：选择器，能够检测多个注册的通道上是否有事件发生，如果有就获取事件并做出相应的处理。实现单线程管理多个通道</li>
<li><strong>SelectionKey</strong>：代表了Selector和socketChannel的注册关系，有OP_ACCEPR、OP_CONNECT、OP_READ和OP_WRITE</li>
<li><strong>ServerSocketChannel</strong>：用来在服务器端监听新的客户端<strong>连接</strong></li>
<li><strong>SocketChannel</strong>：网络IO通道，具体负责进行<strong>读写</strong>操作。NIO总是把缓冲区的数据写入通道，或者把通道里的数据读出缓冲区</li>
</ul>
<h3 id="问题34-说说IO多路复用"><a href="#问题34-说说IO多路复用" class="headerlink" title="问题34 说说IO多路复用"></a>问题34 说说IO多路复用</h3><ul>
<li><strong>select</strong>：具体过程就是监听socket服务端，准备文件描述符数组fds作为通道，然后再用一个bitmap数据结构rset来作为标志位，代替fds。select函数的作用就是将rset的内容从用户态拷贝到内核态，内核态来负责每一个文件描述符是否有内容，如果没有就阻塞，如果有就将该位置位，然后select返回。</li>
<li><strong>poll</strong>：poll的工作原理和select相同，但是它使用一个存放了fd，events和revents的结构体来代替rset，poll函数当有数据时会将revent置位。同时在处理的时候可以将revent复位，这样就使得这个结构体数组可以重用，同时也可以避免了rset有长度限制的缺陷</li>
<li><strong>epoll</strong>：epoll使用的结构体epoll_event同样有fd和events字段，但是在epoll函数中，它不再需要用户态和内核态的切换，而是在共享区域进行操作，避免了状态切换带来的开销，其次是它将数组进行了排序，有数据的元素放在了前面，这样就避免了需要遍历整个数组的开销。</li>
</ul>
<h3 id="问题35-了解的设计模式"><a href="#问题35-了解的设计模式" class="headerlink" title="问题35 了解的设计模式"></a>问题35 了解的设计模式</h3><ul>
<li>工厂模式：定义一个用于创建对象的接口，让子类来决定实例化哪一个类</li>
<li>单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点</li>
<li>适配器模式：将一类的接口转换成用户希望的另一个接口</li>
<li>装饰者模式：动态地给一个对象增加一些额外的职责</li>
<li>代理：为其他对象提供一种代理以控制对这个对象的访问</li>
<li>迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示</li>
</ul>
<h3 id="问题36-手写单例模式"><a href="#问题36-手写单例模式" class="headerlink" title="问题36 手写单例模式"></a>问题36 手写单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class Single&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == s)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Single<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == s)&#123;</span><br><span class="line">                    s = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题37-JDK源码中用到的设计模式"><a href="#问题37-JDK源码中用到的设计模式" class="headerlink" title="问题37 JDK源码中用到的设计模式"></a>问题37 JDK源码中用到的设计模式</h3><ul>
<li>装饰器模式：IO流</li>
<li>迭代器模式：Iterator</li>
<li>单例模式：java.lang.Runtime</li>
<li>代理模式：RMI</li>
</ul>
<h3 id="问题38-简单说说匿名内部类"><a href="#问题38-简单说说匿名内部类" class="headerlink" title="问题38 简单说说匿名内部类"></a>问题38 简单说说匿名内部类</h3><p>匿名内部类是没有访问修饰符的，所以当所在方法的形参需要被内部匿名类使用，那么这个形参必须为final，同时内部匿名类是没有构造方法的。</p>
<h3 id="问题39-自定义的类对象能否作为key"><a href="#问题39-自定义的类对象能否作为key" class="headerlink" title="问题39 自定义的类对象能否作为key"></a>问题39 自定义的类对象能否作为key</h3><p>可以，只要重写equals方法和hashcode方法，保证对象的属性改变时，其hashcode不会发生变化即可</p>
<h3 id="问题40-为什么要实现内存模型"><a href="#问题40-为什么要实现内存模型" class="headerlink" title="问题40 为什么要实现内存模型"></a>问题40 为什么要实现内存模型</h3><p>内存模型就是为了在现代计算机平台中保证程序可以正确执行，但是不同的平台实现是不同的。比如编译器生成的指令顺序可能与源代码不同，编译器也可能把变量保存在寄存器中，而不是内存中；处理器可以乱序或者并行执行指令；缓存可能会改变写入变量提交到主内存的顺序；保存在处理器本地缓存中的值，对其他处理器是不可见的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/BlockingQueue%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/BlockingQueue%E6%BA%90%E7%A0%81/" itemprop="url">BlockingQueue源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T21:55:30+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/20/BlockingQueue%E6%BA%90%E7%A0%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/20/BlockingQueue%E6%BA%90%E7%A0%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,TimeUnit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long,TimeUnit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/20/BlockingQueue%E6%BA%90%E7%A0%81/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/" itemprop="url">Java线程池源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-20T21:55:19+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><h3 id="活动线程数量"><a href="#活动线程数量" class="headerlink" title="活动线程数量"></a>活动线程数量</h3>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/19/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/19/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%80/" itemprop="url">Java面经整理之一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T15:23:18+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/19/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%80/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/19/Java%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%80/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="问题1-HTTP和HTTPS的区别"><a href="#问题1-HTTP和HTTPS的区别" class="headerlink" title="问题1 HTTP和HTTPS的区别"></a>问题1 HTTP和HTTPS的区别</h3><ol>
<li><p>首先HTTP协议是运行在TCP之上的，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；而HTTPS协议是在HTTP运行在SSL/TLS之上的，而SSL/TLS是运行在TCP之上的，所有传输内容都是加密的，加密采用的是对称加密，但是对称加密的密钥用服务器方的证书进行了非对称加密，此外客户端可以验证服务器的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。</p>
</li>
<li><p>https协议是需要申请证书的，收费的</p>
</li>
<li><p>http的端口一般默认是80端口，而https的默认端口一般是443</p>
</li>
</ol>
<h3 id="问题2-TCP如何保证可靠性"><a href="#问题2-TCP如何保证可靠性" class="headerlink" title="问题2 TCP如何保证可靠性"></a>问题2 TCP如何保证可靠性</h3><ul>
<li>数据包校验，使用16位校验和字段</li>
<li>超时重传机制，重传计时器</li>
<li>应答机制，确认序号ack</li>
<li>对失序数据包重排序，包序号解决seq</li>
<li>TCP还能提供流量控制，窗口大小字段控制</li>
</ul>
<h3 id="问题3-TCP的三次握手"><a href="#问题3-TCP的三次握手" class="headerlink" title="问题3 TCP的三次握手"></a>问题3 TCP的三次握手</h3><p>SYN标志位表示发起连接</p>
<ol>
<li>A -&gt; B SYN = 1,seq = x，之后A处于SYN_SEND状态</li>
<li>B -&gt; A SYN = 1, ACK = 1, ack = x + 1, seq = y，之后B处于SYN_RCVD状态</li>
<li>A -&gt; B ACK = 1, ack = y + 1, seq = x + 1，此时A已经处于ESTABLISHED</li>
</ol>
<h3 id="问题4-TCP的四次挥手"><a href="#问题4-TCP的四次挥手" class="headerlink" title="问题4 TCP的四次挥手"></a>问题4 TCP的四次挥手</h3><ol>
<li>A -&gt; B FIN = 1,seq = x，之后A处于FIN_WAIT-1状态</li>
<li>B -&gt; A ACK = 1, ack = x + 1，之后B处于CLOSED-WAIT状态，B要去结束一些进程来保证可以顺利关闭连接</li>
<li>B -&gt; A FIN = 1, ACK = 1, ack = x + 1,seq = y，此时B处于LAST-ACK状态</li>
<li>A -&gt; B ACK = 1,ack = y + 1，此时A处于TIME-WAIT状态，即需要等待2MSL（报文最大生存时间），用于防止B没有收到A发送的ACK，导致B重发FIN，2MSL能保证A能收到B重发的包</li>
</ol>
<h3 id="问题5-TCP连接为什么需要三次握手，两次可以吗"><a href="#问题5-TCP连接为什么需要三次握手，两次可以吗" class="headerlink" title="问题5 TCP连接为什么需要三次握手，两次可以吗"></a>问题5 TCP连接为什么需要三次握手，两次可以吗</h3><p>为了防止失效的连接请求报文突然又传到了服务器，发生错误。</p>
<p>比如此时服务器会回一个SYN=1,ACK=1,ack = l+1,seq = i的包，然后客户端收到之后检测发现发来的包的ack对不上就拒绝连接，服务器没收到ack=i+1的包也就不会连接。如果只有两次握手，服务器就会处于连接状态了。</p>
<h3 id="问题6-什么是DDos攻击"><a href="#问题6-什么是DDos攻击" class="headerlink" title="问题6 什么是DDos攻击"></a>问题6 什么是DDos攻击</h3><p>所谓DDos攻击就是客户端一直向服务器发起建立连接请求，但是收到服务器的SYN=1,ACK=1,ack = x+1的第二个包之后，不发送第三个包，则此时服务器会等到30s到2min才能将此连接进行关闭。如果一直发，服务器就会有大量的资源用于等待第三个ACK包</p>
<h3 id="问题7-GET和POST的区别"><a href="#问题7-GET和POST的区别" class="headerlink" title="问题7 GET和POST的区别"></a>问题7 GET和POST的区别</h3><ul>
<li>POST一般用来更新数据，而GET一般用来查询数据</li>
<li>GET请求是明文传输的，一般拼接在URL中，长度有限，而POST请求不是明文传输的，安全性更高，同时没有长度限制</li>
<li>GET请求具有幂等性</li>
<li>POST请求不能被缓存</li>
</ul>
<h3 id="问题8-TCP和UDP的区别"><a href="#问题8-TCP和UDP的区别" class="headerlink" title="问题8 TCP和UDP的区别"></a>问题8 TCP和UDP的区别</h3><ol>
<li>UDP是无连接的，而TCP需要进行三次握手</li>
<li>UDP不保证可靠交付，而TCP有可靠的，有重传机制（计时器），保证有序(seq)，应答机制(ack)，流量控制（窗口大小）和数据包校验（校验和）</li>
<li>UDP是面向报文的，不会对大数据包进行拆分，而TCP会对大数据包进行拆分，然后在接收方进行重组。</li>
<li>UDP支持一对一，一对多和多对多的交互通信，而TCP只支持一对一</li>
<li>UDP的头部为8个字节，TCP为20个字节</li>
</ol>
<h3 id="问题9-流量控制"><a href="#问题9-流量控制" class="headerlink" title="问题9 流量控制"></a>问题9 流量控制</h3><p>流量控制就是指当接收方处理太慢时，导致缓存中没有空间，无法继续接收，此时可以改变TCP头中的窗口大小字段，那么发送方也会随之改变，只会让左指针右移，右指针不变，从而窗口大小减一，也不会发送数据。</p>
<h3 id="问题10-拥塞控制"><a href="#问题10-拥塞控制" class="headerlink" title="问题10 拥塞控制"></a>问题10 拥塞控制</h3><p>流量控制是防止接收方缓存塞满，拥塞控制是防止把网络塞满</p>
<ol>
<li>慢启动，指数增长，直到ssthresh，一般为65535个字节</li>
<li>拥塞避免，线性增长，（1/拥塞控制窗口大小）</li>
<li>拥塞发生，将ssthresh设为当前cwnd/2，将cwnd设为1，重新开始慢启动</li>
<li>快速重传，比如6，8，9已经被服务器接收，此时服务器会发出三个ack=6的ACK包，要求客户端发送7。此时客户端不会等待超时，直接发送7。cwnd变为cwnd/2，ssthresh=cwnd，继续处于拥塞避免阶段</li>
</ol>
<p>3和4选其一，3快速下降会导致网络卡断</p>
<h3 id="问题11-输入网址之后发生了什么"><a href="#问题11-输入网址之后发生了什么" class="headerlink" title="问题11 输入网址之后发生了什么"></a>问题11 输入网址之后发生了什么</h3><ol>
<li>查询DNS，获取域名对应的IP地址。浏览器DNS缓存-&gt;操作系统-&gt;本地的HOST文件-&gt;发起一个DNS的系统调用</li>
<li>根据IP地址发起HTTP/TCP三次握手</li>
<li>TCP/IP建立起来后，浏览器向服务器发送HTTP请求</li>
<li>服务器接收请求，处理之后生成HTML页面代码返回给浏览器</li>
<li>浏览器解析和渲染HTML，如果有JS和CSS同样是一个个完整的HTTP请求</li>
</ol>
<h3 id="问题12-HTTP1-0、HTTP1-1以及HTTP2-0的区别"><a href="#问题12-HTTP1-0、HTTP1-1以及HTTP2-0的区别" class="headerlink" title="问题12 HTTP1.0、HTTP1.1以及HTTP2.0的区别"></a>问题12 HTTP1.0、HTTP1.1以及HTTP2.0的区别</h3><p>HTTP1.0是一种无状态，无连接的协议，每次请求都需要建立一次TCP连接</p>
<p>HTTP1.1是长连接的，但是必须按客户端的请求顺序处理，不允许并行。</p>
<p>HTTP2.0增加了二进制分帧，多路复用，服务器推送等功能。</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="问题1-什么是索引"><a href="#问题1-什么是索引" class="headerlink" title="问题1 什么是索引"></a>问题1 什么是索引</h3><p>索引是对数据库表一列或多列数据进行排序的结构。可以加快数据库表的检索速度，尤其是在分组和排序的时候有明显效果。但是创建和维护索引需要代价。</p>
<h3 id="问题2-索引在什么情况下会失效"><a href="#问题2-索引在什么情况下会失效" class="headerlink" title="问题2 索引在什么情况下会失效"></a>问题2 索引在什么情况下会失效</h3><ol>
<li>条件中有or</li>
<li>对于多列索引，不是使用的第一部分（最左前缀匹配）</li>
<li>like查询是以%开头的</li>
<li>如果列类型是字符串，那么不带引号也不会用索引</li>
<li>如果全表扫描更快，那么也不会用索引</li>
</ol>
<h3 id="问题3-最左前缀匹配"><a href="#问题3-最左前缀匹配" class="headerlink" title="问题3 最左前缀匹配"></a>问题3 最左前缀匹配</h3><p>对于3列索引(col1, col2, col3)，会创建(col1)、(col1, col2)、(col1, col2, col3)的索引</p>
<p>mysql会向右匹配直到遇到范围查询</p>
<p>=和in可以乱序，mysql会自动优化</p>
<h3 id="问题4-索引的数据结构"><a href="#问题4-索引的数据结构" class="headerlink" title="问题4 索引的数据结构"></a>问题4 索引的数据结构</h3><p><strong>B树</strong>每个节点有K-1个元素，K个孩子，其中 ceil(m/2) ≤ K ≤ m，且元素是从小到达排的，Ai的孩子的元素都比K_i+1小</p>
<p><img src="https://img-blog.csdn.net/2018032420113990?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>B树相对于二叉树变成多路查找树，每个节点存放的信息更多，那就可以减少IO磁盘读写，并且是在内存中比较的，所以减少大量时间。</p>
<p><strong>B+树</strong>有K个子树的中间节点包含K个元素，每个元素不保存数据，只用作索引，数据都在叶结点上。叶节点中包含全部元素的信息，及指向含这些元素记录的指针，叶子节点本身按照关键字排序</p>
<p><img src="https://img-blog.csdn.net/20180325001555181?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>B+树的查询都会落到叶子节点，查询更加稳定，而B树有些数据在中间节点，不稳定；B+树的中间节点只存放索引，相对B+树更小，因此同样的空间可以读入更多的节点，所以B+树的磁盘读写代价更低。</p>
<h3 id="问题5-什么情况下适合建立索引"><a href="#问题5-什么情况下适合建立索引" class="headerlink" title="问题5 什么情况下适合建立索引"></a>问题5 什么情况下适合建立索引</h3><ul>
<li>order by、group by、distinct后面的字段</li>
<li>在union等集合操作的结果集字段</li>
<li>经常用作查询选择的字段</li>
<li>经常用作表连接的字段</li>
<li>很少更新的表中只用到的那几个字段</li>
</ul>
<h3 id="问题6-MySQL的逻辑架构"><a href="#问题6-MySQL的逻辑架构" class="headerlink" title="问题6 MySQL的逻辑架构"></a>问题6 MySQL的逻辑架构</h3><ul>
<li>连接器</li>
<li>分析器</li>
<li>优化器</li>
<li>执行器</li>
<li>存储引擎层</li>
</ul>
<h3 id="问题7-InnoDB和MyISAM的区别"><a href="#问题7-InnoDB和MyISAM的区别" class="headerlink" title="问题7 InnoDB和MyISAM的区别"></a>问题7 InnoDB和MyISAM的区别</h3><ul>
<li>MyISAM不支持事务，InnoDB支持事务</li>
<li>MyISAM的锁为表锁，而InnoDB支持行锁和表级锁，默认为行锁</li>
<li>MyISAM支持全文索引，而InnoDB不支持</li>
<li>MyISAM相对简单，因此其效率要优于InnoDB</li>
</ul>
<h3 id="问题8-MySQL的日志"><a href="#问题8-MySQL的日志" class="headerlink" title="问题8 MySQL的日志"></a>问题8 MySQL的日志</h3><ul>
<li>redo log是InnoDB特有的，而binlog是MySQL的Server层实现的，所有引擎都可以使用</li>
<li>redo log是物理日志，记录的是“在某个数据页做了什么操作”；而binlog是逻辑日志，记录的是这个语句的原始逻辑</li>
<li>redo log是循环写的，空间固定会用完；binlog是可以追加写入的。</li>
</ul>
<p>其中redo log有两阶段，分别是prepare和commit，binlog在两阶段中间，这样可以保证发生意外恢复后两份日志和数据的一致性</p>
<h3 id="问题9-事务隔离级别"><a href="#问题9-事务隔离级别" class="headerlink" title="问题9 事务隔离级别"></a>问题9 事务隔离级别</h3><ul>
<li>串行化，可以避免幻读</li>
<li>可重复读，所有被select获取的数据不允许被修改，这样就可以避免不可重复读，但是未被获取的数据可以被增加，因此无法避免幻读。</li>
<li>读已提交，读取的事务允许其他事务继续访问，但未提交的写事务禁止访问。获取读锁，读完就释放，获取写锁，直到事务结束。可以避免脏读</li>
<li>读未提交，允许其他事务看到没有提交的事务，会发生脏读</li>
</ul>
<h3 id="问题10-事务的ACID"><a href="#问题10-事务的ACID" class="headerlink" title="问题10 事务的ACID"></a>问题10 事务的ACID</h3><ul>
<li>原子性：事务中的所有操作全部执行或者全部不执行</li>
<li>一致性：保证数据库的数据总是从一个一致性状态到另一个一致性状态</li>
<li>隔离性：多个事务并发执行，结果应该与多个事务串行执行效果一样，即各个事务互不干扰</li>
<li>持久性：事务操作完成后，对数据库的影响是持久的</li>
</ul>
<h3 id="问题11-数据库范式"><a href="#问题11-数据库范式" class="headerlink" title="问题11 数据库范式"></a>问题11 数据库范式</h3><ul>
<li>1NF：符合1NF的关系中每个属性都不可再分</li>
<li>2NF：每一个非主属性完全依赖R的码，消除非主属性对码的部分依赖</li>
<li>3NF：不存在这样的码X，属性组Y以及非主属性Z，使得X-&gt;Y,Y-&gt;Z成立。即X-&gt;Y，要么X含有码，要么Y是主属性。消除了非主属性对码的传递依赖</li>
<li>BCNF：如果X-&gt;Y且Y不属于X，则X必含有码。消除了主属性对码的部分函数依赖和传递函数依赖</li>
<li>4NF：要求把同一表中多对多的关系删除</li>
<li>5NF：从最终结构重新建立原始结构</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="问题1-什么是redis"><a href="#问题1-什么是redis" class="headerlink" title="问题1 什么是redis"></a>问题1 什么是redis</h3><p>redis是一款高性能的分布式内存数据库，基于内存并支持持久化的NoSQL数据库，它的五种基本数据结构包括string、list、set、sorted set、hash。</p>
<h3 id="问题2-redis相比memcached的优势"><a href="#问题2-redis相比memcached的优势" class="headerlink" title="问题2 redis相比memcached的优势"></a>问题2 redis相比memcached的优势</h3><ul>
<li>memcached仅支持字符串，而redis支持的数据类型更加丰富</li>
<li>redis的速度要快于memcached，并且支持数据的持久化</li>
<li>redis支持数据备份，即master-slave模式</li>
</ul>
<h3 id="问题3-redis是单线程的为什么执行速度这么快"><a href="#问题3-redis是单线程的为什么执行速度这么快" class="headerlink" title="问题3 redis是单线程的为什么执行速度这么快"></a>问题3 redis是单线程的为什么执行速度这么快</h3><ul>
<li>基于内存实现，完全内存计算</li>
<li>单线程操作，避免了线程的上下文切换</li>
<li>多路I/O复用的线程模型，实现了一个线程监控多个IO流，及时响应请求</li>
<li>redis对外部的依赖比较少，属于轻量级内存数据库</li>
</ul>
<h3 id="问题4-redis会出现什么问题"><a href="#问题4-redis会出现什么问题" class="headerlink" title="问题4 redis会出现什么问题"></a>问题4 redis会出现什么问题</h3><ul>
<li>缓存雪崩</li>
<li>缓存穿透</li>
<li>数据库和缓存的双写一致问题</li>
</ul>
<h3 id="问题5-redis的持久化方式"><a href="#问题5-redis的持久化方式" class="headerlink" title="问题5 redis的持久化方式"></a>问题5 redis的持久化方式</h3><ul>
<li><strong>RDB</strong>快照方式：将当前内存里的数据集快照写入磁盘。包括自动触发和手动触发，手动触发redis进程会fork一个子进程，让子进程去负责快照，redis会在fork子进程期间被阻塞</li>
<li><strong>AOF</strong>增量持久化：记录redis服务器所执行的写命令来记录数据库状态。AOF文件会随着服务器的运行而增大，因此需要AOF重写。AOF重写会读取数据库的现有状态，然后根据类型用一条命令来替代前面对键值对的多条命令。AOF重写也是在子进程中执行的，而在子进程执行AOF重写期间，redis服务器执行的写命令会记录在AOF重写缓冲区中。当子进程完成AOF日志重写后，给父进程发生信号，父进程接收信号后将AOF重写缓冲区的内容交给子进程以保证数据的一致性。</li>
</ul>
<h3 id="问题6-redis数据过期挥手策略"><a href="#问题6-redis数据过期挥手策略" class="headerlink" title="问题6 redis数据过期挥手策略"></a>问题6 redis数据过期挥手策略</h3><ul>
<li>定期删除</li>
<li>惰性删除，再次访问时如果过期才会删除</li>
</ul>
<h3 id="问题7-redis对事务的支持"><a href="#问题7-redis对事务的支持" class="headerlink" title="问题7 redis对事务的支持"></a>问题7 redis对事务的支持</h3><p>redis是单线程的程序，所以只需要保证在执行事务时不会被中断即可，事务可以运行直到执行完所有事务队列中的命令为止。</p>
<p>redis不支持回滚操作。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="问题1-介绍一下kafka"><a href="#问题1-介绍一下kafka" class="headerlink" title="问题1 介绍一下kafka"></a>问题1 介绍一下kafka</h3><p>kafka是一个消息队列，可以实现发布订阅模式。在异步通信或者生产者和消费者需要解耦的场景经常使用，可以对数据流进行处理。kafka支持消息的快速持久化，支持批量读写，支持消息分区，并为分区创建多个副本等。</p>
<h3 id="问题2-kafka使用磁盘存储，为什么具有高性能"><a href="#问题2-kafka使用磁盘存储，为什么具有高性能" class="headerlink" title="问题2 kafka使用磁盘存储，为什么具有高性能"></a>问题2 kafka使用磁盘存储，为什么具有高性能</h3><ul>
<li>顺序读写磁盘</li>
<li>页缓存，将磁盘中的数据缓存到内存中</li>
<li>零拷贝，直接将数据拷贝到网卡设备，不经过应用程序</li>
</ul>
<h3 id="问题3-kafka中的核心概念"><a href="#问题3-kafka中的核心概念" class="headerlink" title="问题3 kafka中的核心概念"></a>问题3 kafka中的核心概念</h3><ul>
<li>生产者</li>
<li>消费者</li>
<li>分区，每个Topic可以划分成多个分区</li>
<li>副本，分为leader副本和followe副本，follower副本仅仅是将数据从leader副本中拉取下来，保存到本地</li>
<li>消费者组，每条消息只能被消费者组中的一个消费者消费，但是能被多个消费者组消费</li>
<li>Broker：server</li>
<li>Cluster：多个Broker组成一个Cluster集群，每个Cluster集群可以选举一个Broker来作为Controller</li>
</ul>
<h3 id="问题4-介绍kafka的副本机制"><a href="#问题4-介绍kafka的副本机制" class="headerlink" title="问题4 介绍kafka的副本机制"></a>问题4 介绍kafka的副本机制</h3><p>ISR+HW+LEO</p>
<p>ISR表示可用副本集合，HW表示高水位，消费者处理消息时只能拉取到HW之前的消息，LEO是副本的offset标记。</p>
<ul>
<li>消费者向分区推送消息</li>
<li>Leader副本写日志，并且递增LEO</li>
<li>Follower副本从leader副本拉取消息进行同步</li>
<li>Follower副本写日志，并且递增LEO</li>
<li>当ISR集合中所有副本完成消息同步，leader副本递增其HW</li>
</ul>
<p>ISR的存在可以当Follower副本延迟过高时将他踢出ISR集合，避免了高延迟的Follower副本影响整个集群（消除了同步复制的问题），同时如果leader集合所在的broker宕机，会优先从ISR集合中的Follower副本选举为leader（消除异步复制的问题）。</p>
<h3 id="问题5-kafka的文件存储机制"><a href="#问题5-kafka的文件存储机制" class="headerlink" title="问题5 kafka的文件存储机制"></a>问题5 kafka的文件存储机制</h3><p>kafka中消息是以topic进行分类的，生产者通过topic向broker发送消息，消费者通过topic读取数据。topic在物理层面又能以partition为分组，一个topic可以分成若干个partition，partition还可以细分为segment。</p>
<h3 id="问题6-kafka传输的三大语义"><a href="#问题6-kafka传输的三大语义" class="headerlink" title="问题6 kafka传输的三大语义"></a>问题6 kafka传输的三大语义</h3><ul>
<li>at most once：最多一次</li>
<li>at least once：最少一次</li>
<li>Exactly once：恰好一次</li>
</ul>
<h3 id="问题7-kafka中可靠性的配置"><a href="#问题7-kafka中可靠性的配置" class="headerlink" title="问题7 kafka中可靠性的配置"></a>问题7 kafka中可靠性的配置</h3><ul>
<li><strong>request.required.acks</strong>：1（默认），leader确认即可；0：无需等待broker的回复；-1：需要ISR中所有follower都回复确认才可以。</li>
<li><strong>min.insync.replicas</strong>：ISR集合中的最小副本个数</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="问题1-产生死锁的必要条件"><a href="#问题1-产生死锁的必要条件" class="headerlink" title="问题1 产生死锁的必要条件"></a>问题1 产生死锁的必要条件</h3><ul>
<li>条件互斥，即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。</li>
<li>不可抢占</li>
<li>占有且申请，在占有资源的同时又去申请新的资源导致阻塞，并且继续占有不释放资源</li>
<li>循环等待，比如P1等待P2的资源，P2又等待P1的资源，构成了一个循环</li>
</ul>
<h3 id="问题2-如何避免死锁问题"><a href="#问题2-如何避免死锁问题" class="headerlink" title="问题2 如何避免死锁问题"></a>问题2 如何避免死锁问题</h3><ul>
<li>打破互斥条件，即允许进程同时访问某些资源。并无使用价值</li>
<li>打破不可抢占条件，即允许进程强行从占有者那里夺取某些资源。具体实现是当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足，它必须释放所占有的全部资源，这些资源就可以被其他进程抢占了。</li>
<li>打破占有且申请条件。即进程在运行前一次性地向系统申请它所需要的全部资源，只有都能满足时才分配。</li>
<li>打破循环等待条件，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按照资源序号递增的顺序提出。</li>
</ul>
<h3 id="问题3-进程间通信有哪几种方式"><a href="#问题3-进程间通信有哪几种方式" class="headerlink" title="问题3 进程间通信有哪几种方式"></a>问题3 进程间通信有哪几种方式</h3><ul>
<li>管道PIPE：管道可用于具有亲缘关系的进程间的通信</li>
<li>命名管道FIFO：允许无亲缘关系进程间的通信。通过命令mkfifo来创建</li>
<li>信号Signal：用于通知接收进程某种事件发生了</li>
<li>消息队列，消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷</li>
<li>共享内存：使得多个进程可以访问同一块内存空间</li>
<li>内存映射：允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现</li>
<li>信号量semaphore：主要作为进程间以及同一进程不同线程之间的同步手段</li>
<li>套接字socket：可以用于不同机器之间的进程间通信。</li>
</ul>
<h3 id="问题4-进程同步与阻塞"><a href="#问题4-进程同步与阻塞" class="headerlink" title="问题4 进程同步与阻塞"></a>问题4 进程同步与阻塞</h3><p>同步就是在发出一个调用时，在没有得到结果之前不会返回，而异步则是调用发出之后，调用就返回了，被调用者通过状态、通知等来通知调用者，或者通过回调函数处理这个调用。</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。非阻塞调用是指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>同步与阻塞没有任何关系。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="问题1-grep命令"><a href="#问题1-grep命令" class="headerlink" title="问题1 grep命令"></a>问题1 grep命令</h3><p>grep使用正则表达式搜索文本，并把匹配的行打印出来</p>
<p>下面的命令可以用于在file.log文件中查找”password”字段，并统计出现次数</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="string">"password"</span> <span class="keyword">file</span>.<span class="built_in">log</span> -<span class="keyword">c</span></span><br></pre></td></tr></table></figure>

<h3 id="问题2-awk命令"><a href="#问题2-awk命令" class="headerlink" title="问题2 awk命令"></a>问题2 awk命令</h3><p>awk命令主要是将一行分为多个字段处理，格式如下</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">awk</span> [-<span class="variable">F</span> <span class="variable">field</span>-<span class="variable">separator</span>] <span class="string">'commands'</span> <span class="variable">input</span>-<span class="function"><span class="title">file</span>(<span class="variable">s</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="问题3-top和ps命令"><a href="#问题3-top和ps命令" class="headerlink" title="问题3 top和ps命令"></a>问题3 top和ps命令</h3><p>ps命令用于显示运行在当前控制台下的属于当前用户的进程。可以通过ps -ef| grep “java”来找出进程中包含java的所有进程</p>
<p>top命令可以实时监控进程，相对于ps查看进程，top还可以监控系统性能，可以操作进程</p>
<h3 id="问题4-sed命令"><a href="#问题4-sed命令" class="headerlink" title="问题4 sed命令"></a>问题4 sed命令</h3><p>sed命令是利用脚本来处理文本文件。sed可按照脚本的指令来处理、编辑文本文件。</p>
<h3 id="问题5-其他命令"><a href="#问题5-其他命令" class="headerlink" title="问题5 其他命令"></a>问题5 其他命令</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正序排序 <span class="keyword">sort</span> -<span class="keyword">n</span> <span class="keyword">test</span>.txt</span><br><span class="line">逆序排序 <span class="keyword">sort</span> -nr <span class="keyword">test</span>.txt</span><br><span class="line">查看文件最后两行 tail -<span class="keyword">n</span> 2 <span class="keyword">file</span>.<span class="keyword">log</span></span><br><span class="line">查看文件开始两行 head -<span class="keyword">n</span> 2 <span class="keyword">file</span>.<span class="keyword">log</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoShanUzi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiaoShanUzi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/12/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">牛客专栏-面试常考设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-12T16:51:19+08:00">
                2020-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F/" itemprop="url" rel="index">
                    <span itemprop="name">牛客专栏</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/12/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/12/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="面试常考设计模式"><a href="#面试常考设计模式" class="headerlink" title="面试常考设计模式"></a>面试常考设计模式</h2><h3 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h3>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/12/%E7%89%9B%E5%AE%A2%E4%B8%93%E6%A0%8F-%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="XiaoShanUzi" />
            
              <p class="site-author-name" itemprop="name">XiaoShanUzi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xszzl" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1191315155@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiaoShanUzi</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->

<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'Nj9RsSmy8CMSkpzPmoVAX8CW-gzGzoHsz',
        appKey: '7bKhqX57xz7vSCOyfY17QRUJ',
        placeholder: '说点什么吧',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
